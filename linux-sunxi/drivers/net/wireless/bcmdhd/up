aiutils.c:2: * Misc utility routines for accessing chip-specific features
aiutils.c:3: * of the SiliconBackplane-based Broadcom chips.
aiutils.c:5: * Copyright (C) 1999-2012, Broadcom Corporation
aiutils.c:25: * $Id: aiutils.c 347614 2012-07-27 10:24:51Z $
aiutils.c:75:		SI_VMSG(("  after %d invalid and %d non-matching entries\n", inv, nom));
aiutils.c:91:		(*eromptr)--;
aiutils.c:129:	erombase = R_REG(sii->osh, &cc->eromptr);
aiutils.c:131:	switch (BUSTYPE(sih->bustype)) {
aiutils.c:138:		sii->curwrap = (void *)((uintptr)regs + SI_CORE_SIZE);
aiutils.c:141:		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, erombase);
aiutils.c:152:		SI_ERROR(("Don't know how to do AXI enumertion on bus %d\n", sih->bustype));
aiutils.c:171:			SI_VMSG(("Found END of erom after %d cores\n", sii->numcores));
aiutils.c:194:		         mfg, cid, crev, eromptr - 1, nmw, nsw, nmp, nsp));
aiutils.c:207:					sii->oob_router = addrl;
aiutils.c:214:		idx = sii->numcores;
aiutils.c:216:		sii->cia[idx] = cia;
aiutils.c:217:		sii->cib[idx] = cib;
aiutils.c:218:		sii->coreid[idx] = remap_coreid(sih, cid);
aiutils.c:258:		sii->coresba[idx] = addrl;
aiutils.c:259:		sii->coresba_size[idx] = sizel;
aiutils.c:266:				sii->coresba2[idx] = addrl;
aiutils.c:267:				sii->coresba2_size[idx] = sizel;
aiutils.c:302:				sii->wrapba[idx] = addrl;
aiutils.c:319:				sii->wrapba[idx] = addrl;
aiutils.c:328:		sii->numcores++;
aiutils.c:334:	sii->numcores = 0;
aiutils.c:348:	if (coreidx >= MIN(sii->numcores, SI_MAXCORES))
aiutils.c:351:	addr = sii->coresba[coreidx];
aiutils.c:352:	wrap = sii->wrapba[coreidx];
aiutils.c:358:	ASSERT((sii->intrsenabled_fn == NULL) || !(*(sii)->intrsenabled_fn)((sii)->intr_arg));
aiutils.c:360:	switch (BUSTYPE(sih->bustype)) {
aiutils.c:363:		if (!sii->regs[coreidx]) {
aiutils.c:364:			sii->regs[coreidx] = REG_MAP(addr, SI_CORE_SIZE);
aiutils.c:365:			ASSERT(GOODREGS(sii->regs[coreidx]));
aiutils.c:367:		sii->curmap = regs = sii->regs[coreidx];
aiutils.c:368:		if (!sii->wrappers[coreidx]) {
aiutils.c:369:			sii->wrappers[coreidx] = REG_MAP(wrap, SI_CORE_SIZE);
aiutils.c:370:			ASSERT(GOODREGS(sii->wrappers[coreidx]));
aiutils.c:372:		sii->curwrap = sii->wrappers[coreidx];
aiutils.c:378:		sii->curmap = regs = (void *)((uintptr)addr);
aiutils.c:379:		sii->curwrap = (void *)((uintptr)wrap);
aiutils.c:389:	sii->curmap = regs;
aiutils.c:390:	sii->curidx = coreidx;
aiutils.c:405:	for (i = 0; i < sii->numcores; i++) {
aiutils.c:406:		if (sii->coreid[i] == CC_CORE_ID) {
aiutils.c:407:			cc = (chipcregs_t *)sii->regs[i];
aiutils.c:414:	erombase = R_REG(sii->osh, &cc->eromptr);
aiutils.c:418:	cidx = sii->curidx;
aiutils.c:419:	cia = sii->cia[cidx];
aiutils.c:420:	cib = sii->cib[cidx];
aiutils.c:461:			if (!asidx--) {
aiutils.c:495:	cidx = sii->curidx;
aiutils.c:498:		return sii->coresba[cidx];
aiutils.c:500:		return sii->coresba2[cidx];
aiutils.c:516:	cidx = sii->curidx;
aiutils.c:519:		return sii->coresba_size[cidx];
aiutils.c:521:		return sii->coresba2_size[cidx];
aiutils.c:538:		return sii->curidx;
aiutils.c:542:		return sii->curidx;
aiutils.c:544:	ai = sii->curwrap;
aiutils.c:546:	return (R_REG(sii->osh, &ai->oobselouta30) & 0x1f);
aiutils.c:558:	uint32 *map = (uint32 *) sii->curwrap;
aiutils.c:561:		uint32 w = R_REG(sii->osh, map+(offset/4));
aiutils.c:564:		W_REG(sii->osh, map+(offset/4), val);
aiutils.c:567:	return (R_REG(sii->osh, map+(offset/4)));
aiutils.c:577:	cia = sii->cia[sii->curidx];
aiutils.c:588:	cib = sii->cib[sii->curidx];
aiutils.c:599:	ai = sii->curwrap;
aiutils.c:601:	return (((R_REG(sii->osh, &ai->ioctrl) & (SICF_FGC | SICF_CLOCK_EN)) == SICF_CLOCK_EN) &&
aiutils.c:602:	        ((R_REG(sii->osh, &ai->resetctrl) & AIRC_RESET) == 0));
aiutils.c:633:	if (BUSTYPE(sih->bustype) == SI_BUS) {
aiutils.c:637:		if (!sii->regs[coreidx]) {
aiutils.c:638:			sii->regs[coreidx] = REG_MAP(sii->coresba[coreidx],
aiutils.c:640:			ASSERT(GOODREGS(sii->regs[coreidx]));
aiutils.c:642:		r = (uint32 *)((uchar *)sii->regs[coreidx] + regoff);
aiutils.c:643:	} else if (BUSTYPE(sih->bustype) == PCI_BUS) {
aiutils.c:646:		if ((sii->coreid[coreidx] == CC_CORE_ID) && SI_FAST(sii)) {
aiutils.c:650:			r = (uint32 *)((char *)sii->curmap + PCI_16KB0_CCREGS_OFFSET + regoff);
aiutils.c:651:		} else if (sii->pub.buscoreidx == coreidx) {
aiutils.c:657:				r = (uint32 *)((char *)sii->curmap +
aiutils.c:660:				r = (uint32 *)((char *)sii->curmap +
aiutils.c:671:		origidx = si_coreidx(&sii->pub);
aiutils.c:674:		r = (uint32*) ((uchar*) ai_setcoreidx(&sii->pub, coreidx) + regoff);
aiutils.c:680:		w = (R_REG(sii->osh, r) & ~mask) | val;
aiutils.c:681:		W_REG(sii->osh, r, w);
aiutils.c:685:	w = R_REG(sii->osh, r);
aiutils.c:690:			ai_setcoreidx(&sii->pub, origidx);
aiutils.c:708:	ASSERT(GOODREGS(sii->curwrap));
aiutils.c:709:	ai = sii->curwrap;
aiutils.c:712:	if (R_REG(sii->osh, &ai->resetctrl) & AIRC_RESET)
aiutils.c:716:	SPINWAIT(((status = R_REG(sii->osh, &ai->resetstatus)) != 0), 300);
aiutils.c:722:		SPINWAIT(((status = R_REG(sii->osh, &ai->resetstatus)) != 0), 10000);
aiutils.c:727:	W_REG(sii->osh, &ai->ioctrl, bits);
aiutils.c:728:	dummy = R_REG(sii->osh, &ai->ioctrl);
aiutils.c:732:	W_REG(sii->osh, &ai->resetctrl, AIRC_RESET);
aiutils.c:733:	dummy = R_REG(sii->osh, &ai->resetctrl);
aiutils.c:738:/* reset and re-enable a core
aiutils.c:740: * bits - core specific bits that are set during and after reset sequence
aiutils.c:741: * resetbits - core specific bits that are set only during reset sequence
aiutils.c:751:	ASSERT(GOODREGS(sii->curwrap));
aiutils.c:752:	ai = sii->curwrap;
aiutils.c:762:	W_REG(sii->osh, &ai->ioctrl, (bits | SICF_FGC | SICF_CLOCK_EN));
aiutils.c:763:	dummy = R_REG(sii->osh, &ai->ioctrl);
aiutils.c:766:	W_REG(sii->osh, &ai->resetctrl, 0);
aiutils.c:767:	dummy = R_REG(sii->osh, &ai->resetctrl);
aiutils.c:771:	W_REG(sii->osh, &ai->ioctrl, (bits | SICF_CLOCK_EN));
aiutils.c:772:	dummy = R_REG(sii->osh, &ai->ioctrl);
aiutils.c:797:	ASSERT(GOODREGS(sii->curwrap));
aiutils.c:798:	ai = sii->curwrap;
aiutils.c:803:		w = ((R_REG(sii->osh, &ai->ioctrl) & ~mask) | val);
aiutils.c:804:		W_REG(sii->osh, &ai->ioctrl, w);
aiutils.c:827:	ASSERT(GOODREGS(sii->curwrap));
aiutils.c:828:	ai = sii->curwrap;
aiutils.c:833:		w = ((R_REG(sii->osh, &ai->ioctrl) & ~mask) | val);
aiutils.c:834:		W_REG(sii->osh, &ai->ioctrl, w);
aiutils.c:837:	return R_REG(sii->osh, &ai->ioctrl);
aiutils.c:859:	ASSERT(GOODREGS(sii->curwrap));
aiutils.c:860:	ai = sii->curwrap;
aiutils.c:866:		w = ((R_REG(sii->osh, &ai->iostatus) & ~mask) | val);
aiutils.c:867:		W_REG(sii->osh, &ai->iostatus, w);
aiutils.c:870:	return R_REG(sii->osh, &ai->iostatus);
bcmevent.c:2: * bcmevent read-only data shared by kernel or app layers
bcmevent.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
bcmevent.c:23: * $Id: bcmevent.c 370587 2012-11-22 09:32:38Z $
bcmsdh.c:5: * Copyright (C) 1999-2012, Broadcom Corporation
bcmsdh.c:25: * $Id: bcmsdh.c 373330 2012-12-07 04:46:17Z $
bcmsdh.c:73:	sdioh_enable_hw_oob_intr(sdh->sdioh, enable);
bcmsdh.c:100:	if (!(bcmsdh->sdioh = sdioh_attach(osh, cfghdl, irq))) {
bcmsdh.c:105:	bcmsdh->osh = osh;
bcmsdh.c:106:	bcmsdh->init_success = TRUE;
bcmsdh.c:111:	bcmsdh->sbwad = SI_ENUM_BASE;
bcmsdh.c:121:		if (bcmsdh->sdioh) {
bcmsdh.c:122:			sdioh_detach(osh, bcmsdh->sdioh);
bcmsdh.c:123:			bcmsdh->sdioh = NULL;
bcmsdh.c:137:	return sdioh_iovar_op(bcmsdh->sdioh, name, params, plen, arg, len, set);
bcmsdh.c:148:	status = sdioh_interrupt_query(bcmsdh->sdioh, &on);
bcmsdh.c:162:	status = sdioh_interrupt_set(bcmsdh->sdioh, TRUE);
bcmsdh.c:173:	status = sdioh_interrupt_set(bcmsdh->sdioh, FALSE);
bcmsdh.c:184:	status = sdioh_interrupt_register(bcmsdh->sdioh, fn, argh);
bcmsdh.c:195:	status = sdioh_interrupt_deregister(bcmsdh->sdioh);
bcmsdh.c:206:	return sdioh_interrupt_pending(bcmsdh->sdioh);
bcmsdh.c:241:	ASSERT(bcmsdh->init_success);
bcmsdh.c:248:	status = sdioh_cfg_read(bcmsdh->sdioh, fnc_num, addr, (uint8 *)&data);
bcmsdh.c:273:	ASSERT(bcmsdh->init_success);
bcmsdh.c:280:	status = sdioh_cfg_write(bcmsdh->sdioh, fnc_num, addr, (uint8 *)&data);
bcmsdh.c:301:	ASSERT(bcmsdh->init_success);
bcmsdh.c:303:	status = sdioh_request_word(bcmsdh->sdioh, SDIOH_CMD_TYPE_NORMAL, SDIOH_READ, fnc_num,
bcmsdh.c:324:	ASSERT(bcmsdh->init_success);
bcmsdh.c:326:	status = sdioh_request_word(bcmsdh->sdioh, SDIOH_CMD_TYPE_NORMAL, SDIOH_WRITE, fnc_num,
bcmsdh.c:351:	ASSERT(bcmsdh->init_success);
bcmsdh.c:355:	status = sdioh_cis_read(bcmsdh->sdioh, func, cis, length);
bcmsdh.c:359:		if ((tmp_buf = (uint8 *)MALLOC(bcmsdh->osh, length)) == NULL) {
bcmsdh.c:364:		for (tmp_ptr = tmp_buf, ptr = cis; ptr < (cis + length - 4); tmp_ptr++) {
bcmsdh.c:365:			ptr += snprintf((char*)ptr, (cis + length - ptr - 4),
bcmsdh.c:367:			if ((((tmp_ptr - tmp_buf) + 1) & 0xf) == 0)
bcmsdh.c:368:				ptr += snprintf((char *)ptr, (cis + length - ptr -4), "\n");
bcmsdh.c:370:		MFREE(bcmsdh->osh, tmp_buf, length);
bcmsdh.c:384:	if (bar0 != bcmsdh->sbwad || force_set) {
bcmsdh.c:395:			bcmsdh->sbwad = bar0;
bcmsdh.c:398:			bcmsdh->sbwad = 0;
bcmsdh.c:417:	ASSERT(bcmsdh->init_success);
bcmsdh.c:426:	status = sdioh_request_word(bcmsdh->sdioh, SDIOH_CMD_TYPE_NORMAL,
bcmsdh.c:429:	bcmsdh->regfail = !(SDIOH_API_SUCCESS(status));
bcmsdh.c:443:				bcmsdh->regfail = TRUE;
bcmsdh.c:466:	ASSERT(bcmsdh->init_success);
bcmsdh.c:474:	status = sdioh_request_word(bcmsdh->sdioh, SDIOH_CMD_TYPE_NORMAL, SDIOH_WRITE, SDIO_FUNC_1,
bcmsdh.c:476:	bcmsdh->regfail = !(SDIOH_API_SUCCESS(status));
bcmsdh.c:489:	return ((bcmsdh_info_t *)sdh)->regfail;
bcmsdh.c:504:	ASSERT(bcmsdh->init_success);
bcmsdh.c:524:	status = sdioh_request_buffer(bcmsdh->sdioh, SDIOH_DATA_PIO, incr_fix,
bcmsdh.c:542:	ASSERT(bcmsdh->init_success);
bcmsdh.c:562:	status = sdioh_request_buffer(bcmsdh->sdioh, SDIOH_DATA_PIO, incr_fix,
bcmsdh.c:575:	ASSERT(bcmsdh->init_success);
bcmsdh.c:581:	status = sdioh_request_buffer(bcmsdh->sdioh, SDIOH_DATA_PIO, SDIOH_DATA_INC,
bcmsdh.c:593:	return sdioh_abort(bcmsdh->sdioh, fn);
bcmsdh.c:601:	return sdioh_start(bcmsdh->sdioh, stage);
bcmsdh.c:609:	return sdioh_stop(bcmsdh->sdioh);
bcmsdh.c:619:	return sdioh_waitlockfree(bcmsdh->sdioh);
bcmsdh.c:627:	bcmsdh->vendevid = (VENDOR_BROADCOM << 16) | 0;
bcmsdh.c:628:	return (bcmsdh->vendevid);
bcmsdh.c:639:	return (sdioh_query_iofnum(bcmsdh->sdioh));
bcmsdh.c:647:	return sdioh_sdio_reset(bcmsdh->sdioh);
bcmsdh.c:653:	return sdh->sdioh;
bcmsdh.c:656:/* Function to pass device-status bits to DHD. */
bcmsdh.c:670:	return (bcmsdh->sbwad);
bcmsdh.c:685:	sdioh_info_t *sd = (sdioh_info_t *)(p->sdioh);
bcmsdh.c:697:	sdioh_info_t *sd = (sdioh_info_t *)(p->sdioh);
bcmsdh.c:706:	sdioh_info_t *sd = (sdioh_info_t *)(p->sdioh);
bcmsdh.c:715:	sdioh_info_t *sd = (sdioh_info_t *)(p->sdioh);
bcmsdh.c:724:	sdioh_info_t *sd = (sdioh_info_t *)(p->sdioh);
bcmsdh.c:734:	sdioh_glom_post(bcmsdh->sdioh, frame, len);
bcmsdh.c:741:	sdioh_glom_clear(bcmsdh->sdioh);
bcmsdh.c:748:	return (sdioh_set_mode(bcmsdh->sdioh, mode));
bcmsdh_linux.c:2: * SDIO access interface for drivers - linux specific (pci only)
bcmsdh_linux.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
bcmsdh_linux.c:24: * $Id: bcmsdh_linux.c 373359 2012-12-07 06:36:37Z $
bcmsdh_linux.c:174:		return -ENXIO;
bcmsdh_linux.c:208:	sdhc->osh = osh;
bcmsdh_linux.c:210:	sdhc->dev = (void *)dev;
bcmsdh_linux.c:219:	if (!(sdh = bcmsdh_attach(osh, (void *)r->start,
bcmsdh_linux.c:225:	sdhc->sdh = sdh;
bcmsdh_linux.c:226:	sdhc->oob_irq = irq;
bcmsdh_linux.c:227:	sdhc->oob_flags = irq_flags;
bcmsdh_linux.c:228:	sdhc->oob_irq_registered = FALSE;	/* to make sure.. */
bcmsdh_linux.c:229:	sdhc->oob_irq_enable_flag = FALSE;
bcmsdh_linux.c:231:	spin_lock_init(&sdhc->irq_lock);
bcmsdh_linux.c:235:	sdhc->next = sdhcinfo;
bcmsdh_linux.c:241:	if (!(sdhc->ch = drvinfo.attach((vendevid >> 16),
bcmsdh_linux.c:253:		if (sdhc->sdh)
bcmsdh_linux.c:254:			bcmsdh_detach(sdhc->osh, sdhc->sdh);
bcmsdh_linux.c:259:	return -ENODEV;
bcmsdh_linux.c:271:	drvinfo.detach(sdhc->ch);
bcmsdh_linux.c:272:	bcmsdh_detach(sdhc->osh, sdhc->sdh);
bcmsdh_linux.c:275:	for (sdhc = sdhcinfo, prev = NULL; sdhc; sdhc = sdhc->next) {
bcmsdh_linux.c:276:		if (sdhc->dev == (void *)dev) {
bcmsdh_linux.c:278:				prev->next = sdhc->next;
bcmsdh_linux.c:291:	osh = sdhc->osh;
bcmsdh_linux.c:370:		if (pdev->bus->number != (sd_pci_slot>>16) ||
bcmsdh_linux.c:371:			PCI_SLOT(pdev->devfn) != (sd_pci_slot&0xffff)) {
bcmsdh_linux.c:374:				bcmsdh_chipmatch(pdev->vendor, pdev->device)
bcmsdh_linux.c:377:				pdev->bus->number, PCI_SLOT(pdev->devfn), pdev->vendor,
bcmsdh_linux.c:378:				pdev->device));
bcmsdh_linux.c:379:			return -ENODEV;
bcmsdh_linux.c:383:			bcmsdh_chipmatch(pdev->vendor, pdev->device)
bcmsdh_linux.c:386:			pdev->bus->number, PCI_SLOT(pdev->devfn), pdev->vendor, pdev->device));
bcmsdh_linux.c:389:	if ((pdev->vendor == VENDOR_TI) && ((pdev->device == PCIXX21_FLASHMEDIA_ID) ||
bcmsdh_linux.c:390:	    (pdev->device == PCIXX21_FLASHMEDIA0_ID))) {
bcmsdh_linux.c:413:	if (!bcmsdh_chipmatch(pdev->vendor, pdev->device)) {
bcmsdh_linux.c:414:		return -ENODEV;
bcmsdh_linux.c:420:		pdev->bus->number, PCI_SLOT(pdev->devfn),
bcmsdh_linux.c:421:		PCI_FUNC(pdev->devfn), pdev->irq));
bcmsdh_linux.c:439:	sdhc->osh = osh;
bcmsdh_linux.c:441:	sdhc->dev = pdev;
bcmsdh_linux.c:451:	                          (void **)&regs, pdev->irq))) {
bcmsdh_linux.c:456:	sdhc->sdh = sdh;
bcmsdh_linux.c:459:	if (!(sdhc->ch = drvinfo.attach(VENDOR_BROADCOM, /* pdev->vendor, */
bcmsdh_linux.c:467:	sdhc->next = sdhcinfo;
bcmsdh_linux.c:475:		if (sdhc->sdh)
bcmsdh_linux.c:476:			bcmsdh_detach(sdhc->osh, sdhc->sdh);
bcmsdh_linux.c:481:	return -ENODEV;
bcmsdh_linux.c:495:	for (sdhc = sdhcinfo, prev = NULL; sdhc; sdhc = sdhc->next) {
bcmsdh_linux.c:496:		if (sdhc->dev == pdev) {
bcmsdh_linux.c:498:				prev->next = sdhc->next;
bcmsdh_linux.c:508:	drvinfo.detach(sdhc->ch);
bcmsdh_linux.c:510:	bcmsdh_detach(sdhc->osh, sdhc->sdh);
bcmsdh_linux.c:513:	osh = sdhc->osh;
bcmsdh_linux.c:587:	dev_set_drvdata(sdhcinfo->dev, dhdp);
bcmsdh_linux.c:603:	spin_lock_irqsave(&sdhcinfo->irq_lock, flags);
bcmsdh_linux.c:606:			enable_irq(sdhcinfo->oob_irq);
bcmsdh_linux.c:608:			disable_irq_nosync(sdhcinfo->oob_irq);
bcmsdh_linux.c:611:	spin_unlock_irqrestore(&sdhcinfo->irq_lock, flags);
bcmsdh_linux.c:618:	dhdp = (dhd_pub_t *)dev_get_drvdata(sdhcinfo->dev);
bcmsdh_linux.c:627:	dhdsdio_isr((void *)dhdp->bus);
bcmsdh_linux.c:651:	dev_set_drvdata(sdhcinfo->dev, dhdp);
bcmsdh_linux.c:653:	if (!sdhcinfo->oob_irq_registered) {
bcmsdh_linux.c:655:			(int)sdhcinfo->oob_irq, (int)sdhcinfo->oob_flags));
bcmsdh_linux.c:672:		error = request_irq(sdhcinfo->oob_irq, wlan_oob_irq, sdhcinfo->oob_flags,
bcmsdh_linux.c:675:			return -ENODEV;
bcmsdh_linux.c:686:		if (device_may_wakeup(sdhcinfo->dev)) {
bcmsdh_linux.c:689:			error = enable_irq_wake(sdhcinfo->oob_irq);
bcmsdh_linux.c:695:		sdhcinfo->oob_irq_registered = TRUE;
bcmsdh_linux.c:696:		sdhcinfo->oob_irq_enable_flag = TRUE;
bcmsdh_linux.c:704:	if (sdhcinfo->oob_irq_registered && sdhcinfo->oob_irq_enable_flag != flag) {
bcmsdh_linux.c:706:		sdhcinfo->oob_irq_enable_flag = flag;
bcmsdh_linux.c:709:			enable_irq(sdhcinfo->oob_irq);
bcmsdh_linux.c:715:			if (device_may_wakeup(sdhcinfo->dev))
bcmsdh_linux.c:717:				enable_irq_wake(sdhcinfo->oob_irq);
bcmsdh_linux.c:720:			if (device_may_wakeup(sdhcinfo->dev))
bcmsdh_linux.c:722:				disable_irq_wake(sdhcinfo->oob_irq);
bcmsdh_linux.c:725:			disable_irq(sdhcinfo->oob_irq);
bcmsdh_linux.c:738:	if (sdhcinfo->oob_irq_registered == TRUE) {
bcmsdh_linux.c:764:		free_irq(sdhcinfo->oob_irq, NULL);
bcmsdh_linux.c:772:		sdhcinfo->oob_irq_registered = FALSE;
bcmsdh_linux.c:786:	return dev_get_drvdata(sdhcinfo->dev);
bcmsdh_linux.c:790:/* Module parameters specific to each host-controller driver */
bcmsdh_linux.c:801:extern uint sd_divisor;	/* Divisor (-1 means external clock) */
bcmsdh_linux.c:807:extern uint sd_hiok;	/* Ok to use hi-speed mode */
bcmsdh_sdmmc.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
bcmsdh_sdmmc.c:24: * $Id: bcmsdh_sdmmc.c 362913 2012-10-15 11:26:11Z $
bcmsdh_sdmmc.c:76:uint sd_hiok = FALSE;	/* Don't use hi-speed mode by default */
bcmsdh_sdmmc.c:99:	sd->com_cis_ptr = sdioh_sdmmc_get_cisaddr(sd, SDIOD_CCCR_CISPTR_0);
bcmsdh_sdmmc.c:100:	sd->func_cis_ptr[0] = sd->com_cis_ptr;
bcmsdh_sdmmc.c:101:	sd_info(("%s: Card's Common CIS Ptr = 0x%x\n", __FUNCTION__, sd->com_cis_ptr));
bcmsdh_sdmmc.c:105:	     func <= sd->num_funcs; func++, fbraddr += SDIOD_FBR_SIZE) {
bcmsdh_sdmmc.c:106:		sd->func_cis_ptr[func] = sdioh_sdmmc_get_cisaddr(sd, SDIOD_FBR_CISPTR_0 + fbraddr);
bcmsdh_sdmmc.c:108:		         __FUNCTION__, func, sd->func_cis_ptr[func]));
bcmsdh_sdmmc.c:111:	sd->func_cis_ptr[0] = sd->com_cis_ptr;
bcmsdh_sdmmc.c:112:	sd_info(("%s: Card's Common CIS Ptr = 0x%x\n", __FUNCTION__, sd->com_cis_ptr));
bcmsdh_sdmmc.c:115:	sdio_claim_host(gInstance->func[1]);
bcmsdh_sdmmc.c:116:	err_ret = sdio_enable_func(gInstance->func[1]);
bcmsdh_sdmmc.c:117:	sdio_release_host(gInstance->func[1]);
bcmsdh_sdmmc.c:146:	sd->osh = osh;
bcmsdh_sdmmc.c:149:		MFREE(sd->osh, sd, sizeof(sdioh_info_t));
bcmsdh_sdmmc.c:153:	sd->num_funcs = 2;
bcmsdh_sdmmc.c:154:	sd->sd_blockmode = TRUE;
bcmsdh_sdmmc.c:155:	sd->use_client_ints = TRUE;
bcmsdh_sdmmc.c:156:	sd->client_block_size[0] = 64;
bcmsdh_sdmmc.c:157:	sd->use_rxchain = FALSE;
bcmsdh_sdmmc.c:159:	gInstance->sd = sd;
bcmsdh_sdmmc.c:162:	if (gInstance->func[1]) {
bcmsdh_sdmmc.c:163:		sdio_claim_host(gInstance->func[1]);
bcmsdh_sdmmc.c:165:		sd->client_block_size[1] = 64;
bcmsdh_sdmmc.c:166:		err_ret = sdio_set_block_size(gInstance->func[1], 64);
bcmsdh_sdmmc.c:172:		sdio_release_host(gInstance->func[1]);
bcmsdh_sdmmc.c:174:		sd_err(("%s:gInstance->func[1] is null\n", __FUNCTION__));
bcmsdh_sdmmc.c:175:		MFREE(sd->osh, sd, sizeof(sdioh_info_t));
bcmsdh_sdmmc.c:179:	if (gInstance->func[2]) {
bcmsdh_sdmmc.c:181:		sdio_claim_host(gInstance->func[2]);
bcmsdh_sdmmc.c:183:		sd->client_block_size[2] = sd_f2_blocksize;
bcmsdh_sdmmc.c:184:		err_ret = sdio_set_block_size(gInstance->func[2], sd_f2_blocksize);
bcmsdh_sdmmc.c:191:		sdio_release_host(gInstance->func[2]);
bcmsdh_sdmmc.c:193:		sd_err(("%s:gInstance->func[2] is null\n", __FUNCTION__));
bcmsdh_sdmmc.c:194:		MFREE(sd->osh, sd, sizeof(sdioh_info_t));
bcmsdh_sdmmc.c:213:		sdio_claim_host(gInstance->func[2]);
bcmsdh_sdmmc.c:214:		sdio_disable_func(gInstance->func[2]);
bcmsdh_sdmmc.c:215:		sdio_release_host(gInstance->func[2]);
bcmsdh_sdmmc.c:218:		if (gInstance->func[1]) {
bcmsdh_sdmmc.c:219:			sdio_claim_host(gInstance->func[1]);
bcmsdh_sdmmc.c:220:			sdio_disable_func(gInstance->func[1]);
bcmsdh_sdmmc.c:221:			sdio_release_host(gInstance->func[1]);
bcmsdh_sdmmc.c:224:		gInstance->func[1] = NULL;
bcmsdh_sdmmc.c:225:		gInstance->func[2] = NULL;
bcmsdh_sdmmc.c:230:		MFREE(sd->osh, sd, sizeof(sdioh_info_t));
bcmsdh_sdmmc.c:243:	if (gInstance->func[0]) {
bcmsdh_sdmmc.c:244:		sdio_claim_host(gInstance->func[0]);
bcmsdh_sdmmc.c:246:		reg = sdio_readb(gInstance->func[0], SDIOD_CCCR_INTEN, &err);
bcmsdh_sdmmc.c:249:			sdio_release_host(gInstance->func[0]);
bcmsdh_sdmmc.c:256:		sdio_writeb(gInstance->func[0], reg, SDIOD_CCCR_INTEN, &err);
bcmsdh_sdmmc.c:257:		sdio_release_host(gInstance->func[0]);
bcmsdh_sdmmc.c:274:	if (gInstance->func[0]) {
bcmsdh_sdmmc.c:275:		sdio_claim_host(gInstance->func[0]);
bcmsdh_sdmmc.c:276:		reg = sdio_readb(gInstance->func[0], SDIOD_CCCR_INTEN, &err);
bcmsdh_sdmmc.c:279:			sdio_release_host(gInstance->func[0]);
bcmsdh_sdmmc.c:287:		sdio_writeb(gInstance->func[0], reg, SDIOD_CCCR_INTEN, &err);
bcmsdh_sdmmc.c:289:		sdio_release_host(gInstance->func[0]);
bcmsdh_sdmmc.c:309:	sd->intr_handler = fn;
bcmsdh_sdmmc.c:310:	sd->intr_handler_arg = argh;
bcmsdh_sdmmc.c:311:	sd->intr_handler_valid = TRUE;
bcmsdh_sdmmc.c:314:	if (gInstance->func[2]) {
bcmsdh_sdmmc.c:315:		sdio_claim_host(gInstance->func[2]);
bcmsdh_sdmmc.c:316:		sdio_claim_irq(gInstance->func[2], IRQHandlerF2);
bcmsdh_sdmmc.c:317:		sdio_release_host(gInstance->func[2]);
bcmsdh_sdmmc.c:320:	if (gInstance->func[1]) {
bcmsdh_sdmmc.c:321:		sdio_claim_host(gInstance->func[1]);
bcmsdh_sdmmc.c:322:		sdio_claim_irq(gInstance->func[1], IRQHandler);
bcmsdh_sdmmc.c:323:		sdio_release_host(gInstance->func[1]);
bcmsdh_sdmmc.c:338:	if (gInstance->func[1]) {
bcmsdh_sdmmc.c:340:		sdio_claim_host(gInstance->func[1]);
bcmsdh_sdmmc.c:341:		sdio_release_irq(gInstance->func[1]);
bcmsdh_sdmmc.c:342:		sdio_release_host(gInstance->func[1]);
bcmsdh_sdmmc.c:345:	if (gInstance->func[2]) {
bcmsdh_sdmmc.c:347:		sdio_claim_host(gInstance->func[2]);
bcmsdh_sdmmc.c:348:		sdio_release_irq(gInstance->func[2]);
bcmsdh_sdmmc.c:350:		sdio_release_host(gInstance->func[2]);
bcmsdh_sdmmc.c:353:	sd->intr_handler_valid = FALSE;
bcmsdh_sdmmc.c:354:	sd->intr_handler = NULL;
bcmsdh_sdmmc.c:355:	sd->intr_handler_arg = NULL;
bcmsdh_sdmmc.c:366:	*onoff = sd->client_intr_enabled;
bcmsdh_sdmmc.c:381:	return sd->num_funcs;
bcmsdh_sdmmc.c:457:	if (vi->type == IOVT_VOID)
bcmsdh_sdmmc.c:459:	else if (vi->type == IOVT_BUFFER)
bcmsdh_sdmmc.c:470:	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
bcmsdh_sdmmc.c:482:		int_val = (int32)si->sd_blockmode;
bcmsdh_sdmmc.c:487:		si->sd_blockmode = (bool)int_val;
bcmsdh_sdmmc.c:488:		/* Haven't figured out how to make non-block mode with DMA */
bcmsdh_sdmmc.c:492:		if ((uint32)int_val > si->num_funcs) {
bcmsdh_sdmmc.c:496:		int_val = (int32)si->client_block_size[int_val];
bcmsdh_sdmmc.c:506:		if (func > si->num_funcs) {
bcmsdh_sdmmc.c:526:		si->client_block_size[func] = blksize;
bcmsdh_sdmmc.c:532:		int_val = (int32)si->use_rxchain;
bcmsdh_sdmmc.c:537:		int_val = (int32)si->sd_use_dma;
bcmsdh_sdmmc.c:542:		si->sd_use_dma = (bool)int_val;
bcmsdh_sdmmc.c:546:		int_val = (int32)si->use_client_ints;
bcmsdh_sdmmc.c:551:		si->use_client_ints = (bool)int_val;
bcmsdh_sdmmc.c:552:		if (si->use_client_ints)
bcmsdh_sdmmc.c:553:			si->intmask |= CLIENT_INTR;
bcmsdh_sdmmc.c:555:			si->intmask &= ~CLIENT_INTR;
bcmsdh_sdmmc.c:605:		int_val = (int32)si->intrcount;
bcmsdh_sdmmc.c:618:		if (sd_ptr->offset < SD_SysAddr || sd_ptr->offset > SD_MaxCurCap) {
bcmsdh_sdmmc.c:619:			sd_err(("%s: bad offset 0x%x\n", __FUNCTION__, sd_ptr->offset));
bcmsdh_sdmmc.c:625:		                  (sd_ptr->offset & 1) ? 8 : ((sd_ptr->offset & 2) ? 16 : 32),
bcmsdh_sdmmc.c:626:		                  sd_ptr->offset));
bcmsdh_sdmmc.c:627:		if (sd_ptr->offset & 1)
bcmsdh_sdmmc.c:628:			int_val = 8; /* sdioh_sdmmc_rreg8(si, sd_ptr->offset); */
bcmsdh_sdmmc.c:629:		else if (sd_ptr->offset & 2)
bcmsdh_sdmmc.c:630:			int_val = 16; /* sdioh_sdmmc_rreg16(si, sd_ptr->offset); */
bcmsdh_sdmmc.c:632:			int_val = 32; /* sdioh_sdmmc_rreg(si, sd_ptr->offset); */
bcmsdh_sdmmc.c:642:		if (sd_ptr->offset < SD_SysAddr || sd_ptr->offset > SD_MaxCurCap) {
bcmsdh_sdmmc.c:643:			sd_err(("%s: bad offset 0x%x\n", __FUNCTION__, sd_ptr->offset));
bcmsdh_sdmmc.c:648:		sd_trace(("%s: wreg%d value 0x%08x at offset %d\n", __FUNCTION__, sd_ptr->value,
bcmsdh_sdmmc.c:649:		                  (sd_ptr->offset & 1) ? 8 : ((sd_ptr->offset & 2) ? 16 : 32),
bcmsdh_sdmmc.c:650:		                  sd_ptr->offset));
bcmsdh_sdmmc.c:659:		if (sdioh_cfg_read(si, sd_ptr->func, sd_ptr->offset, &data)) {
bcmsdh_sdmmc.c:672:		uint8 data = (uint8)sd_ptr->value;
bcmsdh_sdmmc.c:674:		if (sdioh_cfg_write(si, sd_ptr->func, sd_ptr->offset, &data)) {
bcmsdh_sdmmc.c:741:	/* Only the lower 17-bits are valid */
bcmsdh_sdmmc.c:757:	if (!sd->func_cis_ptr[func]) {
bcmsdh_sdmmc.c:763:	sd_err(("%s: func_cis_ptr[%d]=0x%04x\n", __FUNCTION__, func, sd->func_cis_ptr[func]));
bcmsdh_sdmmc.c:766:		offset =  sd->func_cis_ptr[func] + count;
bcmsdh_sdmmc.c:796:				if (gInstance->func[2]) {
bcmsdh_sdmmc.c:797:					sdio_claim_host(gInstance->func[2]);
bcmsdh_sdmmc.c:800:						err_ret = sdio_enable_func(gInstance->func[2]);
bcmsdh_sdmmc.c:807:						err_ret = sdio_disable_func(gInstance->func[2]);
bcmsdh_sdmmc.c:813:					sdio_release_host(gInstance->func[2]);
bcmsdh_sdmmc.c:823:				while (sdio_abort_retry--) {
bcmsdh_sdmmc.c:824:					if (gInstance->func[func]) {
bcmsdh_sdmmc.c:825:						sdio_claim_host(gInstance->func[func]);
bcmsdh_sdmmc.c:831:						sdio_writeb(gInstance->func[func],
bcmsdh_sdmmc.c:833:						sdio_release_host(gInstance->func[func]);
bcmsdh_sdmmc.c:844:				if (gInstance->func[func]) {
bcmsdh_sdmmc.c:845:					sdio_claim_host(gInstance->func[func]);
bcmsdh_sdmmc.c:846:					sdio_f0_writeb(gInstance->func[func],
bcmsdh_sdmmc.c:848:					sdio_release_host(gInstance->func[func]);
bcmsdh_sdmmc.c:853:			if (gInstance->func[func]) {
bcmsdh_sdmmc.c:854:				sdio_claim_host(gInstance->func[func]);
bcmsdh_sdmmc.c:855:				sdio_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
bcmsdh_sdmmc.c:856:				sdio_release_host(gInstance->func[func]);
bcmsdh_sdmmc.c:861:		if (gInstance->func[func]) {
bcmsdh_sdmmc.c:862:			sdio_claim_host(gInstance->func[func]);
bcmsdh_sdmmc.c:864:				*byte = sdio_f0_readb(gInstance->func[func], regaddr, &err_ret);
bcmsdh_sdmmc.c:866:				*byte = sdio_readb(gInstance->func[func], regaddr, &err_ret);
bcmsdh_sdmmc.c:868:			sdio_release_host(gInstance->func[func]);
bcmsdh_sdmmc.c:900:	sdio_claim_host(gInstance->func[func]);
bcmsdh_sdmmc.c:904:			sdio_writel(gInstance->func[func], *word, addr, &err_ret);
bcmsdh_sdmmc.c:906:			sdio_writew(gInstance->func[func], (*word & 0xFFFF), addr, &err_ret);
bcmsdh_sdmmc.c:912:			*word = sdio_readl(gInstance->func[func], addr, &err_ret);
bcmsdh_sdmmc.c:914:			*word = sdio_readw(gInstance->func[func], addr, &err_ret) & 0xFFFF;
bcmsdh_sdmmc.c:921:	sdio_release_host(gInstance->func[func]);
bcmsdh_sdmmc.c:926:		while (sdio_abort_retry--) {
bcmsdh_sdmmc.c:927:			if (gInstance->func[0]) {
bcmsdh_sdmmc.c:928:				sdio_claim_host(gInstance->func[0]);
bcmsdh_sdmmc.c:934:				sdio_writeb(gInstance->func[0],
bcmsdh_sdmmc.c:936:				sdio_release_host(gInstance->func[0]);
bcmsdh_sdmmc.c:978:	for (pnext = pkt; pnext; pnext = PKTNEXT(sd->osh, pnext))
bcmsdh_sdmmc.c:979:		ttl_len += PKTLEN(sd->osh, pnext);
bcmsdh_sdmmc.c:981:	blk_size = sd->client_block_size[func];
bcmsdh_sdmmc.c:982:	if (!sd->use_rxchain || ttl_len <= blk_size) {
bcmsdh_sdmmc.c:989:	lft_len = ttl_len - dma_len;
bcmsdh_sdmmc.c:1004:		     pnext = PKTNEXT(sd->osh, pnext)) {
bcmsdh_sdmmc.c:1005:			pkt_len = PKTLEN(sd->osh, pnext);
bcmsdh_sdmmc.c:1008:				dma_len -= pkt_len;
bcmsdh_sdmmc.c:1015:			sg_set_buf(&sd->sg_list[SGCount++],
bcmsdh_sdmmc.c:1016:				(uint8*)PKTDATA(sd->osh, pnext),
bcmsdh_sdmmc.c:1026:		mmc_dat.sg = sd->sg_list;
bcmsdh_sdmmc.c:1044:		sdio_claim_host(gInstance->func[func]);
bcmsdh_sdmmc.c:1045:		mmc_set_data_timeout(&mmc_dat, gInstance->func[func]->card);
bcmsdh_sdmmc.c:1046:		mmc_wait_for_req(gInstance->func[func]->card->host, &mmc_req);
bcmsdh_sdmmc.c:1047:		sdio_release_host(gInstance->func[func]);
bcmsdh_sdmmc.c:1057:			sd->use_rxchain = FALSE;
bcmsdh_sdmmc.c:1061:			addr = addr + ttl_len - lft_len - dma_len;
bcmsdh_sdmmc.c:1068:		sdio_claim_host(gInstance->func[func]);
bcmsdh_sdmmc.c:1069:		for (pnext = pkt; pnext; pnext = PKTNEXT(sd->osh, pnext)) {
bcmsdh_sdmmc.c:1070:			uint8 *buf = (uint8*)PKTDATA(sd->osh, pnext) +
bcmsdh_sdmmc.c:1072:			pkt_len = PKTLEN(sd->osh, pnext);
bcmsdh_sdmmc.c:1074:				pkt_len -= xfred_len;
bcmsdh_sdmmc.c:1085:				pkt_len += blk_size - (pkt_len % blk_size);
bcmsdh_sdmmc.c:1096:						gInstance->func[func],
bcmsdh_sdmmc.c:1100:						gInstance->func[func],
bcmsdh_sdmmc.c:1104:						gInstance->func[func],
bcmsdh_sdmmc.c:1108:						gInstance->func[func],
bcmsdh_sdmmc.c:1112:			//	ret = sw_mci_check_r1_ready(gInstance->func[func]->card->host, 1000);
bcmsdh_sdmmc.c:1132:		sdio_release_host(gInstance->func[func]);
bcmsdh_sdmmc.c:1142: * end, a DMA-able packet is created.
bcmsdh_sdmmc.c:1167:		if (!(mypkt = PKTGET_STATIC(sd->osh, buflen_u, write ? TRUE : FALSE)))
bcmsdh_sdmmc.c:1169:		if (!(mypkt = PKTGET(sd->osh, buflen_u, write ? TRUE : FALSE)))
bcmsdh_sdmmc.c:1179:			bcopy(buffer, PKTDATA(sd->osh, mypkt), buflen_u);
bcmsdh_sdmmc.c:1186:			bcopy(PKTDATA(sd->osh, mypkt), buffer, buflen_u);
bcmsdh_sdmmc.c:1189:		PKTFREE_STATIC(sd->osh, mypkt, write ? TRUE : FALSE);
bcmsdh_sdmmc.c:1191:		PKTFREE(sd->osh, mypkt, write ? TRUE : FALSE);
bcmsdh_sdmmc.c:1193:	} else if (((uint32)(PKTDATA(sd->osh, pkt)) & DMA_ALIGN_MASK) != 0) {
bcmsdh_sdmmc.c:1197:		ASSERT(PKTNEXT(sd->osh, pkt) == NULL);
bcmsdh_sdmmc.c:1200:		         __FUNCTION__, write ? "TX" : "RX", PKTLEN(sd->osh, pkt)));
bcmsdh_sdmmc.c:1202:		if (!(mypkt = PKTGET_STATIC(sd->osh, PKTLEN(sd->osh, pkt), write ? TRUE : FALSE)))
bcmsdh_sdmmc.c:1204:		if (!(mypkt = PKTGET(sd->osh, PKTLEN(sd->osh, pkt), write ? TRUE : FALSE)))
bcmsdh_sdmmc.c:1208:			           __FUNCTION__, PKTLEN(sd->osh, pkt)));
bcmsdh_sdmmc.c:1214:			bcopy(PKTDATA(sd->osh, pkt),
bcmsdh_sdmmc.c:1215:			      PKTDATA(sd->osh, mypkt),
bcmsdh_sdmmc.c:1216:			      PKTLEN(sd->osh, pkt));
bcmsdh_sdmmc.c:1223:			bcopy(PKTDATA(sd->osh, mypkt),
bcmsdh_sdmmc.c:1224:			      PKTDATA(sd->osh, pkt),
bcmsdh_sdmmc.c:1225:			      PKTLEN(sd->osh, mypkt));
bcmsdh_sdmmc.c:1228:		PKTFREE_STATIC(sd->osh, mypkt, write ? TRUE : FALSE);
bcmsdh_sdmmc.c:1230:		PKTFREE(sd->osh, mypkt, write ? TRUE : FALSE);
bcmsdh_sdmmc.c:1259:/* Reset and re-initialize the device */
bcmsdh_sdmmc.c:1271:	sd_trace(("%s: %d\n", __FUNCTION__, sd->use_client_ints));
bcmsdh_sdmmc.c:1272:	sd->intmask &= ~CLIENT_INTR;
bcmsdh_sdmmc.c:1279:	sd_trace(("%s: %d\n", __FUNCTION__, sd->use_client_ints));
bcmsdh_sdmmc.c:1280:	sd->intmask |= CLIENT_INTR;
bcmsdh_sdmmc.c:1315:	sd = gInstance->sd;
bcmsdh_sdmmc.c:1318:	sdio_release_host(gInstance->func[0]);
bcmsdh_sdmmc.c:1320:	if (sd->use_client_ints) {
bcmsdh_sdmmc.c:1321:		sd->intrcount++;
bcmsdh_sdmmc.c:1322:		ASSERT(sd->intr_handler);
bcmsdh_sdmmc.c:1323:		ASSERT(sd->intr_handler_arg);
bcmsdh_sdmmc.c:1324:		(sd->intr_handler)(sd->intr_handler_arg);
bcmsdh_sdmmc.c:1329:		        __FUNCTION__, sd->client_intr_enabled, sd->intr_handler));
bcmsdh_sdmmc.c:1332:	sdio_claim_host(gInstance->func[0]);
bcmsdh_sdmmc.c:1342:	sd = gInstance->sd;
bcmsdh_sdmmc.c:1380:	sdioh_info_t *sd = gInstance->sd;
bcmsdh_sdmmc.c:1388:	if (gInstance->func[0]) {
bcmsdh_sdmmc.c:1395:		/* sdio_reset_comm() - has been fixed in latest kernel/msm.git for Linux
bcmsdh_sdmmc.c:1399:		if ((ret = sdio_reset_comm(gInstance->func[0]->card))) {
bcmsdh_sdmmc.c:1404:			sd->num_funcs = 2;
bcmsdh_sdmmc.c:1405:			sd->sd_blockmode = TRUE;
bcmsdh_sdmmc.c:1406:			sd->use_client_ints = TRUE;
bcmsdh_sdmmc.c:1407:			sd->client_block_size[0] = 64;
bcmsdh_sdmmc.c:1409:			if (gInstance->func[1]) {
bcmsdh_sdmmc.c:1411:				sdio_claim_host(gInstance->func[1]);
bcmsdh_sdmmc.c:1413:				sd->client_block_size[1] = 64;
bcmsdh_sdmmc.c:1414:				if (sdio_set_block_size(gInstance->func[1], 64)) {
bcmsdh_sdmmc.c:1419:				sdio_release_host(gInstance->func[1]);
bcmsdh_sdmmc.c:1422:			if (gInstance->func[2]) {
bcmsdh_sdmmc.c:1424:				sdio_claim_host(gInstance->func[2]);
bcmsdh_sdmmc.c:1426:				sd->client_block_size[2] = sd_f2_blocksize;
bcmsdh_sdmmc.c:1427:				if (sdio_set_block_size(gInstance->func[2],
bcmsdh_sdmmc.c:1434:				sdio_release_host(gInstance->func[2]);
bcmsdh_sdmmc.c:1441:			sdio_claim_host(gInstance->func[0]);
bcmsdh_sdmmc.c:1442:			if (gInstance->func[2])
bcmsdh_sdmmc.c:1443:				sdio_claim_irq(gInstance->func[2], IRQHandlerF2);
bcmsdh_sdmmc.c:1444:			if (gInstance->func[1])
bcmsdh_sdmmc.c:1445:				sdio_claim_irq(gInstance->func[1], IRQHandler);
bcmsdh_sdmmc.c:1446:			sdio_release_host(gInstance->func[0]);
bcmsdh_sdmmc.c:1470:	if (gInstance->func[0]) {
bcmsdh_sdmmc.c:1472:		sdio_claim_host(gInstance->func[0]);
bcmsdh_sdmmc.c:1473:		if (gInstance->func[1])
bcmsdh_sdmmc.c:1474:			sdio_release_irq(gInstance->func[1]);
bcmsdh_sdmmc.c:1475:		if (gInstance->func[2])
bcmsdh_sdmmc.c:1476:			sdio_release_irq(gInstance->func[2]);
bcmsdh_sdmmc.c:1477:		sdio_release_host(gInstance->func[0]);
bcmsdh_sdmmc_linux.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
bcmsdh_sdmmc_linux.c:24: * $Id: bcmsdh_sdmmc_linux.c 363783 2012-10-19 06:27:14Z $
bcmsdh_sdmmc_linux.c:115:		sd_trace(("sdio_bcmsdh: func->class=%x\n", func->class));
bcmsdh_sdmmc_linux.c:116:		sd_trace(("sdio_vendor: 0x%04x\n", func->vendor));
bcmsdh_sdmmc_linux.c:117:		sd_trace(("sdio_device: 0x%04x\n", func->device));
bcmsdh_sdmmc_linux.c:118:		sd_trace(("Function#: 0x%04x\n", func->num));
bcmsdh_sdmmc_linux.c:120:		if (func->num == 1) {
bcmsdh_sdmmc_linux.c:122:			sdio_func_0.card = func->card;
bcmsdh_sdmmc_linux.c:123:			gInstance->func[0] = &sdio_func_0;
bcmsdh_sdmmc_linux.c:124:			if(func->device == 0x4) { /* 4318 */
bcmsdh_sdmmc_linux.c:125:				gInstance->func[2] = NULL;
bcmsdh_sdmmc_linux.c:127:				ret = bcmsdh_probe(&func->dev);
bcmsdh_sdmmc_linux.c:131:		gInstance->func[func->num] = func;
bcmsdh_sdmmc_linux.c:133:		if (func->num == 2) {
bcmsdh_sdmmc_linux.c:135:			wl_cfg80211_set_parent_dev(&func->dev);
bcmsdh_sdmmc_linux.c:138:			ret = bcmsdh_probe(&func->dev);
bcmsdh_sdmmc_linux.c:141:		ret = -ENODEV;
bcmsdh_sdmmc_linux.c:151:		sd_info(("sdio_bcmsdh: func->class=%x\n", func->class));
bcmsdh_sdmmc_linux.c:152:		sd_info(("sdio_vendor: 0x%04x\n", func->vendor));
bcmsdh_sdmmc_linux.c:153:		sd_info(("sdio_device: 0x%04x\n", func->device));
bcmsdh_sdmmc_linux.c:154:		sd_info(("Function#: 0x%04x\n", func->num));
bcmsdh_sdmmc_linux.c:156:		if (gInstance->func[2]) {
bcmsdh_sdmmc_linux.c:158:			bcmsdh_remove(&func->dev);
bcmsdh_sdmmc_linux.c:159:			gInstance->func[2] = NULL;
bcmsdh_sdmmc_linux.c:161:		if (func->num == 1) {
bcmsdh_sdmmc_linux.c:165:			gInstance->func[1] = NULL;
bcmsdh_sdmmc_linux.c:194:	if (func->num != 2)
bcmsdh_sdmmc_linux.c:202:		return -EBUSY;
bcmsdh_sdmmc_linux.c:211:		return  -EINVAL;
bcmsdh_sdmmc_linux.c:245:	printk("[bcmdhd]: %s line %d. func-.num %d.\n", __FUNCTION__, __LINE__, func->num);
bcmsdh_sdmmc_linux.c:246:	if ((func->num == 2) && dhd_os_check_if_up(bcmsdh_get_drvdata())) {
bcmsdh_sdmmc_linux.c:326:	sdos = (struct sdos_info*)MALLOC(sd->osh, sizeof(struct sdos_info));
bcmsdh_sdmmc_linux.c:327:	sd->sdos_info = (void*)sdos;
bcmsdh_sdmmc_linux.c:331:	sdos->sd = sd;
bcmsdh_sdmmc_linux.c:332:	spin_lock_init(&sdos->lock);
bcmsdh_sdmmc_linux.c:340:	ASSERT(sd && sd->sdos_info);
bcmsdh_sdmmc_linux.c:342:	sdos = (struct sdos_info *)sd->sdos_info;
bcmsdh_sdmmc_linux.c:343:	MFREE(sd->osh, sdos, sizeof(struct sdos_info));
bcmsdh_sdmmc_linux.c:358:	sdos = (struct sdos_info *)sd->sdos_info;
bcmsdh_sdmmc_linux.c:362:	if (enable && !(sd->intr_handler && sd->intr_handler_arg)) {
bcmsdh_sdmmc_linux.c:369:	spin_lock_irqsave(&sdos->lock, flags);
bcmsdh_sdmmc_linux.c:371:	sd->client_intr_enabled = enable;
bcmsdh_sdmmc_linux.c:378:	spin_unlock_irqrestore(&sdos->lock, flags);
bcmsdh_sdmmc_linux.c:389:	printk("[bcmdhd]: %s enter.--------------- \n", __FUNCTION__);
bcmsdh_sdmmc_linux.c:418:		return -ENOMEM;
bcmutils.c:2: * Driver O/S-independent utility routines
bcmutils.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
bcmutils.c:23: * $Id: bcmutils.c 312855 2012-02-04 02:01:18Z $
bcmutils.c:75:		offset -= PKTLEN(osh, p);
bcmutils.c:83:		n = MIN((uint)PKTLEN(osh, p) - offset, (uint)len);
bcmutils.c:86:		len -= n;
bcmutils.c:104:		offset -= PKTLEN(osh, p);
bcmutils.c:112:		n = MIN((uint)PKTLEN(osh, p) - offset, (uint)len);
bcmutils.c:115:		len -= n;
bcmutils.c:182:			align64 = (64 - align64) & 0x3f;
bcmutils.c:183:			len -= align64;		/* bytes from aligned 64B to end */
bcmutils.c:206:		pkt_off = offset - len;
bcmutils.c:215: * osl multiple-precedence packet queue
bcmutils.c:216: * hi_prec is always >= the number of the highest non-empty precedence
bcmutils.c:223:	ASSERT(prec >= 0 && prec < pq->num_prec);
bcmutils.c:229:	q = &pq->q[prec];
bcmutils.c:231:	if (q->head)
bcmutils.c:232:		PKTSETLINK(q->tail, p);
bcmutils.c:234:		q->head = p;
bcmutils.c:236:	q->tail = p;
bcmutils.c:237:	q->len++;
bcmutils.c:239:	pq->len++;
bcmutils.c:241:	if (pq->hi_prec < prec)
bcmutils.c:242:		pq->hi_prec = (uint8)prec;
bcmutils.c:252:	ASSERT(prec >= 0 && prec < pq->num_prec);
bcmutils.c:258:	q = &pq->q[prec];
bcmutils.c:260:	if (q->head == NULL)
bcmutils.c:261:		q->tail = p;
bcmutils.c:263:	PKTSETLINK(p, q->head);
bcmutils.c:264:	q->head = p;
bcmutils.c:265:	q->len++;
bcmutils.c:267:	pq->len++;
bcmutils.c:269:	if (pq->hi_prec < prec)
bcmutils.c:270:		pq->hi_prec = (uint8)prec;
bcmutils.c:281:	ASSERT(prec >= 0 && prec < pq->num_prec);
bcmutils.c:283:	q = &pq->q[prec];
bcmutils.c:285:	if ((p = q->head) == NULL)
bcmutils.c:288:	if ((q->head = PKTLINK(p)) == NULL)
bcmutils.c:289:		q->tail = NULL;
bcmutils.c:291:	q->len--;
bcmutils.c:293:	pq->len--;
bcmutils.c:306:	ASSERT(prec >= 0 && prec < pq->num_prec);
bcmutils.c:308:	q = &pq->q[prec];
bcmutils.c:316:	q->len--;
bcmutils.c:318:	pq->len--;
bcmutils.c:332:	ASSERT(prec >= 0 && prec < pq->num_prec);
bcmutils.c:334:	q = &pq->q[prec];
bcmutils.c:336:	if ((p = q->head) == NULL)
bcmutils.c:339:	for (prev = NULL; p != q->tail; p = PKTLINK(p))
bcmutils.c:345:		q->head = NULL;
bcmutils.c:347:	q->tail = prev;
bcmutils.c:348:	q->len--;
bcmutils.c:350:	pq->len--;
bcmutils.c:361:	q = &pq->q[prec];
bcmutils.c:362:	p = q->head;
bcmutils.c:365:			bool head = (p == q->head);
bcmutils.c:367:				q->head = PKTLINK(p);
bcmutils.c:372:			q->len--;
bcmutils.c:373:			pq->len--;
bcmutils.c:374:			p = (head ? q->head : PKTLINK(prev));
bcmutils.c:381:	if (q->head == NULL) {
bcmutils.c:382:		ASSERT(q->len == 0);
bcmutils.c:383:		q->tail = NULL;
bcmutils.c:393:	ASSERT(prec >= 0 && prec < pq->num_prec);
bcmutils.c:398:	q = &pq->q[prec];
bcmutils.c:400:	if (q->head == pktbuf) {
bcmutils.c:401:		if ((q->head = PKTLINK(pktbuf)) == NULL)
bcmutils.c:402:			q->tail = NULL;
bcmutils.c:404:		for (p = q->head; p && PKTLINK(p) != pktbuf; p = PKTLINK(p))
bcmutils.c:410:		if (q->tail == pktbuf)
bcmutils.c:411:			q->tail = p;
bcmutils.c:414:	q->len--;
bcmutils.c:415:	pq->len--;
bcmutils.c:430:	pq->num_prec = (uint16)num_prec;
bcmutils.c:432:	pq->max = (uint16)max_len;
bcmutils.c:435:		pq->q[prec].max = pq->max;
bcmutils.c:441:	ASSERT(prec >= 0 && prec < pq->num_prec);
bcmutils.c:443:	if (prec < pq->num_prec)
bcmutils.c:444:		pq->q[prec].max = (uint16)max_len;
bcmutils.c:454:	if (pq->len == 0)
bcmutils.c:457:	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
bcmutils.c:458:		pq->hi_prec--;
bcmutils.c:460:	q = &pq->q[prec];
bcmutils.c:462:	if ((p = q->head) == NULL)
bcmutils.c:465:	if ((q->head = PKTLINK(p)) == NULL)
bcmutils.c:466:		q->tail = NULL;
bcmutils.c:468:	q->len--;
bcmutils.c:470:	pq->len--;
bcmutils.c:487:	if (pq->len == 0)
bcmutils.c:490:	for (prec = 0; prec < pq->hi_prec; prec++)
bcmutils.c:491:		if (pq->q[prec].head)
bcmutils.c:494:	q = &pq->q[prec];
bcmutils.c:496:	if ((p = q->head) == NULL)
bcmutils.c:499:	for (prev = NULL; p != q->tail; p = PKTLINK(p))
bcmutils.c:505:		q->head = NULL;
bcmutils.c:507:	q->tail = prev;
bcmutils.c:508:	q->len--;
bcmutils.c:510:	pq->len--;
bcmutils.c:525:	if (pq->len == 0)
bcmutils.c:528:	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
bcmutils.c:529:		pq->hi_prec--;
bcmutils.c:534:	return (pq->q[prec].head);
bcmutils.c:542:	if (pq->len == 0)
bcmutils.c:545:	for (prec = 0; prec < pq->hi_prec; prec++)
bcmutils.c:546:		if (pq->q[prec].head)
bcmutils.c:552:	return (pq->q[prec].tail);
bcmutils.c:563:	if (pq->len == 0) {
bcmutils.c:567:	for (prec = 0; prec < pq->num_prec; prec++)
bcmutils.c:570:		ASSERT(pq->len == 0);
bcmutils.c:581:	for (prec = 0; prec <= pq->hi_prec; prec++)
bcmutils.c:583:			len += pq->q[prec].len;
bcmutils.c:596:	if (pq->len == 0)
bcmutils.c:600:	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
bcmutils.c:601:		pq->hi_prec--;
bcmutils.c:603:	while ((prec_bmp & (1 << prec)) == 0 || pq->q[prec].head == NULL)
bcmutils.c:604:		if (prec-- == 0)
bcmutils.c:607:	q = &pq->q[prec];
bcmutils.c:609:	if ((p = q->head) == NULL)
bcmutils.c:625:	if (pq->len == 0)
bcmutils.c:628:	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
bcmutils.c:629:		pq->hi_prec--;
bcmutils.c:631:	while ((pq->q[prec].head == NULL) || ((prec_bmp & (1 << prec)) == 0))
bcmutils.c:632:		if (prec-- == 0)
bcmutils.c:635:	q = &pq->q[prec];
bcmutils.c:637:	if ((p = q->head) == NULL)
bcmutils.c:640:	if ((q->head = PKTLINK(p)) == NULL)
bcmutils.c:641:		q->tail = NULL;
bcmutils.c:643:	q->len--;
bcmutils.c:648:	pq->len--;
bcmutils.c:659:	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 0-7 */
bcmutils.c:661:	_BCM_C,	/* 8-15 */
bcmutils.c:662:	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 16-23 */
bcmutils.c:663:	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 24-31 */
bcmutils.c:664:	_BCM_S|_BCM_SP,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,		/* 32-39 */
bcmutils.c:665:	_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 40-47 */
bcmutils.c:666:	_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,			/* 48-55 */
bcmutils.c:667:	_BCM_D,_BCM_D,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 56-63 */
bcmutils.c:669:	_BCM_U|_BCM_X, _BCM_U, /* 64-71 */
bcmutils.c:670:	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,			/* 72-79 */
bcmutils.c:671:	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,			/* 80-87 */
bcmutils.c:672:	_BCM_U,_BCM_U,_BCM_U,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 88-95 */
bcmutils.c:674:	_BCM_L|_BCM_X, _BCM_L, /* 96-103 */
bcmutils.c:675:	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L, /* 104-111 */
bcmutils.c:676:	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L, /* 112-119 */
bcmutils.c:677:	_BCM_L,_BCM_L,_BCM_L,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_C, /* 120-127 */
bcmutils.c:678:	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/* 128-143 */
bcmutils.c:679:	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/* 144-159 */
bcmutils.c:681:	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 160-175 */
bcmutils.c:683:	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 176-191 */
bcmutils.c:685:	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,	/* 192-207 */
bcmutils.c:687:	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_L,	/* 208-223 */
bcmutils.c:689:	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,	/* 224-239 */
bcmutils.c:691:	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L /* 240-255 */
bcmutils.c:707:	else if (cp[0] == '-') {
bcmutils.c:730:	       (value = bcm_isdigit(*cp) ? *cp-'0' : bcm_toupper(*cp)-'A'+10) < base) {
bcmutils.c:734:			return (ulong)-1;
bcmutils.c:740:		result = (ulong)(-(long)result);
bcmutils.c:765:	len = strlen(haystack) - nlen + 1;
bcmutils.c:884:	((C >= 'A' && C <= 'Z') ? (char)((int)C - (int)'A' + (int)'a') : C)
bcmutils.c:895:* Returns:    Return 0 if the two strings are equal, -1 if t1 < t2 and 1 if
bcmutils.c:907:		if (dc < sc) return -1;
bcmutils.c:914:	if (!*s1 && *s2) return -1;
bcmutils.c:929:* Returns:    Return 0 if the two strings are equal, -1 if t1 < t2 and 1 if
bcmutils.c:941:		if (dc < sc) return -1;
bcmutils.c:945:		cnt--;
bcmutils.c:950:	if (!*s1 && *s2) return -1;
bcmutils.c:962:		ea->octet[i++] = (char) bcm_strtoul(p, &ep, 16);
bcmutils.c:990:		if (--abuflen == 0)
bcmutils.c:1009:	const uint8 *octet = ea->octet;
bcmutils.c:1019:	*(p-1) = '\0';
bcmutils.c:1028:	         ia->addr[0], ia->addr[1], ia->addr[2], ia->addr[3]);
bcmutils.c:1063:/* Takes an Ethernet frame and sets out-of-bound PKTPRIO.
bcmutils.c:1081:	if (ntoh16(eh->ether_type) == ETHER_TYPE_8021Q) {
bcmutils.c:1087:		vlan_tag = ntoh16(evh->vlan_tag);
bcmutils.c:1090:		if (ntoh16(evh->ether_type) == ETHER_TYPE_IP) {
bcmutils.c:1108:		 * the VLAN driver on Linux, overwrites the skb->priority field
bcmutils.c:1114:			evh->vlan_tag = hton16(vlan_tag);
bcmutils.c:1117:	} else if (ntoh16(eh->ether_type) == ETHER_TYPE_IP) {
bcmutils.c:1138:	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(bcmerrorstrtable) - 1));
bcmutils.c:1145:	ASSERT(strlen(bcmerrorstrtable[-bcmerror]) < BCME_STRLEN);
bcmutils.c:1147:	return bcmerrorstrtable[-bcmerror];
bcmutils.c:1168:	for (vi = table; vi->name; vi++) {
bcmutils.c:1169:		if (!strcmp(vi->name, lookup_name))
bcmutils.c:1183:	switch (vi->type) {
bcmutils.c:1199:		if (len < vi->minlen) {
bcmutils.c:1296:	while (nbytes-- > 0)
bcmutils.c:1366:	while (nbytes-- > 0)
bcmutils.c:1490: * Advance from the current 1-byte tag/1-byte length/variable-length value
bcmutils.c:1507:	len = elt->len;
bcmutils.c:1508:	elt = (bcm_tlv_t*)(elt->data + len);
bcmutils.c:1509:	*buflen -= (TLV_HDR_LEN + len);
bcmutils.c:1519: * Traverse a string of 1-byte tag/1-byte length/variable-length value
bcmutils.c:1534:		int len = elt->len;
bcmutils.c:1537:		if ((elt->id == key) &&
bcmutils.c:1542:		totlen -= (len + TLV_HDR_LEN);
bcmutils.c:1549: * Traverse a string of 1-byte tag/1-byte length/variable-length value
bcmutils.c:1565:		uint id = elt->id;
bcmutils.c:1566:		int len = elt->len;
bcmutils.c:1578:		totlen -= (len + TLV_HDR_LEN);
bcmutils.c:1630:			p -= 2 - len;	/* overwrite last char */
bcmutils.c:1634:	return (int)(p - buf);
bcmutils.c:1649:	return (int)(p - str);
bcmutils.c:1670:			len -= nchar;
bcmutils.c:1675:			len -= nchar;
bcmutils.c:1722:/* Produce a human-readable string for boardrev */
bcmutils.c:1754:		len -= max_len;
bcmutils.c:1774:		if (cur_ptr->nameandfmt == NULL)
bcmutils.c:1776:		len = snprintf(buf, bufsize, cur_ptr->nameandfmt,
bcmutils.c:1777:		               read_rtn(arg0, arg1, cur_ptr->offset));
bcmutils.c:1780:			len = bufsize - 1;
bcmutils.c:1782:		bufsize -= len;
bcmutils.c:1818: * Value is ( mW(QDBM_OFFSET - 1) + mW(QDBM_OFFSET) ) / 2
bcmutils.c:1823: * QDBM_OFFSET + QDBM_TABLE_LEN-1.
bcmutils.c:1824: * Value is ( mW(QDBM_OFFSET + QDBM_TABLE_LEN - 1) + mW(QDBM_OFFSET + QDBM_TABLE_LEN) ) / 2.
bcmutils.c:1841:	int idx = qdbm - QDBM_OFFSET;
bcmutils.c:1848:	/* scale the qdBm index up to the range of the table 0-40
bcmutils.c:1879:		offset -= 40;
bcmutils.c:1882:	for (qdbm = 0; qdbm < QDBM_TABLE_LEN-1; qdbm++) {
bcmutils.c:1883:		boundary = nqdBm_to_mW_map[qdbm] + (nqdBm_to_mW_map[qdbm+1] -
bcmutils.c:1903:			tmp &= (tmp - 1);
bcmutils.c:1915:	b->origsize = b->size = size;
bcmutils.c:1916:	b->origbuf = b->buf = buf;
bcmutils.c:1928:	r = vsnprintf(b->buf, b->size, fmt, ap);
bcmutils.c:1930:	/* Non Ansi C99 compliant returns -1,
bcmutils.c:1931:	 * Ansi compliant return r >= b->size,
bcmutils.c:1937:	if ((r == -1) || (r >= (int)b->size)) {
bcmutils.c:1938:		b->size = 0;
bcmutils.c:1940:		b->size -= r;
bcmutils.c:1941:		b->buf += r;
bcmutils.c:1980:	for (i = nbytes - 1; i >= 0; i--) {
bcmutils.c:1982:			return (arg1[i] - arg2[i]);
bcmutils.c:2025:			p += snprintf(p, (endp - p), "\\x%02X", c);
bcmutils.c:2031:	return (int)(p - buf);
bcmutils.c:2078:	buf_len = (unsigned int)(dp - varbuf);
bcmutils.c:2080:		pad = 4 - buf_len % 4;
bcmwifi_channels.c:2: * Misc utility routines used by kernel or app-level.
bcmwifi_channels.c:3: * Contents are wifi-specific, used by any kernel or app-level
bcmwifi_channels.c:6: * Copyright (C) 1999-2012, Broadcom Corporation
bcmwifi_channels.c:25: * $Id: bcmwifi_channels.c 309193 2012-01-19 00:03:57Z $
bcmwifi_channels.c:35:#define tolower(c) (bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
bcmwifi_channels.c:61: * <channel><band><bandwidth><ctl-sideband>
bcmwifi_channels.c:68: *	(ctl-sideband spec implies 40MHz)
bcmwifi_channels.c:69: * <ctl-sideband>: U for upper, L for lower
bcmwifi_channels.c:75: *	8  ->  2.4GHz channel 8, 20MHz
bcmwifi_channels.c:76: *	8b ->  2.4GHz channel 8, 20MHz
bcmwifi_channels.c:77: *	8l ->  2.4GHz channel 8, 40MHz, lower ctl sideband
bcmwifi_channels.c:78: *	8a ->  5GHz channel 8 (low 5 GHz band), 20MHz
bcmwifi_channels.c:79: *	36 ->  5GHz channel 36, 20MHz
bcmwifi_channels.c:80: *	36l -> 5GHz channel 36, 40MHz, lower ctl sideband
bcmwifi_channels.c:81: *	40u -> 5GHz channel 40, 40MHz, upper ctl sideband
bcmwifi_channels.c:82: *	180n -> channel 180, 10MHz
bcmwifi_channels.c:101:	/* check for non-default band spec */
bcmwifi_channels.c:111:			channel -= CH_10MHZ_APART;
bcmwifi_channels.c:167:		if (channel <= (MAXCHANNEL - CH_20MHZ_APART))
bcmwifi_channels.c:176:			channel -= CH_10MHZ_APART;
bcmwifi_channels.c:275: * [<band> 'g'] <channel> ['/'<bandwidth> [<ctl-sideband>]['/'<1st80channel>'-'<2nd80channel>]]
bcmwifi_channels.c:285: * <primary-sideband>:
bcmwifi_channels.c:295: *      non-overlapping and the primary sub-band is derived from its
bcmwifi_channels.c:307: * 40MHz channels is also allowed: <channel><ctl-sideband>
bcmwifi_channels.c:311: * <ctl-sideband>:
bcmwifi_channels.c:316: *      5g8             20MHz     8          -              -
bcmwifi_channels.c:317: *      52              20MHz     52         -              -
bcmwifi_channels.c:318: *      52/40           40MHz     54         52-56          52
bcmwifi_channels.c:319: *      56/40           40MHz     54         52-56          56
bcmwifi_channels.c:320: *      52/80           80MHz     58         52-64          52
bcmwifi_channels.c:321: *      56/80           80MHz     58         52-64          56
bcmwifi_channels.c:322: *      60/80           80MHz     58         52-64          60
bcmwifi_channels.c:323: *      64/80           80MHz     58         52-64          64
bcmwifi_channels.c:324: *      52/160          160MHz    50         36-64          52
bcmwifi_channels.c:325: *      36/160          160MGz    50         36-64          36
bcmwifi_channels.c:326: *      36/80+80/42-106 80+80MHz  42,106     36-48,100-112  36
bcmwifi_channels.c:330: *      2g8             20MHz     8          -              -
bcmwifi_channels.c:331: *      8               20MHz     8          -              -
bcmwifi_channels.c:332: *      6               20MHz     6          -              -
bcmwifi_channels.c:333: *      6/40l           40MHz     8          6-10           6
bcmwifi_channels.c:334: *      6l              40MHz     8          6-10           6
bcmwifi_channels.c:335: *      6/40u           40MHz     4          2-6            6
bcmwifi_channels.c:336: *      6u              40MHz     4          2-6            6
bcmwifi_channels.c:393:	/* edge channels separated by BW - 10MHz on each side
bcmwifi_channels.c:397:	return (uint8)(((bw - 20) / 2) / 5);
bcmwifi_channels.c:406:	return (uint8)(center_ch - center_chan_to_edge(bw));
bcmwifi_channels.c:410: * return -1 on error
bcmwifi_channels.c:418:	if ((ctl_ch - lowest) % 4) {
bcmwifi_channels.c:420:		return -1;
bcmwifi_channels.c:423:	sb = ((ctl_ch - lowest) / 4);
bcmwifi_channels.c:428:		return -1;
bcmwifi_channels.c:442: * return -1 on error
bcmwifi_channels.c:453:	return -1;
bcmwifi_channels.c:472:	/* check for non-default band spec */
bcmwifi_channels.c:516:		snprintf(buf, CHANSPEC_STR_LEN, "%d/80+80/%d-%d", ctl_chan, chan1, chan2);
bcmwifi_channels.c:663:		/* must followed by '-' */
bcmwifi_channels.c:664:		if (a[0] != '-')
bcmwifi_channels.c:714:		int sb = -1;
bcmwifi_channels.c:770:			/* sb index is 0-3 for the low 80MHz channel, and 4-7 for
bcmwifi_channels.c:965:				sb -= 4;
bcmwifi_channels.c:1009:	int sb = -1;
bcmwifi_channels.c:1081:			center_chan -= CH_20MHZ_APART;
bcmwifi_channels.c:1096: * frequencies from 5 - 6 GHz, and 2.407 GHz is assumed for 2.4 - 2.5 GHz.
bcmwifi_channels.c:1105: * -1 is returned if the start_factor is WF_CHAN_FACTOR_2_4_G and the
bcmwifi_channels.c:1114:	int ch = -1;
bcmwifi_channels.c:1133:		return -1;
bcmwifi_channels.c:1135:	offset = freq - base;
bcmwifi_channels.c:1140:		return -1;
bcmwifi_channels.c:1144:		return -1;
bcmwifi_channels.c:1161: * -1 is returned for an out of range channel.
bcmwifi_channels.c:1172:		freq = -1;
dhd_bta.c:2: * BT-AMP support routines
dhd_bta.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_bta.c:24: * $Id: dhd_bta.c 303834 2011-12-20 06:17:39Z $
dhd_bta.c:63:	if ((uint)cmd->plen + HCI_CMD_PREAMBLE_SIZE > cmd_len)
dhd_bta.c:67:		(char *)cmd, (uint)cmd->plen + HCI_CMD_PREAMBLE_SIZE, (char *)buf, len);
dhd_bta.c:88:	q = dhd_bus_txq(pub->bus);
dhd_bta.c:104:			PKTPULL(pub->osh, pkt, dhd_bus_hdrlen(pub->bus));
dhd_bta.c:107:			if (PKTLEN(pub->osh, pkt) >= RFC1042_HDR_LEN) {
dhd_bta.c:109:				        (struct ether_header *)PKTDATA(pub->osh, pkt);
dhd_bta.c:111:				if (ntoh16(eh->ether_type) < ETHER_TYPE_MIN) {
dhd_bta.c:116:					         DOT11_LLC_SNAP_HDR_LEN - 2) == 0 &&
dhd_bta.c:117:					    ntoh16(lsh->type) == BTA_PROT_L2CAP) {
dhd_bta.c:120:						uint16 handle = ltoh16(ACL_data->handle);
dhd_bta.c:123:							PKTFREE(pub->osh, pkt, TRUE);
dhd_bta.c:132:			PKTPUSH(pub->osh, pkt, dhd_bus_hdrlen(pub->bus));
dhd_bta.c:155:	switch (ltoh16_ua((uint8 *)&cmd->opcode)) {
dhd_bta.c:157:		eflush_cmd_parms_t *cmdparms = (eflush_cmd_parms_t *)cmd->parms;
dhd_bta.c:158:		dhd_bta_flush_hcidata(pub, ltoh16_ua(cmdparms->llh));
dhd_bta.c:168:/* Send HCI cmd encapsulated in BT-SIG frame via data channel to the dongle. */
dhd_bta.c:175:	osl_t *osh = pub->osh;
dhd_bta.c:185:	if ((len = (uint)cmd->plen + HCI_CMD_PREAMBLE_SIZE) > cmd_len) {
dhd_bta.c:191:	p = PKTGET(osh, pub->hdrlen + RFC1042_HDR_LEN + len, TRUE);
dhd_bta.c:205:	PKTPULL(osh, p, pub->hdrlen + RFC1042_HDR_LEN);
dhd_bta.c:208:	/* copy in partial Ethernet header with BT-SIG LLC/SNAP header */
dhd_bta.c:211:	bzero(eh->ether_dhost, ETHER_ADDR_LEN);
dhd_bta.c:212:	ETHER_SET_LOCALADDR(eh->ether_dhost);
dhd_bta.c:213:	bcopy(&pub->mac, eh->ether_shost, ETHER_ADDR_LEN);
dhd_bta.c:214:	eh->ether_type = hton16(len + DOT11_LLC_SNAP_HDR_LEN);
dhd_bta.c:216:	bcopy(BT_SIG_SNAP_MPROT, lsh, DOT11_LLC_SNAP_HDR_LEN - 2);
dhd_bta.c:217:	lsh->type = 0;
dhd_bta.c:230:	osl_t *osh = pub->osh;
dhd_bta.c:239:	if ((len = (uint)ltoh16(data->dlen) + HCI_ACL_DATA_PREAMBLE_SIZE) > data_len) {
dhd_bta.c:245:	p = PKTGET(osh, pub->hdrlen + RFC1042_HDR_LEN + len, TRUE);
dhd_bta.c:253:	PKTPULL(osh, p, pub->hdrlen + RFC1042_HDR_LEN);
dhd_bta.c:256:	/* copy in partial Ethernet header with BT-SIG LLC/SNAP header */
dhd_bta.c:259:	bzero(eh->ether_dhost, ETHER_ADDR_LEN);
dhd_bta.c:260:	bcopy(&pub->mac, eh->ether_shost, ETHER_ADDR_LEN);
dhd_bta.c:261:	eh->ether_type = hton16(len + DOT11_LLC_SNAP_HDR_LEN);
dhd_bta.c:263:	bcopy(BT_SIG_SNAP_MPROT, lsh, DOT11_LLC_SNAP_HDR_LEN - 2);
dhd_bta.c:264:	lsh->type = HTON16(BTA_PROT_L2CAP);
dhd_bta.c:273:	uint8 *pktdata = (uint8 *)PKTDATA(dhdp->osh, txp);
dhd_bta.c:275:	uint16 handle = ltoh16(ACL_data->handle);
dhd_bta.c:297:	evt->ecode = HCI_Number_of_Completed_Data_Blocks;
dhd_bta.c:298:	evt->plen = sizeof(num_completed_data_blocks_evt_parms_t);
dhd_bta.c:300:	parms = (num_completed_data_blocks_evt_parms_t *)evt->parms;
dhd_bta.c:301:	htol16_ua_store(dhdp->maxdatablks, (uint8 *)&parms->num_blocks);
dhd_bta.c:302:	parms->num_handles = 1;
dhd_bta.c:303:	htol16_ua_store(llh, (uint8 *)&parms->completed[0].handle);
dhd_bta.c:304:	parms->completed[0].pkts = 1;
dhd_bta.c:305:	parms->completed[0].blocks = 1;
dhd_bta.c:316:	switch (evt->ecode) {
dhd_bta.c:318:		cmd_complete_parms_t *parms = (cmd_complete_parms_t *)evt->parms;
dhd_bta.c:319:		switch (ltoh16_ua((uint8 *)&parms->opcode)) {
dhd_bta.c:322:			        (read_data_block_size_evt_parms_t *)parms->parms;
dhd_bta.c:323:			dhdp->maxdatablks = ltoh16_ua((uint8 *)&parms2->data_block_num);
dhd_bta.c:331:		flush_occurred_evt_parms_t *evt_parms = (flush_occurred_evt_parms_t *)evt->parms;
dhd_bta.c:332:		dhd_bta_flush_hcidata(dhdp, ltoh16_ua((uint8 *)&evt_parms->handle));
dhd_bta.h:2: * BT-AMP support routines
dhd_bta.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_bta.h:24: * $Id: dhd_bta.h 291086 2011-10-21 01:17:24Z $
dhd_bus.h:2: * Header file describing the internal (inter-module) DHD interfaces.
dhd_bus.h:7: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_bus.h:27: * $Id: dhd_bus.h 347614 2012-07-27 10:24:51Z $
dhd_bus.h:80:/* Check for and handle local prot-specific iovar commands */
dhd_bus.h:93:/* Set user-specified nvram parameters. */
dhd_bus.h:102:	(_bus)->dhd->busstate = DHD_BUS_DOWN; \
dhd_cdc.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_cdc.c:24: * $Id: dhd_cdc.c 368762 2012-11-14 21:59:17Z $
dhd_cdc.c:87:	dhd_prot_t *prot = dhd->prot;
dhd_cdc.c:88:	int len = ltoh32(prot->msg.len) + sizeof(cdc_ioctl_t);
dhd_cdc.c:94:	/* NOTE : cdc->msg.len holds the desired length of the buffer to be
dhd_cdc.c:102:	err = dhd_bus_txctl(dhd->bus, (uchar*)&prot->msg, len);
dhd_cdc.c:113:	dhd_prot_t *prot = dhd->prot;
dhd_cdc.c:118:		ret = dhd_bus_rxctl(dhd->bus, (uchar*)&prot->msg, cdc_len);
dhd_cdc.c:121:	} while (CDC_IOC_ID(ltoh32(prot->msg.flags)) != id);
dhd_cdc.c:129:	dhd_prot_t *prot = dhd->prot;
dhd_cdc.c:130:	cdc_ioctl_t *msg = &prot->msg;
dhd_cdc.c:144:			strncpy((char *)buf, bcmerrorstr(dhd->dongle_error), BCME_STRLEN);
dhd_cdc.c:149:			*(int *)buf = dhd->dongle_error;
dhd_cdc.c:156:	msg->cmd = htol32(cmd);
dhd_cdc.c:157:	msg->len = htol32(len);
dhd_cdc.c:158:	msg->flags = (++prot->reqid << CDCF_IOC_ID_SHIFT);
dhd_cdc.c:162:	msg->flags |= (action << CDCF_IOC_ACTION_SHIFT);
dhd_cdc.c:163:	msg->flags = htol32(msg->flags);
dhd_cdc.c:166:		memcpy(prot->buf, buf, len);
dhd_cdc.c:169:		if (!dhd->hang_was_sent)
dhd_cdc.c:176:	if ((ret = dhdcdc_cmplt(dhd, prot->reqid, len)) < 0)
dhd_cdc.c:179:	flags = ltoh32(msg->flags);
dhd_cdc.c:182:	if ((id < prot->reqid) && (++retries < RETRIES))
dhd_cdc.c:184:	if (id != prot->reqid) {
dhd_cdc.c:186:		           dhd_ifname(dhd, ifidx), __FUNCTION__, id, prot->reqid));
dhd_cdc.c:187:		ret = -EINVAL;
dhd_cdc.c:205:		ret = ltoh32(msg->status);
dhd_cdc.c:207:		dhd->dongle_error = ret;
dhd_cdc.c:217:	dhd_prot_t *prot = dhd->prot;
dhd_cdc.c:218:	cdc_ioctl_t *msg = &prot->msg;
dhd_cdc.c:225:	if (dhd->busstate == DHD_BUS_DOWN) {
dhd_cdc.c:227:		return -EIO;
dhd_cdc.c:231:	if (dhd->hang_was_sent) {
dhd_cdc.c:234:		return -EIO;
dhd_cdc.c:239:	msg->cmd = htol32(cmd);
dhd_cdc.c:240:	msg->len = htol32(len);
dhd_cdc.c:241:	msg->flags = (++prot->reqid << CDCF_IOC_ID_SHIFT);
dhd_cdc.c:245:	msg->flags |= (action << CDCF_IOC_ACTION_SHIFT) | CDCF_IOC_SET;
dhd_cdc.c:246:	msg->flags = htol32(msg->flags);
dhd_cdc.c:249:		memcpy(prot->buf, buf, len);
dhd_cdc.c:256:	if ((ret = dhdcdc_cmplt(dhd, prot->reqid, len)) < 0)
dhd_cdc.c:259:	flags = ltoh32(msg->flags);
dhd_cdc.c:262:	if (id != prot->reqid) {
dhd_cdc.c:264:		           dhd_ifname(dhd, ifidx), __FUNCTION__, id, prot->reqid));
dhd_cdc.c:265:		ret = -EINVAL;
dhd_cdc.c:272:		ret = ltoh32(msg->status);
dhd_cdc.c:274:		dhd->dongle_error = ret;
dhd_cdc.c:285:	dhd_prot_t *prot = dhd->prot;
dhd_cdc.c:286:	int ret = -1;
dhd_cdc.c:292:	if ((dhd->busstate == DHD_BUS_DOWN) || dhd->hang_was_sent) {
dhd_cdc.c:304:		ret = -1;
dhd_cdc.c:316:	if (prot->pending == TRUE) {
dhd_cdc.c:318:			ioc->cmd, (unsigned long)ioc->cmd, prot->lastcmd,
dhd_cdc.c:319:			(unsigned long)prot->lastcmd));
dhd_cdc.c:320:		if ((ioc->cmd == WLC_SET_VAR) || (ioc->cmd == WLC_GET_VAR)) {
dhd_cdc.c:326:	prot->pending = TRUE;
dhd_cdc.c:327:	prot->lastcmd = ioc->cmd;
dhd_cdc.c:328:	action = ioc->set;
dhd_cdc.c:330:		ret = dhdcdc_set_ioctl(dhd, ifidx, ioc->cmd, buf, len, action);
dhd_cdc.c:332:		ret = dhdcdc_query_ioctl(dhd, ifidx, ioc->cmd, buf, len, action);
dhd_cdc.c:334:			ioc->used = ret - sizeof(cdc_ioctl_t);
dhd_cdc.c:341:		cdc_ioctl_t *msg = &prot->msg;
dhd_cdc.c:342:		ioc->needed = ltoh32(msg->len); /* len == needed when set/query fails from dongle */
dhd_cdc.c:346:	if ((!ret) && (ioc->cmd == WLC_SET_VAR) && (!strcmp(buf, "wme_dp"))) {
dhd_cdc.c:352:		dhd->wme_dp = (uint8) ltoh32(val);
dhd_cdc.c:355:	prot->pending = FALSE;
dhd_cdc.c:379:		dhdp->wlfc_state;
dhd_cdc.c:389:	h = (wlfc_hanger_t*)wlfc->hanger;
dhd_cdc.c:391:		bcm_bprintf(strbuf, "wlfc-hanger not initialized yet\n");
dhd_cdc.c:394:	mac_table = wlfc->destination_entries.nodes;
dhd_cdc.c:395:	interfaces = wlfc->destination_entries.interfaces;
dhd_cdc.c:396:	bcm_bprintf(strbuf, "---- wlfc stats ----\n");
dhd_cdc.c:400:			h->pushed,
dhd_cdc.c:401:			h->popped,
dhd_cdc.c:402:			h->failed_to_push,
dhd_cdc.c:403:			h->failed_to_pop,
dhd_cdc.c:404:			h->failed_slotfind,
dhd_cdc.c:405:			(h->pushed - h->popped));
dhd_cdc.c:410:		wlfc->stats.tlv_parse_failed,
dhd_cdc.c:411:		wlfc->stats.credit_request_failed,
dhd_cdc.c:412:		wlfc->stats.mac_update_failed,
dhd_cdc.c:413:		wlfc->stats.psmode_update_failed,
dhd_cdc.c:414:		wlfc->stats.delayq_full_error,
dhd_cdc.c:415:		wlfc->stats.sendq_full_error,
dhd_cdc.c:416:		wlfc->stats.rollback_failed);
dhd_cdc.c:420:		wlfc->SENDQ.q[0].len, wlfc->FIFO_credit[0], wlfc->stats.sendq_pkts[0],
dhd_cdc.c:421:		wlfc->SENDQ.q[1].len, wlfc->FIFO_credit[1], wlfc->stats.sendq_pkts[1],
dhd_cdc.c:422:		wlfc->SENDQ.q[2].len, wlfc->FIFO_credit[2], wlfc->stats.sendq_pkts[2],
dhd_cdc.c:423:		wlfc->SENDQ.q[3].len, wlfc->FIFO_credit[3], wlfc->stats.sendq_pkts[3],
dhd_cdc.c:424:		wlfc->SENDQ.q[4].len, wlfc->FIFO_credit[4], wlfc->stats.sendq_pkts[4]);
dhd_cdc.c:427:	bcm_bprintf(strbuf, "SENDQ dropped: AC[0-3]:(%d,%d,%d,%d), (bcmc,atim):(%d,%d)\n",
dhd_cdc.c:428:		wlfc->stats.dropped_qfull[0], wlfc->stats.dropped_qfull[1],
dhd_cdc.c:429:		wlfc->stats.dropped_qfull[2], wlfc->stats.dropped_qfull[3],
dhd_cdc.c:430:		wlfc->stats.dropped_qfull[4], wlfc->stats.dropped_qfull[5]);
dhd_cdc.c:449:				iftype_desc, ((wlfc->hostif_flow_state[i] == OFF)
dhd_cdc.c:516:		if (wlfc->stats.latency_sample_count) {
dhd_cdc.c:517:			moving_samples = sizeof(wlfc->stats.deltas)/sizeof(uint32);
dhd_cdc.c:520:				moving_avg += wlfc->stats.deltas[i];
dhd_cdc.c:523:			avg = (100 * wlfc->stats.total_status_latency) /
dhd_cdc.c:524:				wlfc->stats.latency_sample_count;
dhd_cdc.c:527:				moving_samples, avg/100, (avg - (avg/100)*100),
dhd_cdc.c:528:				wlfc->stats.latency_most_recent,
dhd_cdc.c:533:	bcm_bprintf(strbuf, "wlfc- fifo[0-5] credit stats: sent = (%d,%d,%d,%d,%d,%d), "
dhd_cdc.c:535:		wlfc->stats.fifo_credits_sent[0],
dhd_cdc.c:536:		wlfc->stats.fifo_credits_sent[1],
dhd_cdc.c:537:		wlfc->stats.fifo_credits_sent[2],
dhd_cdc.c:538:		wlfc->stats.fifo_credits_sent[3],
dhd_cdc.c:539:		wlfc->stats.fifo_credits_sent[4],
dhd_cdc.c:540:		wlfc->stats.fifo_credits_sent[5],
dhd_cdc.c:542:		wlfc->stats.fifo_credits_back[0],
dhd_cdc.c:543:		wlfc->stats.fifo_credits_back[1],
dhd_cdc.c:544:		wlfc->stats.fifo_credits_back[2],
dhd_cdc.c:545:		wlfc->stats.fifo_credits_back[3],
dhd_cdc.c:546:		wlfc->stats.fifo_credits_back[4],
dhd_cdc.c:547:		wlfc->stats.fifo_credits_back[5]);
dhd_cdc.c:555:		for (i = 0; i < sizeof(wlfc->stats.fifo_credits_sent)/sizeof(uint32); i++) {
dhd_cdc.c:556:			fifo_cr_sent += wlfc->stats.fifo_credits_sent[i];
dhd_cdc.c:559:		for (i = 0; i < sizeof(wlfc->stats.fifo_credits_back)/sizeof(uint32); i++) {
dhd_cdc.c:560:			fifo_cr_acked += wlfc->stats.fifo_credits_back[i];
dhd_cdc.c:564:			if (wlfc->destination_entries.nodes[i].occupied) {
dhd_cdc.c:566:					wlfc->destination_entries.nodes[i].dstncredit_sent_packets;
dhd_cdc.c:570:			if (wlfc->destination_entries.interfaces[i].occupied) {
dhd_cdc.c:572:				wlfc->destination_entries.interfaces[i].dstncredit_sent_packets;
dhd_cdc.c:576:			if (wlfc->destination_entries.nodes[i].occupied) {
dhd_cdc.c:578:					wlfc->destination_entries.nodes[i].dstncredit_acks;
dhd_cdc.c:582:			if (wlfc->destination_entries.interfaces[i].occupied) {
dhd_cdc.c:584:					wlfc->destination_entries.interfaces[i].dstncredit_acks;
dhd_cdc.c:587:		bcm_bprintf(strbuf, "wlfc- (sent, status) => pq(%d,%d), vq(%d,%d),"
dhd_cdc.c:588:			"other:%d, bc_mc:%d, signal-only, (sent,freed): (%d,%d)",
dhd_cdc.c:591:			wlfc->destination_entries.other.dstncredit_acks,
dhd_cdc.c:593:			wlfc->stats.signal_only_pkts_sent, wlfc->stats.signal_only_pkts_freed);
dhd_cdc.c:597:	bcm_bprintf(strbuf, "wlfc- pkt((in,2bus,txstats,hdrpull),(dropped,hdr_only,wlc_tossed)"
dhd_cdc.c:600:		wlfc->stats.pktin,
dhd_cdc.c:601:		wlfc->stats.pkt2bus,
dhd_cdc.c:602:		wlfc->stats.txstatus_in,
dhd_cdc.c:603:		wlfc->stats.dhd_hdrpulls,
dhd_cdc.c:605:		wlfc->stats.pktdropped,
dhd_cdc.c:606:		wlfc->stats.wlfc_header_only_pkt,
dhd_cdc.c:607:		wlfc->stats.wlc_tossed_pkts,
dhd_cdc.c:609:		wlfc->stats.pkt_freed,
dhd_cdc.c:610:		wlfc->stats.pkt_free_err, wlfc->stats.rollback);
dhd_cdc.c:612:	bcm_bprintf(strbuf, "wlfc- suppress((d11,wlc,err),enq(d11,wl,hq,mac?),retx(d11,wlc,hq)) = "
dhd_cdc.c:615:		wlfc->stats.d11_suppress,
dhd_cdc.c:616:		wlfc->stats.wl_suppress,
dhd_cdc.c:617:		wlfc->stats.bad_suppress,
dhd_cdc.c:619:		wlfc->stats.psq_d11sup_enq,
dhd_cdc.c:620:		wlfc->stats.psq_wlsup_enq,
dhd_cdc.c:621:		wlfc->stats.psq_hostq_enq,
dhd_cdc.c:622:		wlfc->stats.mac_handle_notfound,
dhd_cdc.c:624:		wlfc->stats.psq_d11sup_retx,
dhd_cdc.c:625:		wlfc->stats.psq_wlsup_retx,
dhd_cdc.c:626:		wlfc->stats.psq_hostq_retx);
dhd_cdc.c:633:	hang-er: noun, a contrivance on which things are hung, as a hook.
dhd_cdc.c:648:	hanger->max_items = max_items;
dhd_cdc.c:650:	for (i = 0; i < hanger->max_items; i++) {
dhd_cdc.c:651:		hanger->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
dhd_cdc.c:662:		MFREE(osh, h, WLFC_HANGER_SIZE(h->max_items));
dhd_cdc.c:675:		for (i = (h->slot_pos + 1); i != h->slot_pos;) {
dhd_cdc.c:676:			if (h->items[i].state == WLFC_HANGER_ITEM_STATE_FREE) {
dhd_cdc.c:677:				h->slot_pos = i;
dhd_cdc.c:680:			(i == h->max_items)? i = 0 : i++;
dhd_cdc.c:682:		h->failed_slotfind++;
dhd_cdc.c:700:		if ((h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_INUSE) ||
dhd_cdc.c:701:			(h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_INUSE_SUPPRESSED)) {
dhd_cdc.c:702:			*gen = h->items[slot_id].gen;
dhd_cdc.c:720:		if (h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_FREE) {
dhd_cdc.c:721:			h->items[slot_id].state = WLFC_HANGER_ITEM_STATE_INUSE;
dhd_cdc.c:722:			h->items[slot_id].pkt = pkt;
dhd_cdc.c:723:			h->items[slot_id].identifier = slot_id;
dhd_cdc.c:724:			h->pushed++;
dhd_cdc.c:727:			h->failed_to_push++;
dhd_cdc.c:747:		if (h->items[slot_id].state != WLFC_HANGER_ITEM_STATE_FREE) {
dhd_cdc.c:748:			*pktout = h->items[slot_id].pkt;
dhd_cdc.c:750:				h->items[slot_id].state =
dhd_cdc.c:752:				h->items[slot_id].pkt = NULL;
dhd_cdc.c:753:				h->items[slot_id].identifier = 0;
dhd_cdc.c:754:				h->items[slot_id].gen = 0xff;
dhd_cdc.c:755:				h->popped++;
dhd_cdc.c:759:			h->failed_to_pop++;
dhd_cdc.c:778:		h->items[slot_id].gen = gen;
dhd_cdc.c:779:		if (h->items[slot_id].state == WLFC_HANGER_ITEM_STATE_INUSE) {
dhd_cdc.c:780:			h->items[slot_id].state = WLFC_HANGER_ITEM_STATE_INUSE_SUPPRESSED;
dhd_cdc.c:809:	fillers = ROUNDUP(dataOffset, 4) - dataOffset;
dhd_cdc.c:812:	PKTPUSH(ctx->osh, p, dataOffset);
dhd_cdc.c:813:	wlh = (uint8*) PKTDATA(ctx->osh, p);
dhd_cdc.c:822:		wlh[dataOffset - fillers - tim_signal_len ] =
dhd_cdc.c:824:		wlh[dataOffset - fillers - tim_signal_len + 1] =
dhd_cdc.c:826:		wlh[dataOffset - fillers - tim_signal_len + 2] = mac_handle;
dhd_cdc.c:827:		wlh[dataOffset - fillers - tim_signal_len + 3] = tim_bmp;
dhd_cdc.c:830:		memset(&wlh[dataOffset - fillers], WLFC_CTL_TYPE_FILLER, fillers);
dhd_cdc.c:832:	PKTPUSH(ctx->osh, p, BDC_HEADER_LEN);
dhd_cdc.c:833:	h = (struct bdc_header *)PKTDATA(ctx->osh, p);
dhd_cdc.c:834:	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
dhd_cdc.c:836:		h->flags |= BDC_FLAG_SUM_NEEDED;
dhd_cdc.c:839:	h->priority = (PKTPRIO(p) & BDC_PRIORITY_MASK);
dhd_cdc.c:840:	h->flags2 = 0;
dhd_cdc.c:841:	h->dataOffset = dataOffset >> 2;
dhd_cdc.c:851:	if (PKTLEN(ctx->osh, pktbuf) < BDC_HEADER_LEN) {
dhd_cdc.c:853:		           PKTLEN(ctx->osh, pktbuf), BDC_HEADER_LEN));
dhd_cdc.c:856:	h = (struct bdc_header *)PKTDATA(ctx->osh, pktbuf);
dhd_cdc.c:859:	PKTPULL(ctx->osh, pktbuf, BDC_HEADER_LEN);
dhd_cdc.c:861:	if (PKTLEN(ctx->osh, pktbuf) < (h->dataOffset << 2)) {
dhd_cdc.c:863:		           PKTLEN(ctx->osh, pktbuf), (h->dataOffset << 2)));
dhd_cdc.c:866:	/* pull wl-header */
dhd_cdc.c:867:	PKTPULL(ctx->osh, pktbuf, (h->dataOffset << 2));
dhd_cdc.c:875:	wlfc_mac_descriptor_t* table = ctx->destination_entries.nodes;
dhd_cdc.c:879:	if (((ctx->destination_entries.interfaces[ifid].iftype == WLC_E_IF_ROLE_STA) ||
dhd_cdc.c:881:		(ctx->destination_entries.interfaces[ifid].iftype == WLC_E_IF_ROLE_P2P_CLIENT)) &&
dhd_cdc.c:882:		(ctx->destination_entries.interfaces[ifid].occupied)) {
dhd_cdc.c:883:			return &ctx->destination_entries.interfaces[ifid];
dhd_cdc.c:894:	return &ctx->destination_entries.other;
dhd_cdc.c:904:	- a packet from send-q will need to go back to send-q and not delay-q
dhd_cdc.c:906:	- suppressed packet goes back to suppress sub-queue
dhd_cdc.c:907:	- pull out the header, if new or delayed packet
dhd_cdc.c:920:			/* wl-header is saved for suppressed packets */
dhd_cdc.c:921:			if (WLFC_PKTQ_PENQ_HEAD(&entry->psq, ((prec << 1) + 1), p) == NULL) {
dhd_cdc.c:932:				dhd_wlfc_hanger_poppkt(ctx->hanger, hslot, &pktout, 1);
dhd_cdc.c:933:				PKTFREE(ctx->osh, p, TRUE);
dhd_cdc.c:939:				/* delay-q packets are going to delay-q */
dhd_cdc.c:940:				if (WLFC_PKTQ_PENQ_HEAD(&entry->psq, (prec << 1), p) == NULL) {
dhd_cdc.c:947:				if (WLFC_PKTQ_PENQ_HEAD(&ctx->SENDQ, prec, p) == NULL) {
dhd_cdc.c:953:			dhd_wlfc_hanger_poppkt(ctx->hanger, hslot, &pktout, 1);
dhd_cdc.c:963:			entry->requested_credit++;
dhd_cdc.c:971:		ctx->stats.rollback_failed++;
dhd_cdc.c:973:		ctx->stats.rollback++;
dhd_cdc.c:981:	if ((pq->len <= WLFC_FLOWCONTROL_LOWATER) && (ctx->hostif_flow_state[if_id] == ON)) {
dhd_cdc.c:983:		ctx->hostif_flow_state[if_id] = OFF;
dhd_cdc.c:985:		WLFC_DBGMESG(("qlen:%02d, if:%02d, ->OFF, start traffic %s()\n",
dhd_cdc.c:986:		pq->len, if_id, __FUNCTION__));
dhd_cdc.c:989:		dhd_txflowcontrol(ctx->dhdp, if_id, OFF);
dhd_cdc.c:990:		ctx->toggle_host_if = 0;
dhd_cdc.c:992:	if ((pq->len >= WLFC_FLOWCONTROL_HIWATER) && (ctx->hostif_flow_state[if_id] == OFF)) {
dhd_cdc.c:994:		ctx->hostif_flow_state[if_id] = ON;
dhd_cdc.c:996:		WLFC_DBGMESG(("qlen:%02d, if:%02d, ->ON, stop traffic   %s()\n",
dhd_cdc.c:997:		pq->len, if_id, __FUNCTION__));
dhd_cdc.c:1000:		dhd_txflowcontrol(ctx->dhdp, if_id, ON);
dhd_cdc.c:1001:		ctx->host_ifidx = if_id;
dhd_cdc.c:1002:		ctx->toggle_host_if = 1;
dhd_cdc.c:1013:	int dummylen = ((dhd_pub_t *)ctx->dhdp)->hdrlen+ 12;
dhd_cdc.c:1016:	p = PKTGET(ctx->osh, dummylen, TRUE);
dhd_cdc.c:1018:		PKTPULL(ctx->osh, p, dummylen);
dhd_cdc.c:1020:		_dhd_wlfc_pushheader(ctx, p, TRUE, ta_bmp, entry->mac_handle, 0);
dhd_cdc.c:1023:		ctx->stats.signal_only_pkts_sent++;
dhd_cdc.c:1025:		rc = dhd_bus_txdata(((dhd_pub_t *)ctx->dhdp)->bus, p);
dhd_cdc.c:1027:			PKTFREE(ctx->osh, p, TRUE);
dhd_cdc.c:1031:		DHD_ERROR(("%s: couldn't allocate new %d-byte packet\n",
dhd_cdc.c:1045:	if (entry->state == WLFC_STATE_CLOSE) {
dhd_cdc.c:1046:		if ((pktq_plen(&entry->psq, (prec << 1)) == 0) &&
dhd_cdc.c:1047:			(pktq_plen(&entry->psq, ((prec << 1) + 1)) == 0)) {
dhd_cdc.c:1049:			if (entry->traffic_pending_bmp & NBITVAL(prec)) {
dhd_cdc.c:1051:				entry->traffic_pending_bmp =
dhd_cdc.c:1052:					entry->traffic_pending_bmp & ~ NBITVAL(prec);
dhd_cdc.c:1056:			if (!(entry->traffic_pending_bmp & NBITVAL(prec))) {
dhd_cdc.c:1058:				entry->traffic_pending_bmp =
dhd_cdc.c:1059:					entry->traffic_pending_bmp | NBITVAL(prec);
dhd_cdc.c:1065:		if (entry->traffic_lastreported_bmp != entry->traffic_pending_bmp) {
dhd_cdc.c:1066:			entry->send_tim_signal = 1;
dhd_cdc.c:1067:			_dhd_wlfc_send_signalonly_packet(ctx, entry, entry->traffic_pending_bmp);
dhd_cdc.c:1068:			entry->traffic_lastreported_bmp = entry->traffic_pending_bmp;
dhd_cdc.c:1069:			entry->send_tim_signal = 0;
dhd_cdc.c:1089:	- suppressed packets go to sub_queue[2*prec + 1] AND
dhd_cdc.c:1090:	- delayed packets go to sub_queue[2*prec + 0] to ensure
dhd_cdc.c:1093:	if (WLFC_PKTQ_PENQ(&entry->psq, ((prec << 1) + 1), p) == NULL) {
dhd_cdc.c:1094:		ctx->stats.delayq_full_error++;
dhd_cdc.c:1101:	_dhd_wlfc_flow_control_check(ctx, &entry->psq, DHD_PKTTAG_IF(PKTTAG(p)));
dhd_cdc.c:1125:	if (entry->send_tim_signal) {
dhd_cdc.c:1127:		entry->send_tim_signal = 0;
dhd_cdc.c:1128:		entry->traffic_lastreported_bmp = entry->traffic_pending_bmp;
dhd_cdc.c:1131:		hslot = dhd_wlfc_hanger_get_free_slot(ctx->hanger);
dhd_cdc.c:1134:		WLFC_PKTFLAG_SET_GENERATION(htod, entry->generation);
dhd_cdc.c:1135:		entry->transit_count++;
dhd_cdc.c:1159:			entry->traffic_lastreported_bmp, entry->mac_handle, htod);
dhd_cdc.c:1167:			rc = dhd_wlfc_hanger_pushpkt(ctx->hanger, p, hslot);
dhd_cdc.c:1172:				((wlfc_hanger_t*)(ctx->hanger))->items[hslot].push_time =
dhd_cdc.c:1189:			dhd_wlfc_hanger_get_genbit(ctx->hanger, p, hslot, &gen);
dhd_cdc.c:1195:				entry->traffic_lastreported_bmp, entry->mac_handle, htod);
dhd_cdc.c:1206:	if (ctx->destination_entries.interfaces[entry->interface_id].iftype ==
dhd_cdc.c:1208:		/* - destination interface is of type p2p GO.
dhd_cdc.c:1211:		destination-specific-credit left send packets. This is because the
dhd_cdc.c:1212:		firmware storing the destination-specific-requested packet in queue.
dhd_cdc.c:1214:		if ((entry->state == WLFC_STATE_CLOSE) && (entry->requested_credit == 0) &&
dhd_cdc.c:1215:			(entry->requested_packet == 0))
dhd_cdc.c:1218:	/* AP, p2p_go -> unicast desc entry, STA/p2p_cl -> interface desc. entry */
dhd_cdc.c:1219:	if (((entry->state == WLFC_STATE_CLOSE) && (entry->requested_credit == 0) &&
dhd_cdc.c:1220:		(entry->requested_packet == 0)) ||
dhd_cdc.c:1221:		(!(entry->ac_bitmap & (1 << prec))))
dhd_cdc.c:1240:	token_pos = ctx->token_pos[prec];
dhd_cdc.c:1246:	table = (wlfc_mac_descriptor_t*)&ctx->destination_entries;
dhd_cdc.c:1247:	total_entries = sizeof(ctx->destination_entries)/sizeof(wlfc_mac_descriptor_t);
dhd_cdc.c:1251:		if (entry->occupied) {
dhd_cdc.c:1253:				p = pktq_mdeq(&entry->psq,
dhd_cdc.c:1261:					if (entry->suppressed == TRUE) {
dhd_cdc.c:1262:						if ((entry->suppr_transit_count <=
dhd_cdc.c:1263:							entry->suppress_count)) {
dhd_cdc.c:1264:							entry->suppressed = FALSE;
dhd_cdc.c:1269:					/* De-Q from delay Q */
dhd_cdc.c:1270:					p = pktq_mdeq(&entry->psq,
dhd_cdc.c:1277:					/* did the packet come from suppress sub-queue? */
dhd_cdc.c:1278:					if (entry->requested_credit > 0) {
dhd_cdc.c:1279:						entry->requested_credit--;
dhd_cdc.c:1281:						entry->dstncredit_sent_packets++;
dhd_cdc.c:1285:						closed state but had a non-zero packets requested,
dhd_cdc.c:1291:						if (entry->state == WLFC_STATE_CLOSE)
dhd_cdc.c:1294:					else if (entry->requested_packet > 0) {
dhd_cdc.c:1295:						entry->requested_packet--;
dhd_cdc.c:1297:						if (entry->state == WLFC_STATE_CLOSE)
dhd_cdc.c:1300:					/* move token to ensure fair round-robin */
dhd_cdc.c:1301:					ctx->token_pos[prec] =
dhd_cdc.c:1304:					_dhd_wlfc_flow_control_check(ctx, &entry->psq,
dhd_cdc.c:1326:	p = pktq_pdeq(&ctx->SENDQ, prec);
dhd_cdc.c:1341:			- suppressed packets go to sub_queue[2*prec + 1] AND
dhd_cdc.c:1342:			- delayed packets go to sub_queue[2*prec + 0] to ensure
dhd_cdc.c:1345:			if (WLFC_PKTQ_PENQ(&entry->psq, (prec << 1), p) == NULL) {
dhd_cdc.c:1347:				/* dhd_txcomplete(ctx->dhdp, p, FALSE); */
dhd_cdc.c:1348:				PKTFREE(ctx->osh, p, TRUE);
dhd_cdc.c:1349:				ctx->stats.delayq_full_error++;
dhd_cdc.c:1357:			p = pktq_pdeq(&ctx->SENDQ, prec);
dhd_cdc.c:1378:		entry->occupied = 1;
dhd_cdc.c:1379:		entry->state = WLFC_STATE_OPEN;
dhd_cdc.c:1380:		entry->requested_credit = 0;
dhd_cdc.c:1381:		entry->interface_id = ifid;
dhd_cdc.c:1382:		entry->iftype = iftype;
dhd_cdc.c:1383:		entry->ac_bitmap = 0xff; /* update this when handling APSD */
dhd_cdc.c:1386:			memcpy(&entry->ea[0], ea, ETHER_ADDR_LEN);
dhd_cdc.c:1387:		pktq_init(&entry->psq, WLFC_PSQ_PREC_COUNT, WLFC_PSQ_LEN);
dhd_cdc.c:1390:		entry->occupied = 1;
dhd_cdc.c:1391:		entry->state = WLFC_STATE_OPEN;
dhd_cdc.c:1392:		entry->requested_credit = 0;
dhd_cdc.c:1393:		entry->interface_id = ifid;
dhd_cdc.c:1394:		entry->iftype = iftype;
dhd_cdc.c:1395:		entry->ac_bitmap = 0xff; /* update this when handling APSD */
dhd_cdc.c:1398:			memcpy(&entry->ea[0], ea, ETHER_ADDR_LEN);
dhd_cdc.c:1401:		entry->occupied = 0;
dhd_cdc.c:1402:		entry->state = WLFC_STATE_CLOSE;
dhd_cdc.c:1403:		entry->requested_credit = 0;
dhd_cdc.c:1404:		/* enable after packets are queued-deqeued properly.
dhd_cdc.c:1405:		pktq_flush(dhd->osh, &entry->psq, FALSE, NULL, 0);
dhd_cdc.c:1425:		   (ctx->FIFO_credit[lender_ac] > 0)) {
dhd_cdc.c:1426:			ctx->credits_borrowed[borrower_ac][lender_ac]++;
dhd_cdc.c:1427:			ctx->FIFO_credit[lender_ac]--;
dhd_cdc.c:1446:	entry = &ctx->destination_entries.interfaces[ifid];
dhd_cdc.c:1456:	ctx->FIFO_credit[0] = credits[0];
dhd_cdc.c:1457:	ctx->FIFO_credit[1] = credits[1];
dhd_cdc.c:1458:	ctx->FIFO_credit[2] = credits[2];
dhd_cdc.c:1459:	ctx->FIFO_credit[3] = credits[3];
dhd_cdc.c:1461:	ctx->FIFO_credit[4] = credits[4];
dhd_cdc.c:1463:	ctx->FIFO_credit[5] = 0;
dhd_cdc.c:1479:	if (FALSE == dhd_prec_enq(ctx->dhdp, &ctx->SENDQ, p, prec)) {
dhd_cdc.c:1480:		ctx->stats.sendq_full_error++;
dhd_cdc.c:1483:		__FUNCTION__, __LINE__, ctx->SENDQ.len));
dhd_cdc.c:1487:		PKTFREE(ctx->osh, p, TRUE);
dhd_cdc.c:1490:	ctx->stats.pktin++;
dhd_cdc.c:1491:	/* _dhd_wlfc_flow_control_check(ctx, &ctx->SENDQ, DHD_PKTTAG_IF(PKTTAG(p))); */
dhd_cdc.c:1515:	DHD_PKTTAG_SETCREDITCHECK(PKTTAG(commit_info->p), commit_info->ac_fifo_credit_spent);
dhd_cdc.c:1516:	rc = _dhd_wlfc_pretx_pktprocess(ctx, commit_info->mac_entry, commit_info->p,
dhd_cdc.c:1517:	     commit_info->needs_hdr, &hslot);
dhd_cdc.c:1520:		rc = fcommit(commit_ctx, commit_info->p);
dhd_cdc.c:1522:		ctx->stats.generic_error++;
dhd_cdc.c:1525:		ctx->stats.pkt2bus++;
dhd_cdc.c:1526:		if (commit_info->ac_fifo_credit_spent) {
dhd_cdc.c:1527:			ctx->stats.sendq_pkts[ac]++;
dhd_cdc.c:1535:		   - remove wl-header for a delayed packet
dhd_cdc.c:1536:		   - save wl-header header for suppressed packets
dhd_cdc.c:1538:		rc = _dhd_wlfc_rollback_packet_toq(ctx,	commit_info->p,
dhd_cdc.c:1539:		     (commit_info->pkt_type), hslot);
dhd_cdc.c:1541:			ctx->stats.rollback_failed++;
dhd_cdc.c:1574:	-NOTE:
dhd_cdc.c:1578:	have to employ weighted round-robin or ucode scheme to avoid
dhd_cdc.c:1582:	for (ac = AC_COUNT; ac >= 0; ac--) {
dhd_cdc.c:1584:		int initial_credit_count = ctx->FIFO_credit[ac];
dhd_cdc.c:1598:				if (ctx->FIFO_credit[ac]) {
dhd_cdc.c:1607:							credit_count--;
dhd_cdc.c:1622:		for (credit = 0; credit < ctx->FIFO_credit[ac];) {
dhd_cdc.c:1647:					ctx->FIFO_credit[ac] -= credit;
dhd_cdc.c:1653:		ctx->FIFO_credit[ac] -= credit;
dhd_cdc.c:1656:		/* If no credits were used, the queue is idle and can be re-used
dhd_cdc.c:1659:		if (initial_credit_count == ctx->FIFO_credit[ac]) {
dhd_cdc.c:1661:			credit_count += ctx->FIFO_credit[ac];
dhd_cdc.c:1677:		if (ctx->allow_credit_borrow) {
dhd_cdc.c:1684:			if (curr_t > ctx->borrow_defer_timestamp)
dhd_cdc.c:1685:				delta = curr_t - ctx->borrow_defer_timestamp;
dhd_cdc.c:1687:				delta = 0xffffffff + curr_t - ctx->borrow_defer_timestamp;
dhd_cdc.c:1691:				ctx->allow_credit_borrow = TRUE;
dhd_cdc.c:1692:				ctx->borrow_defer_timestamp = 0;
dhd_cdc.c:1699:		ctx->allow_credit_borrow = FALSE;
dhd_cdc.c:1700:		ctx->borrow_defer_timestamp = OSL_SYSUPTIME();
dhd_cdc.c:1726:				credit_count--;
dhd_cdc.c:1745:		((athost_wl_status_info_t*)dhdp->wlfc_state)->destination_entries.nodes;
dhd_cdc.c:1762:		dhd->wlfc_state;
dhd_cdc.c:1770:		wlfc->stats.signal_only_pkts_freed++;
dhd_cdc.c:1773:			/* is this a signal-only packet? */
dhd_cdc.c:1774:			PKTFREE(wlfc->osh, txp, TRUE);
dhd_cdc.c:1781:		dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(DHD_PKTTAG_H2DTAG
dhd_cdc.c:1794:			for (lender = AC_COUNT; lender >= 0; lender--) {
dhd_cdc.c:1795:				if (wlfc->credits_borrowed[fifo_id][lender] > 0) {
dhd_cdc.c:1796:					wlfc->FIFO_credit[lender]++;
dhd_cdc.c:1797:					wlfc->credits_borrowed[fifo_id][lender]--;
dhd_cdc.c:1804:				wlfc->FIFO_credit[fifo_id]++;
dhd_cdc.c:1808:		PKTFREE(wlfc->osh, txp, TRUE);
dhd_cdc.c:1828:		dhd->wlfc_state;
dhd_cdc.c:1837:	wlfc->stats.txstatus_in++;
dhd_cdc.c:1840:		wlfc->stats.pkt_freed++;
dhd_cdc.c:1844:		wlfc->stats.d11_suppress++;
dhd_cdc.c:1849:		wlfc->stats.wl_suppress++;
dhd_cdc.c:1854:		wlfc->stats.wlc_tossed_pkts++;
dhd_cdc.c:1862:		ret = dhd_wlfc_hanger_poppkt(wlfc->hanger,
dhd_cdc.c:1873:			if (!entry->suppressed || entry->generation != WLFC_PKTID_GEN(status)) {
dhd_cdc.c:1874:				entry->suppressed = TRUE;
dhd_cdc.c:1875:				entry->suppress_count = pktq_mlen(&entry->psq,
dhd_cdc.c:1877:				entry->suppr_transit_count = entry->transit_count;
dhd_cdc.c:1879:			entry->generation = WLFC_PKTID_GEN(status);
dhd_cdc.c:1887:			old_t = ((wlfc_hanger_t*)(wlfc->hanger))->items[
dhd_cdc.c:1891:			wlfc->stats.latency_sample_count++;
dhd_cdc.c:1893:				delta = new_t - old_t;
dhd_cdc.c:1895:				delta = 0xffffffff + new_t - old_t;
dhd_cdc.c:1896:			wlfc->stats.total_status_latency += delta;
dhd_cdc.c:1897:			wlfc->stats.latency_most_recent = delta;
dhd_cdc.c:1899:			wlfc->stats.deltas[wlfc->stats.idx_delta++] = delta;
dhd_cdc.c:1900:			if (wlfc->stats.idx_delta == sizeof(wlfc->stats.deltas)/sizeof(uint32))
dhd_cdc.c:1901:				wlfc->stats.idx_delta = 0;
dhd_cdc.c:1909:			if (wlfc->proptxstatus_mode == WLFC_FCMODE_IMPLIED_CREDIT) {
dhd_cdc.c:1914:				for (lender = AC_COUNT; lender >= 0; lender--)	{
dhd_cdc.c:1915:					if (wlfc->credits_borrowed[fifo_id][lender] > 0) {
dhd_cdc.c:1916:						wlfc->FIFO_credit[lender]++;
dhd_cdc.c:1917:						wlfc->credits_borrowed[fifo_id][lender]--;
dhd_cdc.c:1924:					wlfc->FIFO_credit[fifo_id]++;
dhd_cdc.c:1938:				entry->requested_credit++;
dhd_cdc.c:1940:			entry->dstncredit_acks++;
dhd_cdc.c:1949:				dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(status),
dhd_cdc.c:1954:				entry->transit_count--;
dhd_cdc.c:1958:				if (entry->suppressed) {
dhd_cdc.c:1959:					entry->suppr_transit_count--;
dhd_cdc.c:1961:				PKTFREE(wlfc->osh, pktbuf, TRUE);
dhd_cdc.c:1965:				dhd_wlfc_hanger_mark_suppressed(wlfc->hanger,
dhd_cdc.c:1967:				entry->suppress_count++;
dhd_cdc.c:1972:			entry->transit_count--;
dhd_cdc.c:1977:			if (entry->suppressed) {
dhd_cdc.c:1978:				entry->suppr_transit_count--;
dhd_cdc.c:1981:			PKTFREE(wlfc->osh, pktbuf, TRUE);
dhd_cdc.c:1999:		dhd->wlfc_state;
dhd_cdc.c:2003:	wlfc->stats.txstatus_in++;
dhd_cdc.c:2006:		wlfc->stats.pkt_freed++;
dhd_cdc.c:2010:		wlfc->stats.d11_suppress++;
dhd_cdc.c:2015:		wlfc->stats.wl_suppress++;
dhd_cdc.c:2020:		wlfc->stats.wlc_tossed_pkts++;
dhd_cdc.c:2023:	ret = dhd_wlfc_hanger_poppkt(wlfc->hanger,
dhd_cdc.c:2034:		if (!entry->suppressed || entry->generation != WLFC_PKTID_GEN(status)) {
dhd_cdc.c:2035:			entry->suppressed = TRUE;
dhd_cdc.c:2036:			entry->suppress_count = pktq_mlen(&entry->psq,
dhd_cdc.c:2038:			entry->suppr_transit_count = entry->transit_count;
dhd_cdc.c:2040:		entry->generation = WLFC_PKTID_GEN(status);
dhd_cdc.c:2048:		old_t = ((wlfc_hanger_t*)(wlfc->hanger))->items[
dhd_cdc.c:2052:		wlfc->stats.latency_sample_count++;
dhd_cdc.c:2054:			delta = new_t - old_t;
dhd_cdc.c:2056:			delta = 0xffffffff + new_t - old_t;
dhd_cdc.c:2057:		wlfc->stats.total_status_latency += delta;
dhd_cdc.c:2058:		wlfc->stats.latency_most_recent = delta;
dhd_cdc.c:2060:		wlfc->stats.deltas[wlfc->stats.idx_delta++] = delta;
dhd_cdc.c:2061:		if (wlfc->stats.idx_delta == sizeof(wlfc->stats.deltas)/sizeof(uint32))
dhd_cdc.c:2062:			wlfc->stats.idx_delta = 0;
dhd_cdc.c:2070:		if (wlfc->proptxstatus_mode == WLFC_FCMODE_IMPLIED_CREDIT) {
dhd_cdc.c:2075:			for (lender = AC_COUNT; lender >= 0; lender--)	{
dhd_cdc.c:2076:				if (wlfc->credits_borrowed[fifo_id][lender] > 0) {
dhd_cdc.c:2077:					wlfc->FIFO_credit[lender]++;
dhd_cdc.c:2078:					wlfc->credits_borrowed[fifo_id][lender]--;
dhd_cdc.c:2085:				wlfc->FIFO_credit[fifo_id]++;
dhd_cdc.c:2099:			entry->requested_credit++;
dhd_cdc.c:2101:		entry->dstncredit_acks++;
dhd_cdc.c:2110:			dhd_wlfc_hanger_poppkt(wlfc->hanger, WLFC_PKTID_HSLOT_GET(status),
dhd_cdc.c:2115:			entry->transit_count--;
dhd_cdc.c:2119:			if (entry->suppressed) {
dhd_cdc.c:2120:				entry->suppr_transit_count--;
dhd_cdc.c:2122:			PKTFREE(wlfc->osh, pktbuf, TRUE);
dhd_cdc.c:2125:			dhd_wlfc_hanger_mark_suppressed(wlfc->hanger,
dhd_cdc.c:2127:			entry->suppress_count++;
dhd_cdc.c:2132:		entry->transit_count--;
dhd_cdc.c:2135:		if (entry->suppressed) {
dhd_cdc.c:2136:			entry->suppr_transit_count--;
dhd_cdc.c:2139:		PKTFREE(wlfc->osh, pktbuf, TRUE);
dhd_cdc.c:2149:		dhd->wlfc_state;
dhd_cdc.c:2152:		wlfc->stats.fifo_credits_back[i] += credits[i];
dhd_cdc.c:2155:		if (wlfc->proptxstatus_mode == WLFC_FCMODE_EXPLICIT_CREDIT)
dhd_cdc.c:2160:			for (lender = AC_COUNT; (lender >= 0) && (credits[i] > 0); lender--) {
dhd_cdc.c:2161:				if (wlfc->credits_borrowed[i][lender] > 0) {
dhd_cdc.c:2162:					if (credits[i] >= wlfc->credits_borrowed[i][lender]) {
dhd_cdc.c:2163:						credits[i] -= wlfc->credits_borrowed[i][lender];
dhd_cdc.c:2164:						wlfc->FIFO_credit[lender] +=
dhd_cdc.c:2165:						    wlfc->credits_borrowed[i][lender];
dhd_cdc.c:2166:						wlfc->credits_borrowed[i][lender] = 0;
dhd_cdc.c:2169:						wlfc->credits_borrowed[i][lender] -= credits[i];
dhd_cdc.c:2170:						wlfc->FIFO_credit[lender] += credits[i];
dhd_cdc.c:2178:				wlfc->FIFO_credit[i] += credits[i];
dhd_cdc.c:2212:		dhd->wlfc_state;
dhd_cdc.c:2224:	table = wlfc->destination_entries.nodes;
dhd_cdc.c:2237:				wlfc->destination_entries.interfaces[ifid].iftype,
dhd_cdc.c:2242:				wlfc->stats.mac_update_failed++;
dhd_cdc.c:2256:				/* enable after packets are queued-deqeued properly.
dhd_cdc.c:2257:				pktq_flush(dhd->osh, &table[existing_index].psq, FALSE, NULL, 0);
dhd_cdc.c:2266:					wlfc->destination_entries.interfaces[ifid].iftype,
dhd_cdc.c:2271:			wlfc->stats.mac_update_failed++;
dhd_cdc.c:2283:		dhd->wlfc_state;
dhd_cdc.c:2289:	table = wlfc->destination_entries.nodes;
dhd_cdc.c:2291:	if (desc->occupied) {
dhd_cdc.c:2293:		desc->requested_credit = 0;
dhd_cdc.c:2295:			desc->state = WLFC_STATE_OPEN;
dhd_cdc.c:2299:			desc->state = WLFC_STATE_CLOSE;
dhd_cdc.c:2310:		wlfc->stats.psmode_update_failed++;
dhd_cdc.c:2320:		dhd->wlfc_state;
dhd_cdc.c:2325:		table = wlfc->destination_entries.interfaces;
dhd_cdc.c:2338:	wlfc->stats.interface_update_failed++;
dhd_cdc.c:2347:		dhd->wlfc_state;
dhd_cdc.c:2353:	table = wlfc->destination_entries.nodes;
dhd_cdc.c:2358:	if (desc->occupied) {
dhd_cdc.c:2359:		desc->requested_credit = credit;
dhd_cdc.c:2361:		desc->ac_bitmap = value[2];
dhd_cdc.c:2364:		wlfc->stats.credit_request_failed++;
dhd_cdc.c:2373:		dhd->wlfc_state;
dhd_cdc.c:2379:	table = wlfc->destination_entries.nodes;
dhd_cdc.c:2384:	if (desc->occupied) {
dhd_cdc.c:2385:		desc->requested_packet = packet_count;
dhd_cdc.c:2387:		desc->ac_bitmap = value[2];
dhd_cdc.c:2390:		wlfc->stats.packet_request_failed++;
dhd_cdc.c:2418:		dhd->wlfc_state;
dhd_cdc.c:2419:	tmpbuf = (uint8*)PKTDATA(dhd->osh, pktbuf);
dhd_cdc.c:2424:				remainder -= 1;
dhd_cdc.c:2435:			remainder -= 2 + len;
dhd_cdc.c:2475:			wlfc->stats.tlv_parse_failed++;
dhd_cdc.c:2486:	uint32 tlv = dhd->wlfc_enabled?
dhd_cdc.c:2511:			dhd->wlfc_enabled?"enabled":"disabled", tlv));
dhd_cdc.c:2524:	if (!dhd->wlfc_enabled || dhd->wlfc_state)
dhd_cdc.c:2528:	dhd->wlfc_state = MALLOC(dhd->osh, sizeof(athost_wl_status_info_t));
dhd_cdc.c:2529:	if (dhd->wlfc_state == NULL)
dhd_cdc.c:2533:	wlfc = (athost_wl_status_info_t*)dhd->wlfc_state;
dhd_cdc.c:2537:	wlfc->osh = dhd->osh;
dhd_cdc.c:2538:	wlfc->dhdp = dhd;
dhd_cdc.c:2540:	wlfc->hanger =
dhd_cdc.c:2541:		dhd_wlfc_hanger_create(dhd->osh, WLFC_HANGER_MAXITEMS);
dhd_cdc.c:2542:	if (wlfc->hanger == NULL) {
dhd_cdc.c:2543:		MFREE(dhd->osh, dhd->wlfc_state, sizeof(athost_wl_status_info_t));
dhd_cdc.c:2544:		dhd->wlfc_state = NULL;
dhd_cdc.c:2550:		wlfc->hostif_flow_state[i] = OFF;
dhd_cdc.c:2555:	sub-queues for all AC precedences + 1 for bc/mc traffic
dhd_cdc.c:2557:	pktq_init(&wlfc->SENDQ, (AC_COUNT + 1), WLFC_SENDQ_LEN);
dhd_cdc.c:2559:	wlfc->destination_entries.other.state = WLFC_STATE_OPEN;
dhd_cdc.c:2561:	wlfc->destination_entries.other.ac_bitmap = 0x1f;
dhd_cdc.c:2562:	wlfc->destination_entries.other.interface_id = 0;
dhd_cdc.c:2564:	wlfc->proptxstatus_mode = WLFC_FCMODE_EXPLICIT_CREDIT;
dhd_cdc.c:2566:	wlfc->allow_credit_borrow = TRUE;
dhd_cdc.c:2567:	wlfc->borrow_defer_timestamp = 0;
dhd_cdc.c:2579:		dhd->wlfc_state;
dhd_cdc.c:2587:	if (dhd->wlfc_state == NULL)
dhd_cdc.c:2589:	/* flush bus->txq */
dhd_cdc.c:2590:	txq = dhd_bus_txq(dhd->bus);
dhd_cdc.c:2593:	h = (wlfc_hanger_t*)wlfc->hanger;
dhd_cdc.c:2594:	total_entries = sizeof(wlfc->destination_entries)/sizeof(wlfc_mac_descriptor_t);
dhd_cdc.c:2596:	table = (wlfc_mac_descriptor_t*)&wlfc->destination_entries;
dhd_cdc.c:2604:				pktq_flush(wlfc->osh, &table[i].psq, TRUE, NULL, 0);
dhd_cdc.c:2610:	if (wlfc->SENDQ.len)
dhd_cdc.c:2611:		pktq_flush(wlfc->osh, &wlfc->SENDQ, TRUE, NULL, 0);
dhd_cdc.c:2612:	for (prec = 0; prec < txq->num_prec; prec++) {
dhd_cdc.c:2615:			for (i = 0; i < h->max_items; i++) {
dhd_cdc.c:2616:				if (pkt == h->items[i].pkt) {
dhd_cdc.c:2617:					if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE) {
dhd_cdc.c:2618:						PKTFREE(wlfc->osh, h->items[i].pkt, TRUE);
dhd_cdc.c:2619:						h->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
dhd_cdc.c:2620:						h->items[i].pkt = NULL;
dhd_cdc.c:2621:						h->items[i].identifier = 0;
dhd_cdc.c:2622:					} else if (h->items[i].state ==
dhd_cdc.c:2625:						h->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
dhd_cdc.c:2633:	/* flush remained pkt in hanger queue, not in bus->txq */
dhd_cdc.c:2634:	for (i = 0; i < h->max_items; i++) {
dhd_cdc.c:2635:		if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE) {
dhd_cdc.c:2636:			PKTFREE(wlfc->osh, h->items[i].pkt, TRUE);
dhd_cdc.c:2637:			h->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
dhd_cdc.c:2638:		} else if (h->items[i].state == WLFC_HANGER_ITEM_STATE_INUSE_SUPPRESSED) {
dhd_cdc.c:2640:			h->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
dhd_cdc.c:2652:		dhd->wlfc_state;
dhd_cdc.c:2657:	if (dhd->wlfc_state == NULL) {
dhd_cdc.c:2665:		wlfc_hanger_t* h = (wlfc_hanger_t*)wlfc->hanger;
dhd_cdc.c:2666:		for (i = 0; i < h->max_items; i++) {
dhd_cdc.c:2667:			if (h->items[i].state != WLFC_HANGER_ITEM_STATE_FREE) {
dhd_cdc.c:2669:					__FUNCTION__, i, h->items[i].pkt,
dhd_cdc.c:2670:					DHD_PKTTAG_CREDITCHECK(PKTTAG(h->items[i].pkt))));
dhd_cdc.c:2676:	dhd_wlfc_hanger_delete(dhd->osh, wlfc->hanger);
dhd_cdc.c:2679:	MFREE(dhd->osh, dhd->wlfc_state, sizeof(athost_wl_status_info_t));
dhd_cdc.c:2680:	dhd->wlfc_state = NULL;
dhd_cdc.c:2690:	bcm_bprintf(strbuf, "Protocol CDC: reqid %d\n", dhdp->prot->reqid);
dhd_cdc.c:2693:	if (dhdp->wlfc_state)
dhd_cdc.c:2711:	PKTPUSH(dhd->osh, pktbuf, BDC_HEADER_LEN);
dhd_cdc.c:2713:	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
dhd_cdc.c:2715:	h->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);
dhd_cdc.c:2717:		h->flags |= BDC_FLAG_SUM_NEEDED;
dhd_cdc.c:2720:	h->priority = (PKTPRIO(pktbuf) & BDC_PRIORITY_MASK);
dhd_cdc.c:2721:	h->flags2 = 0;
dhd_cdc.c:2722:	h->dataOffset = 0;
dhd_cdc.c:2743:	if (PKTLEN(dhd->osh, pktbuf) < BDC_HEADER_LEN) {
dhd_cdc.c:2745:		           PKTLEN(dhd->osh, pktbuf), BDC_HEADER_LEN));
dhd_cdc.c:2749:	h = (struct bdc_header *)PKTDATA(dhd->osh, pktbuf);
dhd_cdc.c:2752:	h->dataOffset = 0;
dhd_cdc.c:2757:		data_offset = h->dataOffset;
dhd_cdc.c:2758:		PKTPULL(dhd->osh, pktbuf, BDC_HEADER_LEN);
dhd_cdc.c:2768:	if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) != BDC_PROTO_VER) {
dhd_cdc.c:2769:		DHD_ERROR(("%s: non-BDC packet received, flags = 0x%x\n",
dhd_cdc.c:2770:		           dhd_ifname(dhd, *ifidx), h->flags));
dhd_cdc.c:2771:		if (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) == BDC_PROTO_VER_1)
dhd_cdc.c:2772:			h->dataOffset = 0;
dhd_cdc.c:2777:	if (h->flags & BDC_FLAG_SUM_GOOD) {
dhd_cdc.c:2778:		DHD_INFO(("%s: BDC packet received with good rx-csum, flags 0x%x\n",
dhd_cdc.c:2779:		          dhd_ifname(dhd, *ifidx), h->flags));
dhd_cdc.c:2783:	PKTSETPRIO(pktbuf, (h->priority & BDC_PRIORITY_MASK));
dhd_cdc.c:2784:	data_offset = h->dataOffset;
dhd_cdc.c:2785:	PKTPULL(dhd->osh, pktbuf, BDC_HEADER_LEN);
dhd_cdc.c:2789:	if (PKTLEN(dhd->osh, pktbuf) < (uint32) (data_offset << 2)) {
dhd_cdc.c:2791:		           PKTLEN(dhd->osh, pktbuf), (data_offset * 4)));
dhd_cdc.c:2796:	if (dhd->wlfc_state &&
dhd_cdc.c:2797:		((athost_wl_status_info_t*)dhd->wlfc_state)->proptxstatus_mode
dhd_cdc.c:2801:		- parse txstatus only for packets that came from the firmware
dhd_cdc.c:2806:		((athost_wl_status_info_t*)dhd->wlfc_state)->stats.dhd_hdrpulls++;
dhd_cdc.c:2813:		PKTPULL(dhd->osh, pktbuf, (data_offset << 2));
dhd_cdc.c:2822:	if (dhd->wlfc_state &&
dhd_cdc.c:2823:		(((athost_wl_status_info_t*)dhd->wlfc_state)->proptxstatus_mode
dhd_cdc.c:2826:		dhd_wlfc_commit_packets(dhd->wlfc_state, (f_commitpkt_t)dhd_bus_txdata,
dhd_cdc.c:2827:			(void *)dhd->bus);
dhd_cdc.c:2838:	if (!(cdc = (dhd_prot_t *)DHD_OS_PREALLOC(dhd->osh, DHD_PREALLOC_PROT,
dhd_cdc.c:2846:	if ((uintptr)(&cdc->msg + 1) != (uintptr)cdc->buf) {
dhd_cdc.c:2851:	dhd->prot = cdc;
dhd_cdc.c:2853:	dhd->hdrlen += BDC_HEADER_LEN;
dhd_cdc.c:2855:	dhd->maxctl = WLC_IOCTL_MAXLEN + sizeof(cdc_ioctl_t) + ROUND_UP_MARGIN;
dhd_cdc.c:2861:		MFREE(dhd->osh, cdc, sizeof(dhd_prot_t));
dhd_cdc.c:2874:	MFREE(dhd->osh, dhd->prot, sizeof(dhd_prot_t));
dhd_cdc.c:2876:	dhd->prot = NULL;
dhd_cdc.c:2883:	dhd->dstats.tx_packets = dhd->tx_packets;
dhd_cdc.c:2884:	dhd->dstats.tx_errors = dhd->tx_errors;
dhd_cdc.c:2885:	dhd->dstats.rx_packets = dhd->rx_packets;
dhd_cdc.c:2886:	dhd->dstats.rx_errors = dhd->rx_errors;
dhd_cdc.c:2887:	dhd->dstats.rx_dropped = dhd->rx_dropped;
dhd_cdc.c:2888:	dhd->dstats.multicast = dhd->rx_multicast;
dhd_cdc.c:2917:	dhd->iswl = TRUE;
dhd_cdc.c:2938:	if (ptr->pend_pkts == 0) {
dhd_cdc.c:2946:		i = ptr->max_idx + 1;
dhd_cdc.c:2949:			i = ((ptr->max_idx + 1) - start) + end;
dhd_cdc.c:2951:			i = end - start;
dhd_cdc.c:2954:		p = (void *)(ptr->p[start]);
dhd_cdc.c:2955:		ptr->p[start] = NULL;
dhd_cdc.c:2966:		i--;
dhd_cdc.c:2967:		if (start++ == ptr->max_idx)
dhd_cdc.c:3008:	ptr = dhd->reorder_bufs[flow_id];
dhd_cdc.c:3023:		dhd_get_hostreorder_pkts(dhd->osh, ptr, pkt, &cnt, &plast,
dhd_cdc.c:3024:			ptr->exp_idx, ptr->exp_idx);
dhd_cdc.c:3027:			PKTSETNEXT(dhd->osh, plast, cur_pkt);
dhd_cdc.c:3038:		buf_size += ((ptr->max_idx + 1) * sizeof(void *));
dhd_cdc.c:3039:		MFREE(dhd->osh, ptr, buf_size);
dhd_cdc.c:3040:		dhd->reorder_bufs[flow_id] = NULL;
dhd_cdc.c:3054:		ptr = (struct reorder_info *)MALLOC(dhd->osh, buf_size_alloc);
dhd_cdc.c:3061:		dhd->reorder_bufs[flow_id] = ptr;
dhd_cdc.c:3062:		ptr->p = (void *)(ptr+1);
dhd_cdc.c:3063:		ptr->max_idx = max_idx;
dhd_cdc.c:3067:		if (ptr->pend_pkts) {
dhd_cdc.c:3068:			dhd_get_hostreorder_pkts(dhd->osh, ptr, pkt, &cnt, &plast,
dhd_cdc.c:3069:				ptr->exp_idx, ptr->exp_idx);
dhd_cdc.c:3070:			ptr->pend_pkts = 0;
dhd_cdc.c:3072:		ptr->cur_idx = reorder_info_buf[WLHOST_REORDERDATA_CURIDX_OFFSET];
dhd_cdc.c:3073:		ptr->exp_idx = reorder_info_buf[WLHOST_REORDERDATA_EXPIDX_OFFSET];
dhd_cdc.c:3074:		ptr->max_idx = reorder_info_buf[WLHOST_REORDERDATA_MAXIDX_OFFSET];
dhd_cdc.c:3075:		ptr->p[ptr->cur_idx] = cur_pkt;
dhd_cdc.c:3076:		ptr->pend_pkts++;
dhd_cdc.c:3084:		if ((exp_idx == ptr->exp_idx) && (cur_idx != ptr->exp_idx)) {
dhd_cdc.c:3087:			if (ptr->p[cur_idx] != NULL) {
dhd_cdc.c:3090:				PKTFREE(dhd->osh, ptr->p[cur_idx], TRUE);
dhd_cdc.c:3091:				ptr->p[cur_idx] = NULL;
dhd_cdc.c:3093:			ptr->p[cur_idx] = cur_pkt;
dhd_cdc.c:3094:			ptr->pend_pkts++;
dhd_cdc.c:3095:			ptr->cur_idx = cur_idx;
dhd_cdc.c:3097:				__FUNCTION__, ptr->pend_pkts));
dhd_cdc.c:3101:		else if (ptr->exp_idx == cur_idx) {
dhd_cdc.c:3105:			if (ptr->p[cur_idx] != NULL) {
dhd_cdc.c:3108:				PKTFREE(dhd->osh, ptr->p[cur_idx], TRUE);
dhd_cdc.c:3109:				ptr->p[cur_idx] = NULL;
dhd_cdc.c:3111:			ptr->p[cur_idx] = cur_pkt;
dhd_cdc.c:3112:			ptr->pend_pkts++;
dhd_cdc.c:3114:			ptr->cur_idx = cur_idx;
dhd_cdc.c:3115:			ptr->exp_idx = exp_idx;
dhd_cdc.c:3117:			dhd_get_hostreorder_pkts(dhd->osh, ptr, pkt, &cnt, &plast,
dhd_cdc.c:3119:			ptr->pend_pkts -= (uint8)cnt;
dhd_cdc.c:3122:				__FUNCTION__, cnt, ptr->pend_pkts));
dhd_cdc.c:3129:				__FUNCTION__, flow_id, ptr->cur_idx, cur_idx,
dhd_cdc.c:3130:				ptr->exp_idx, exp_idx));
dhd_cdc.c:3132:				end_idx = ptr->exp_idx;
dhd_cdc.c:3137:			dhd_get_hostreorder_pkts(dhd->osh, ptr, pkt, &cnt, &plast,
dhd_cdc.c:3138:				ptr->exp_idx, end_idx);
dhd_cdc.c:3140:			if (cur_idx == ptr->max_idx) {
dhd_cdc.c:3149:					PKTSETNEXT(dhd->osh, plast, cur_pkt);
dhd_cdc.c:3155:				ptr->p[cur_idx] = cur_pkt;
dhd_cdc.c:3156:				ptr->pend_pkts++;
dhd_cdc.c:3158:			ptr->exp_idx = exp_idx;
dhd_cdc.c:3159:			ptr->cur_idx = cur_idx;
dhd_cdc.c:3169:			__FUNCTION__, ptr->cur_idx, ptr->exp_idx, exp_idx));
dhd_cdc.c:3171:			end_idx =  ptr->exp_idx;
dhd_cdc.c:3175:		dhd_get_hostreorder_pkts(dhd->osh, ptr, pkt, &cnt, &plast, ptr->exp_idx, end_idx);
dhd_cdc.c:3176:		ptr->pend_pkts -= (uint8)cnt;
dhd_cdc.c:3178:			PKTSETNEXT(dhd->osh, plast, cur_pkt);
dhd_cdc.c:3184:		ptr->exp_idx = exp_idx;
dhd_cfg80211.c:2: * Linux cfg80211 driver - Dongle Host Driver (DHD) related
dhd_cfg80211.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_cfg80211.c:81:	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
dhd_cfg80211.c:82:	dhd->op_mode |= val;
dhd_cfg80211.c:83:	WL_ERR(("Set : op_mode=0x%04x\n", dhd->op_mode));
dhd_cfg80211.c:85:	if (dhd->arp_version == 1) {
dhd_cfg80211.c:97:	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
dhd_cfg80211.c:98:	dhd->op_mode &= ~(DHD_FLAG_P2P_GC_MODE | DHD_FLAG_P2P_GO_MODE);
dhd_cfg80211.c:99:	WL_ERR(("Clean : op_mode=0x%04x\n", dhd->op_mode));
dhd_cfg80211.c:102:	if (dhd->arp_version == 1) {
dhd_cfg80211.c:156:/* TODO: clean up the BT-Coex code, it still have some legacy ioctl/iovar functions */
dhd_cfg80211.c:163:/* this flag boost wifi pkt priority to max, caution: -not fair to sco */
dhd_cfg80211.c:310:			return -1;
dhd_cfg80211.c:363:		return -1;
dhd_cfg80211.c:379:	/* set = 1, save & turn on  0 - off & restore prev settings */
dhd_cfg80211.c:384:	WL_TRACE(("WI-FI priority boost via bt flags, set:%d\n", set));
dhd_cfg80211.c:402:	bt_local->timer_on = 0;
dhd_cfg80211.c:403:	schedule_work(&bt_local->work);
dhd_cfg80211.c:412:	if (btcx_inf->timer_on) {
dhd_cfg80211.c:413:		btcx_inf->timer_on = 0;
dhd_cfg80211.c:414:		del_timer_sync(&btcx_inf->timer);
dhd_cfg80211.c:417:	switch (btcx_inf->bt_state) {
dhd_cfg80211.c:424:			btcx_inf->bt_state = BT_DHCP_OPPR_WIN;
dhd_cfg80211.c:425:			mod_timer(&btcx_inf->timer,
dhd_cfg80211.c:427:			btcx_inf->timer_on = 1;
dhd_cfg80211.c:431:			if (btcx_inf->dhcp_done) {
dhd_cfg80211.c:442:			if (btcx_inf->dev)
dhd_cfg80211.c:443:				wl_cfg80211_bt_setflag(btcx_inf->dev, TRUE);
dhd_cfg80211.c:444:			btcx_inf->bt_state = BT_DHCP_FLAG_FORCE_TIMEOUT;
dhd_cfg80211.c:445:			mod_timer(&btcx_inf->timer,
dhd_cfg80211.c:447:			btcx_inf->timer_on = 1;
dhd_cfg80211.c:451:			if (btcx_inf->dhcp_done) {
dhd_cfg80211.c:462:			if (btcx_inf->dev)
dhd_cfg80211.c:463:				wl_cfg80211_bt_setflag(btcx_inf->dev, FALSE);
dhd_cfg80211.c:465:			btcx_inf->bt_state = BT_DHCP_IDLE;
dhd_cfg80211.c:466:			btcx_inf->timer_on = 0;
dhd_cfg80211.c:471:				btcx_inf->bt_state));
dhd_cfg80211.c:472:			if (btcx_inf->dev)
dhd_cfg80211.c:473:				wl_cfg80211_bt_setflag(btcx_inf->dev, FALSE);
dhd_cfg80211.c:474:			btcx_inf->bt_state = BT_DHCP_IDLE;
dhd_cfg80211.c:475:			btcx_inf->timer_on = 0;
dhd_cfg80211.c:479:	net_os_wake_unlock(btcx_inf->dev);
dhd_cfg80211.c:488:		return -ENOMEM;
dhd_cfg80211.c:490:	btco_inf->bt_state = BT_DHCP_IDLE;
dhd_cfg80211.c:491:	btco_inf->ts_dhcp_start = 0;
dhd_cfg80211.c:492:	btco_inf->ts_dhcp_ok = 0;
dhd_cfg80211.c:494:	btco_inf->timer_ms = 10;
dhd_cfg80211.c:495:	init_timer(&btco_inf->timer);
dhd_cfg80211.c:496:	btco_inf->timer.data = (ulong)btco_inf;
dhd_cfg80211.c:497:	btco_inf->timer.function = wl_cfg80211_bt_timerfunc;
dhd_cfg80211.c:499:	btco_inf->dev = wl->wdev->netdev;
dhd_cfg80211.c:501:	INIT_WORK(&btco_inf->work, wl_cfg80211_bt_handler);
dhd_cfg80211.c:503:	wl->btcoex_info = btco_inf;
dhd_cfg80211.c:509:	if (!wl->btcoex_info)
dhd_cfg80211.c:512:	if (wl->btcoex_info->timer_on) {
dhd_cfg80211.c:513:		wl->btcoex_info->timer_on = 0;
dhd_cfg80211.c:514:		del_timer_sync(&wl->btcoex_info->timer);
dhd_cfg80211.c:517:	cancel_work_sync(&wl->btcoex_info->work);
dhd_cfg80211.c:519:	kfree(wl->btcoex_info);
dhd_cfg80211.c:520:	wl->btcoex_info = NULL;
dhd_cfg80211.c:541:	struct btcoex_info *btco_inf = wl->btcoex_info;
dhd_cfg80211.c:545:	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
dhd_cfg80211.c:560:		dhd->dhcp_in_progress = 1;
dhd_cfg80211.c:562:		if (dhd->early_suspended) {
dhd_cfg80211.c:597:					btco_inf->bt_state = BT_DHCP_START;
dhd_cfg80211.c:598:					btco_inf->timer_on = 1;
dhd_cfg80211.c:599:					mod_timer(&btco_inf->timer, btco_inf->timer.expires);
dhd_cfg80211.c:613:		dhd->dhcp_in_progress = 0;
dhd_cfg80211.c:622:		if (dhd->early_suspended) {
dhd_cfg80211.c:633:		if (btco_inf->timer_on) {
dhd_cfg80211.c:634:			btco_inf->timer_on = 0;
dhd_cfg80211.c:635:			del_timer_sync(&btco_inf->timer);
dhd_cfg80211.c:637:			if (btco_inf->bt_state != BT_DHCP_IDLE) {
dhd_cfg80211.c:639:				WL_TRACE(("%s bt->bt_state:%d\n",
dhd_cfg80211.c:640:					__FUNCTION__, btco_inf->bt_state));
dhd_cfg80211.c:642:				schedule_work(&btco_inf->work);
dhd_cfg80211.c:664:			WL_TRACE(("restore regs {66,41,68} <- 0x%x 0x%x 0x%x\n",
dhd_cfg80211.h:2: * Linux cfg80211 driver - Dongle Host Driver (DHD) related
dhd_cfg80211.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_common.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_common.c:24: * $Id: dhd_common.c 373873 2012-12-10 20:45:58Z $
dhd_common.c:173:	0 - Do not do any proptxtstatus flow control
dhd_common.c:174:	1 - Use implied credit from a packet status
dhd_common.c:175:	2 - Use explicit credit
dhd_common.c:193:	bcm_strncpy_s(fw_path, sizeof(fw_path), CONFIG_BCMDHD_FW_PATH, MOD_PARAM_PATHLEN-1);
dhd_common.c:198:	bcm_strncpy_s(nv_path, sizeof(nv_path), CONFIG_BCMDHD_NVRAM_PATH, MOD_PARAM_PATHLEN-1);
dhd_common.c:221:	            dhdp->up, dhdp->txoff, dhdp->busstate);
dhd_common.c:223:	            dhdp->hdrlen, dhdp->maxctl, dhdp->rxsz);
dhd_common.c:225:	            dhdp->iswl, dhdp->drv_version, bcm_ether_ntoa(&dhdp->mac, eabuf));
dhd_common.c:226:	bcm_bprintf(strbuf, "pub.bcmerror %d tickcnt %d\n", dhdp->bcmerror, dhdp->tickcnt);
dhd_common.c:230:	            dhdp->dstats.tx_packets, dhdp->dstats.tx_bytes,
dhd_common.c:231:	            dhdp->dstats.tx_errors, dhdp->dstats.tx_dropped);
dhd_common.c:233:	            dhdp->dstats.rx_packets, dhdp->dstats.rx_bytes,
dhd_common.c:234:	            dhdp->dstats.rx_errors, dhdp->dstats.rx_dropped);
dhd_common.c:235:	bcm_bprintf(strbuf, "multicast %ld\n", dhdp->dstats.multicast);
dhd_common.c:239:	            dhdp->tx_packets, dhdp->tx_multicast, dhdp->tx_errors);
dhd_common.c:241:	            dhdp->tx_ctlpkts, dhdp->tx_ctlerrs);
dhd_common.c:243:	            dhdp->rx_packets, dhdp->rx_multicast, dhdp->rx_errors);
dhd_common.c:245:	            dhdp->rx_ctlpkts, dhdp->rx_ctlerrs, dhdp->rx_dropped);
dhd_common.c:247:	            dhdp->rx_readahead_cnt, dhdp->tx_realloc);
dhd_common.c:257:	return (!strbuf->size ? BCME_BUFTOOSHORT : 0);
dhd_common.c:282:	if ((ret) && (dhd_pub->up))
dhd_common.c:355:		bcm_strncpy_s((char *)arg, len, bcmerrorstr(dhd_pub->bcmerror), BCME_STRLEN);
dhd_common.c:356:		((char *)arg)[BCME_STRLEN - 1] = 0x00;
dhd_common.c:360:		int_val = (int32)dhd_pub->bcmerror;
dhd_common.c:370:		if (!dhd_pub->up) {
dhd_common.c:393:			bcmerror = dhd_bus_console_in(dhd_pub, arg, len - 1);
dhd_common.c:398:		dhd_pub->tx_packets = dhd_pub->rx_packets = 0;
dhd_common.c:399:		dhd_pub->tx_errors = dhd_pub->rx_errors = 0;
dhd_common.c:400:		dhd_pub->tx_ctlpkts = dhd_pub->rx_ctlpkts = 0;
dhd_common.c:401:		dhd_pub->tx_ctlerrs = dhd_pub->rx_ctlerrs = 0;
dhd_common.c:402:		dhd_pub->rx_dropped = 0;
dhd_common.c:403:		dhd_pub->rx_readahead_cnt = 0;
dhd_common.c:404:		dhd_pub->tx_realloc = 0;
dhd_common.c:405:		dhd_pub->wd_dpc_sched = 0;
dhd_common.c:406:		memset(&dhd_pub->dstats, 0, sizeof(dhd_pub->dstats));
dhd_common.c:410:		if (dhd_pub->wlfc_state) {
dhd_common.c:412:			        (athost_wl_status_info_t*)dhd_pub->wlfc_state;
dhd_common.c:415:			memset(&wlfc->stats, 0, sizeof(athost_wl_stat_counters_t));
dhd_common.c:417:			hanger = (wlfc_hanger_t*)wlfc->hanger;
dhd_common.c:418:			hanger->pushed = 0;
dhd_common.c:419:			hanger->popped = 0;
dhd_common.c:420:			hanger->failed_slotfind = 0;
dhd_common.c:421:			hanger->failed_to_pop = 0;
dhd_common.c:422:			hanger->failed_to_push = 0;
dhd_common.c:451:		if (len < (int)(HCI_CMD_PREAMBLE_SIZE + cmd->plen))
dhd_common.c:466:		if (len < (int)(HCI_ACL_DATA_PREAMBLE_SIZE + ACL_data->dlen))
dhd_common.c:476:		int_val = dhd_pub->wlfc_enabled? 1 : 0;
dhd_common.c:481:		dhd_pub->wlfc_enabled = int_val? 1 : 0;
dhd_common.c:486:		        (athost_wl_status_info_t*)dhd_pub->wlfc_state;
dhd_common.c:487:		int_val = dhd_pub->wlfc_state ? (int32)wlfc->proptxstatus_mode : 0;
dhd_common.c:493:		if (dhd_pub->wlfc_state) {
dhd_common.c:495:			        (athost_wl_status_info_t*)dhd_pub->wlfc_state;
dhd_common.c:496:			wlfc->proptxstatus_mode = int_val & 0xff;
dhd_common.c:513:		int_val = dhd_pub->htsfdlystat_sz;
dhd_common.c:518:		dhd_pub->htsfdlystat_sz = int_val & 0xff;
dhd_common.c:519:		printf("Setting tsfdlystat_sz:%d\n", dhd_pub->htsfdlystat_sz);
dhd_common.c:535:			if (dhd_pub->reorder_bufs[i] != NULL) {
dhd_common.c:536:				*ptr = dhd_pub->reorder_bufs[i]->flow_id;
dhd_common.c:576:	int eprec = -1;		/* precedence to evict from */
dhd_common.c:600:		discard_oldest = AC_BITMAP_TST(dhdp->wme_dp, eprec);
dhd_common.c:607:		PKTFREE(dhdp->osh, p, TRUE);
dhd_common.c:652:	if (vi->type == IOVT_VOID)
dhd_common.c:654:	else if (vi->type == IOVT_BUFFER)
dhd_common.c:660:	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
dhd_common.c:679:	switch (ioc->cmd) {
dhd_common.c:689:			bcmerror = -BCME_BUFTOOSHORT;
dhd_common.c:700:		for (arg = buf, arglen = buflen; *arg && arglen; arg++, arglen--)
dhd_common.c:709:		arg++, arglen--;
dhd_common.c:712:		if (ioc->cmd == DHD_GET_VAR)
dhd_common.c:721:		if (ioc->cmd == DHD_GET_VAR)
dhd_common.c:731:		if (ioc->cmd == DHD_GET_VAR) {
dhd_common.c:761:	event_type = ntoh32(event->event_type);
dhd_common.c:762:	flags = ntoh16(event->flags);
dhd_common.c:763:	status = ntoh32(event->status);
dhd_common.c:764:	reason = ntoh32(event->reason);
dhd_common.c:766:	auth_type = ntoh32(event->auth_type);
dhd_common.c:767:	datalen = ntoh32(event->datalen);
dhd_common.c:771:	        (uchar)event->addr.octet[0]&0xff,
dhd_common.c:772:	        (uchar)event->addr.octet[1]&0xff,
dhd_common.c:773:	        (uchar)event->addr.octet[2]&0xff,
dhd_common.c:774:	        (uchar)event->addr.octet[3]&0xff,
dhd_common.c:775:	        (uchar)event->addr.octet[4]&0xff,
dhd_common.c:776:	        (uchar)event->addr.octet[5]&0xff);
dhd_common.c:934:			printf("\nMACEVENT: %s [unsupported version --> "
dhd_common.c:946:			printf("\nWLC_E_TRACE: [Discarded traces in dongle -->"
dhd_common.c:951:		nblost = ntoh32(hdr.seqnum) - seqnum_prev - 1;
dhd_common.c:953:			printf("\nWLC_E_TRACE: [Event lost --> seqnum %d nblost %d\n",
dhd_common.c:1014:	if (bcmp(BRCM_OUI, &pvt_data->bcm_hdr.oui[0], DOT11_OUI_LEN)) {
dhd_common.c:1019:	/* BRCM event pkt may be unaligned - use xxx_ua to load user_subtype. */
dhd_common.c:1020:	if (ntoh16_ua((void *)&pvt_data->bcm_hdr.usr_subtype) != BCMILCP_BCM_SUBTYPE_EVENT) {
dhd_common.c:1029:	memcpy(event, &pvt_data->event, sizeof(wl_event_msg_t));
dhd_common.c:1031:	type = ntoh32_ua((void *)&event->event_type);
dhd_common.c:1032:	flags = ntoh16_ua((void *)&event->flags);
dhd_common.c:1033:	status = ntoh32_ua((void *)&event->status);
dhd_common.c:1034:	datalen = ntoh32_ua((void *)&event->datalen);
dhd_common.c:1040:		dhd_wlfc_event(dhd_pub->info);
dhd_common.c:1041:		dhd_wlfc_FIFOcreditmap_event(dhd_pub->info, event_data);
dhd_common.c:1054:		uint8* ea = pvt_data->eth.ether_dhost;
dhd_common.c:1057:		              ifevent->ifidx,
dhd_common.c:1058:		              ((ifevent->action == WLC_E_IF_ADD) ? "ADD":"DEL"),
dhd_common.c:1059:		              ((ifevent->is_AP == 0) ? "STA":"AP "),
dhd_common.c:1062:		if (ifevent->action == WLC_E_IF_CHANGE)
dhd_common.c:1063:			dhd_wlfc_interface_event(dhd_pub->info,
dhd_common.c:1065:				ifevent->ifidx, ifevent->is_AP, ea);
dhd_common.c:1067:			dhd_wlfc_interface_event(dhd_pub->info,
dhd_common.c:1068:				((ifevent->action == WLC_E_IF_ADD) ?
dhd_common.c:1070:				ifevent->ifidx, ifevent->is_AP, ea);
dhd_common.c:1074:		if (ifevent->ifidx == 0)
dhd_common.c:1082:					__FUNCTION__, ifevent->ifidx,
dhd_common.c:1083:					event->ifname, ifevent->action));
dhd_common.c:1084:				if (ifevent->action == WLC_E_IF_ADD ||
dhd_common.c:1085:					ifevent->action == WLC_E_IF_CHANGE)
dhd_common.c:1090:		if (ifevent->ifidx > 0 && ifevent->ifidx < DHD_MAX_IFS) {
dhd_common.c:1091:					if (ifevent->action == WLC_E_IF_ADD) {
dhd_common.c:1092:						if (dhd_add_if(dhd_pub->info, ifevent->ifidx,
dhd_common.c:1093:							NULL, event->ifname,
dhd_common.c:1094:							event->addr.octet,
dhd_common.c:1095:							ifevent->flags, ifevent->bssidx)) {
dhd_common.c:1099:									ifevent->ifidx,
dhd_common.c:1100:									event->ifname));
dhd_common.c:1104:					else if (ifevent->action == WLC_E_IF_DEL)
dhd_common.c:1105:						dhd_del_if(dhd_pub->info, ifevent->ifidx);
dhd_common.c:1109:			           __FUNCTION__, ifevent->ifidx, event->ifname));
dhd_common.c:1114:			*ifidx = dhd_ifname2idx(dhd_pub->info, event->ifname);
dhd_common.c:1116:			dhd_event(dhd_pub->info, (char *)pvt_data, evlen, *ifidx);
dhd_common.c:1122:		htsf_update(dhd_pub->info, event_data);
dhd_common.c:1132:		memcpy((void *)(&pvt_data->event.event_type), &temp,
dhd_common.c:1133:		       sizeof(pvt_data->event.event_type));
dhd_common.c:1147:		*ifidx = dhd_ifname2idx(dhd_pub->info, event->ifname);
dhd_common.c:1149:		dhd_event(dhd_pub->info, (char *)pvt_data, evlen, *ifidx);
dhd_common.c:1159:			temp = ntoh32_ua((void *)&event->event_type);
dhd_common.c:1163:			memcpy((void *)(&pvt_data->event.event_type), &temp,
dhd_common.c:1164:			       sizeof(pvt_data->event.event_type));
dhd_common.c:1180:	 * byte order. Convert all members to host-order.
dhd_common.c:1182:	evt->event_type = ntoh32(evt->event_type);
dhd_common.c:1183:	evt->flags = ntoh16(evt->flags);
dhd_common.c:1184:	evt->status = ntoh32(evt->status);
dhd_common.c:1185:	evt->reason = ntoh32(evt->reason);
dhd_common.c:1186:	evt->auth_type = ntoh32(evt->auth_type);
dhd_common.c:1187:	evt->datalen = ntoh32(evt->datalen);
dhd_common.c:1188:	evt->version = ntoh16(evt->version);
dhd_common.c:1221:/* Convert user's input in hex pattern to byte-size mask */
dhd_common.c:1229:		return -1;
dhd_common.c:1234:		return -1;
dhd_common.c:1263:	if (!(arg_save = MALLOC(dhd->osh, strlen(arg) + 1))) {
dhd_common.c:1317:		MFREE(dhd->osh, arg_org, strlen(arg) + 1);
dhd_common.c:1339:	if (!(arg_save = MALLOC(dhd->osh, strlen(arg) + 1))) {
dhd_common.c:1346:	if (!(buf = MALLOC(dhd->osh, BUF_SIZE))) {
dhd_common.c:1410:		htod32(wl_pattern_atoh(argv[i], (char *) pkt_filterp->u.pattern.mask_and_pattern));
dhd_common.c:1420:	         (char *) &pkt_filterp->u.pattern.mask_and_pattern[mask_size]));
dhd_common.c:1431:	/* Keep-alive attributes are set in local	variable (keep_alive_pkt), and
dhd_common.c:1451:		MFREE(dhd->osh, arg_org, strlen(arg) + 1);
dhd_common.c:1454:		MFREE(dhd->osh, buf, BUF_SIZE);
dhd_common.c:1501:			dhd->arp_version = 1;
dhd_common.c:1506:			dhd->arp_version = version;
dhd_common.c:1519:	if (dhd->arp_version == 1)
dhd_common.c:1535:	if (dhd->arp_version == 1)
dhd_common.c:1552:	if (dhd->arp_version == 1)
dhd_common.c:1575:		return -1;
dhd_common.c:1576:	if (dhd == NULL) return -1;
dhd_common.c:1577:	if (dhd->arp_version == 1)
dhd_common.c:1588:		return -1;
dhd_common.c:1610:	switch (ntoh32(event->event_type)) {
dhd_common.c:1619:	/* Call per-port handler. */
dhd_common.c:1630:	int ret = -1;
dhd_common.c:1668:	int ret = -1;
dhd_common.c:1671:	bcn_li_dtim = dhd->suspend_bcn_li_dtim;
dhd_common.c:1718:	if (!(dhd->op_mode & DHD_FLAG_STA_MODE))
dhd_common.c:1746:			ret = -1;
dhd_common.c:1760:	int ret = -1;
dhd_common.c:1787:			dhd->pno_enable = pfn_enabled;
dhd_common.c:1789:				__FUNCTION__, dhd->pno_enable ? "Enable" : "Disable"));
dhd_common.c:1802:	int err = -1;
dhd_common.c:1814:		err = -1;
dhd_common.c:1916:	int ret = -1;
dhd_common.c:1921:		return (dhd->pno_enable);
dhd_common.c:1935:	int res 				= -1;
dhd_common.c:1956:	/* Keep-alive attributes are set in local	variable (mkeep_alive_pkt), and
dhd_common.c:1982:		return -1;
dhd_common.c:1993:			return -1;
dhd_common.c:1996:		*bytes_left -= 1;
dhd_common.c:2011:		*bytes_left -= input_size;
dhd_common.c:2031:		return -1;
dhd_common.c:2043:		*bytes_left -= 1;
dhd_common.c:2054:		*bytes_left -= 1;
dhd_common.c:2059:			return -1;
dhd_common.c:2078:		return -1;
dhd_common.c:2090:		*bytes_left -= 1;
dhd_common.c:2097:			*bytes_left -= 1;
dhd_common.c:2105:			*bytes_left -= 1;
dhd_common.c:2112:				return -1;
dhd_common.c:2117:			*bytes_left -= ssid[idx].SSID_len;
dhd_common.c:2125:			return -1;
dhd_common.c:2130:			return -1;
dhd_common.c:2138:/* Parse a comma-separated list from list_str into ssid array, starting
dhd_common.c:2141: * not been copied.  Returns -1 on empty string, or on ssid too long.
dhd_common.c:2149:		return -1;
dhd_common.c:2165:			return -1;
dhd_common.c:2173:			strncpy((char*)ssid[idx].SSID, str, sizeof(ssid[idx].SSID) - 1);
dhd_common.c:2193:		return -1;
dhd_common.c:2203:			return -1;
dhd_common.c:2210:			return -1;
dhd_custom_gpio.c:3:* Copyright (C) 1999-2012, Broadcom Corporation
dhd_custom_gpio.c:23:* $Id: dhd_custom_gpio.c 353167 2012-08-24 22:11:30Z $
dhd_custom_gpio.c:57:int wifi_set_power(int on, unsigned long msec) { return -1; }
dhd_custom_gpio.c:58:int wifi_get_irq_number(unsigned long *irq_flags_ptr) { return -1; }
dhd_custom_gpio.c:59:int wifi_get_mac_addr(unsigned char *buf) { return -1; }
dhd_custom_gpio.c:75:static int dhd_oob_gpio_num = -1;
dhd_custom_gpio.c:196:		return -EINVAL;
dhd_custom_gpio.c:266:*  input : ISO 3166-1 country abbreviation
dhd_custom_gpio.c:280:		strlcpy(cspec->ccode, cloc_ptr->custom_locale, WLC_CNTRY_BUF_SZ);
dhd_custom_gpio.c:281:		cspec->rev = cloc_ptr->custom_locale_rev;
dhd_custom_gpio.c:297:			memcpy(cspec->ccode,
dhd_custom_gpio.c:299:			cspec->rev = translate_custom_table[i].custom_locale_rev;
dhd_custom_gpio.c:305:	memcpy(cspec->ccode, translate_custom_table[0].custom_locale, WLC_CNTRY_BUF_SZ);
dhd_custom_gpio.c:306:	cspec->rev = translate_custom_table[0].custom_locale_rev;
dhd_dbg.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_dbg.h:24: * $Id: dhd_dbg.h 353490 2012-08-27 21:10:02Z $
dhd_gpio.c:3:* Copyright (C) 1999-2011, Broadcom Corporation
dhd_gpio.c:23:* $Id: dhd_custom_gpio.c,v 1.2.42.1 2010-10-19 00:41:09 Exp $
dhd_gpio.c:31://#include <mach/regs-gpio.h>
dhd_gpio.c:32://#include <plat/gpio-cfg.h>
dhd_gpio.c:42://#include <plat/devs.h>	// modifed plat-samsung/dev-hsmmcX.c EXPORT_SYMBOL(s3c_device_hsmmcx) added
dhd_gpio.c:54:	if (host_oob_irq == -ENXIO) {
dhd.h:2: * Header file describing the internal (inter-module) DHD interfaces.
dhd.h:7: * Copyright (C) 1999-2012, Broadcom Corporation
dhd.h:27: * $Id: dhd.h 373887 2012-12-10 21:58:02Z $
dhd.h:51:/* The kernel threading is sdio-specific */
dhd.h:184:	bool txoff;		/* Transmit flow-controlled */
dhd.h:193:	bool iswl;		/* Dongle-resident driver is wl */
dhd.h:194:	ulong drv_version;	/* Version of dongle-resident driver */
dhd.h:196:	dngl_stats_t dstats;	/* Stats for dongle-based data */
dhd.h:213:	ulong rx_readahead_cnt;	/* Number of packets where header read-ahead was used. */
dhd.h:252: *  see target dhd-cdc-sdmmc-panda-cfg80211-icsmr1-gpl-debug in Makefile
dhd.h:304:			countdown -= 10000; \
dhd.h:321:			countdown -= 10;  \
dhd.h:347:	mutex_init(&dhdp->wl_softap_lock);
dhd.h:354:	mutex_lock(&dhdp->wl_softap_lock);
dhd.h:361:	mutex_unlock(&dhdp->wl_softap_lock);
dhd.h:410:/* Value -1 means we are unsuccessful in creating the kthread. */
dhd.h:411:#define DHD_PID_KT_INVALID 	-1
dhd.h:412:/* Value -2 means we are unsuccessful in both creating the kthread and tasklet */
dhd.h:413:#define DHD_PID_KT_TL_INVALID	-2
dhd.h:419:/* To allow osl_attach/detach calls from os-independent modules */
dhd.h:440:/* Indication from bus module to change flow-control state */
dhd.h:634:/* Initial idletime ticks (may be -1 for immediate idle, 0 for no idle) */
dhd.h:656:#define DEFAULT_GLOM_VALUE 	-1
dhd.h:662:#define DEFAULT_ROAM_TRIGGER_VALUE -75 /* dBm default roam trigger all band */
dhd.h:663:#define DEFAULT_ROAM_TRIGGER_SETTING 	-1
dhd.h:670:#define DEFAULT_ROAM_DELTA_SETTING 	-1
dhd.h:734:#define DHD_DEL_IF	-0xe
dhd.h:735:#define DHD_BAD_IF	-0xf
dhd.h:736:#define WL_AUTO_ROAM_TRIGGER -75
dhd.h:742:	b[11 ] - 1 = this packet was sent in response to one time packet request,
dhd.h:744:	b[10 ] - 1 = signal-only-packet to firmware [i.e. nothing to piggyback on]
dhd.h:745:	b[9  ] - 1 = packet is host->firmware (transmit direction)
dhd.h:746:	       - 0 = packet received from firmware (firmware->host)
dhd.h:747:	b[8  ] - 1 = packet was sent due to credit_request (pspoll),
dhd.h:749:	       - 0 = normal transaction, packet counts against FIFO credit
dhd.h:750:	b[7  ] - 1 = AP, 0 = STA
dhd.h:751:	b[6:4] - AC FIFO number
dhd.h:752:	b[3:0] - interface index
dhd.h:760:	This 32-bit goes from host to device for every packet.
dhd.h:777:#define DHD_PKTTAG_SET_H2DTAG(tag, h2dvalue)	((dhd_pkttag_t*)(tag))->htod_tag = (h2dvalue)
dhd.h:778:#define DHD_PKTTAG_H2DTAG(tag)					(((dhd_pkttag_t*)(tag))->htod_tag)
dhd.h:800:#define DHD_PKTTAG_SETFIFO(tag, fifo)	((dhd_pkttag_t*)(tag))->if_flags = \
dhd.h:801:	(((dhd_pkttag_t*)(tag))->if_flags & ~(DHD_PKTTAG_FIFO_MASK << DHD_PKTTAG_FIFO_SHIFT)) | \
dhd.h:803:#define DHD_PKTTAG_FIFO(tag)			((((dhd_pkttag_t*)(tag))->if_flags >> \
dhd.h:806:#define DHD_PKTTAG_SETIF(tag, if)	((dhd_pkttag_t*)(tag))->if_flags = \
dhd.h:807:	(((dhd_pkttag_t*)(tag))->if_flags & ~DHD_PKTTAG_IFMASK) | ((if) & DHD_PKTTAG_IFMASK)
dhd.h:808:#define DHD_PKTTAG_IF(tag)	(((dhd_pkttag_t*)(tag))->if_flags & DHD_PKTTAG_IFMASK)
dhd.h:810:#define DHD_PKTTAG_SETIFTYPE(tag, isAP)	((dhd_pkttag_t*)(tag))->if_flags = \
dhd.h:811:	(((dhd_pkttag_t*)(tag))->if_flags & \
dhd.h:814:#define DHD_PKTTAG_IFTYPE(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
dhd.h:817:#define DHD_PKTTAG_SETCREDITCHECK(tag, check)	((dhd_pkttag_t*)(tag))->if_flags = \
dhd.h:818:	(((dhd_pkttag_t*)(tag))->if_flags & \
dhd.h:821:#define DHD_PKTTAG_CREDITCHECK(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
dhd.h:824:#define DHD_PKTTAG_SETPKTDIR(tag, dir)	((dhd_pkttag_t*)(tag))->if_flags = \
dhd.h:825:	(((dhd_pkttag_t*)(tag))->if_flags & \
dhd.h:828:#define DHD_PKTTAG_PKTDIR(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
dhd.h:831:#define DHD_PKTTAG_SETSIGNALONLY(tag, signalonly)	((dhd_pkttag_t*)(tag))->if_flags = \
dhd.h:832:	(((dhd_pkttag_t*)(tag))->if_flags & \
dhd.h:835:#define DHD_PKTTAG_SIGNALONLY(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
dhd.h:838:#define DHD_PKTTAG_SETONETIMEPKTRQST(tag)	((dhd_pkttag_t*)(tag))->if_flags = \
dhd.h:839:	(((dhd_pkttag_t*)(tag))->if_flags & \
dhd.h:842:#define DHD_PKTTAG_ONETIMEPKTRQST(tag)	((((dhd_pkttag_t*)(tag))->if_flags >> \
dhd.h:845:#define DHD_PKTTAG_SETDSTN(tag, dstn_MAC_ea)	memcpy(((dhd_pkttag_t*)((tag)))->dstn_ether, \
dhd.h:847:#define DHD_PKTTAG_DSTN(tag)	((dhd_pkttag_t*)(tag))->dstn_ether
dhd.h:852:#define DHD_WLFC_CTRINC_MAC_CLOSE(entry)	do { (entry)->closed_ct++; } while (0)
dhd.h:853:#define DHD_WLFC_CTRINC_MAC_OPEN(entry)		do { (entry)->opened_ct++; } while (0)
dhd_linux.c:2: * Broadcom Dongle Host Driver (DHD), Linux-specific network interface
dhd_linux.c:3: * Basically selected code segments from usb-cdc.c and usb-rndis.c
dhd_linux.c:5: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_linux.c:25: * $Id: dhd_linux.c 374275 2012-12-12 11:44:18Z $
dhd_linux.c:153:#define DBUS_RX_BUFFER_SIZE_DHD(net)	(net->mtu + net->hard_header_len + dhd->pub.hdrlen)
dhd_linux.c:155:#define DBUS_RX_BUFFER_SIZE_DHD(net)	(net->mtu + net->hard_header_len + dhd->pub.hdrlen + 128)
dhd_linux.c:390:/* ARP offload agent mode : Enable ARP Host Auto-Reply and ARP Peer Auto-Reply */
dhd_linux.c:424:/* DPC thread priority, -1 to use tasklet */
dhd_linux.c:581:		for (i = 0; i < dhd->pktfilter_count; i++) {
dhd_linux.c:582:			dhd_pktfilter_offload_set(dhd, dhd->pktfilter[i]);
dhd_linux.c:594:	/* 1 - Enable packet filter, only allow unicast packet to send up */
dhd_linux.c:595:	/* 0 - Disable packet filter */
dhd_linux.c:597:	    (dhd_support_sta_mode(dhd) && !dhd->dhcp_in_progress))) {
dhd_linux.c:598:		for (i = 0; i < dhd->pktfilter_count; i++) {
dhd_linux.c:600:			if (value && (i == dhd->pktfilter_count -1) &&
dhd_linux.c:601:				!(dhd->op_mode & (DHD_FLAG_P2P_GC_MODE | DHD_FLAG_P2P_GO_MODE))) {
dhd_linux.c:604:					value, i, dhd->op_mode));
dhd_linux.c:608:			dhd_pktfilter_offload_enable(dhd, dhd->pktfilter[i],
dhd_linux.c:630:	struct dhd_info *dhdinfo = dhd->info;
dhd_linux.c:636:		__FUNCTION__, value, dhd->in_suspend));
dhd_linux.c:639:	if (dhd && dhd->up) {
dhd_linux.c:640:		if (value && dhd->in_suspend) {
dhd_linux.c:642:				dhd->early_suspended = 1;
dhd_linux.c:658:					if (dhdinfo->iflist[i] && dhdinfo->iflist[i]->net)
dhd_linux.c:688:				dhd->early_suspended = 0;
dhd_linux.c:705:					if (dhdinfo->iflist[i] && dhdinfo->iflist[i]->net)
dhd_linux.c:711:				/* restore pre-suspend setting for dtim_skip */
dhd_linux.c:739:	dhd_pub_t *dhdp = &dhd->pub;
dhd_linux.c:744:	dhdp->in_suspend = val;
dhd_linux.c:745:	if ((force || !dhdp->suspend_disable_flag) &&
dhd_linux.c:778: * Generalized timeout mechanism.  Uses spin sleep with exponential back-off until
dhd_linux.c:792:	tmo->limit = usec;
dhd_linux.c:793:	tmo->increment = 0;
dhd_linux.c:794:	tmo->elapsed = 0;
dhd_linux.c:795:	tmo->tick = jiffies_to_usecs(1);
dhd_linux.c:802:	if (tmo->increment == 0) {
dhd_linux.c:803:		tmo->increment = 1;
dhd_linux.c:807:	if (tmo->elapsed >= tmo->limit)
dhd_linux.c:811:	tmo->elapsed += tmo->increment;
dhd_linux.c:813:	if (tmo->increment < tmo->tick) {
dhd_linux.c:814:		OSL_DELAY(tmo->increment);
dhd_linux.c:815:		tmo->increment *= 2;
dhd_linux.c:816:		if (tmo->increment > tmo->tick)
dhd_linux.c:817:			tmo->increment = tmo->tick;
dhd_linux.c:839:		if (dhd->iflist[i] && (dhd->iflist[i]->net == net))
dhd_linux.c:854:	dhd_info = dhd_pub->info;
dhd_linux.c:855:	if (dhd_info && dhd_info->iflist[ifidx])
dhd_linux.c:856:		return dhd_info->iflist[ifidx]->net;
dhd_linux.c:870:	while (--i > 0)
dhd_linux.c:871:		if (dhd->iflist[i] && !strncmp(dhd->iflist[i]->name, name, IFNAMSIZ))
dhd_linux.c:876:	return i;	/* default - the primary interface */
dhd_linux.c:882:	dhd_info_t *dhd = (dhd_info_t *)dhdp->info;
dhd_linux.c:891:	if (dhd->iflist[ifidx] == NULL) {
dhd_linux.c:896:	if (dhd->iflist[ifidx]->net)
dhd_linux.c:897:		return dhd->iflist[ifidx]->net->name;
dhd_linux.c:910:	if (dhd->iflist[i] && dhd->iflist[i]->bssidx == idx)
dhd_linux.c:911:		return dhd->iflist[i]->mac_addr;
dhd_linux.c:933:	ASSERT(dhd && dhd->iflist[ifidx]);
dhd_linux.c:934:	dev = dhd->iflist[ifidx]->net;
dhd_linux.c:943:	cnt = dev->mc_count;
dhd_linux.c:951:	allmulti = (dev->flags & IFF_ALLMULTI) ? TRUE : FALSE;
dhd_linux.c:954:	if (!dhd->pub.early_suspended)
dhd_linux.c:963:	if (!(bufp = buf = MALLOC(dhd->pub.osh, buflen))) {
dhd_linux.c:965:		           dhd_ifname(&dhd->pub, ifidx), cnt));
dhd_linux.c:969:	strncpy(bufp, "mcast_list", buflen - 1);
dhd_linux.c:970:	bufp[buflen - 1] = '\0';
dhd_linux.c:984:		memcpy(bufp, ha->addr, ETHER_ADDR_LEN);
dhd_linux.c:986:		cnt--;
dhd_linux.c:989:	for (mclist = dev->mc_list; (mclist && (cnt > 0));
dhd_linux.c:990:		cnt--, mclist = mclist->next) {
dhd_linux.c:991:		memcpy(bufp, (void *)mclist->dmi_addr, ETHER_ADDR_LEN);
dhd_linux.c:1006:	ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
dhd_linux.c:1009:			dhd_ifname(&dhd->pub, ifidx), cnt));
dhd_linux.c:1013:	MFREE(dhd->pub.osh, buf, buflen);
dhd_linux.c:1021:	if (!(buf = MALLOC(dhd->pub.osh, buflen))) {
dhd_linux.c:1022:		DHD_ERROR(("%s: out of memory for allmulti\n", dhd_ifname(&dhd->pub, ifidx)));
dhd_linux.c:1029:		           dhd_ifname(&dhd->pub, ifidx), (int)sizeof(allmulti), buflen));
dhd_linux.c:1030:		MFREE(dhd->pub.osh, buf, buflen);
dhd_linux.c:1041:	ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
dhd_linux.c:1044:		           dhd_ifname(&dhd->pub, ifidx), ltoh32(allmulti)));
dhd_linux.c:1047:	MFREE(dhd->pub.osh, buf, buflen);
dhd_linux.c:1051:	allmulti = (dev->flags & IFF_PROMISC) ? TRUE : FALSE;
dhd_linux.c:1060:	ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
dhd_linux.c:1063:		           dhd_ifname(&dhd->pub, ifidx), ltoh32(allmulti)));
dhd_linux.c:1075:		DHD_ERROR(("%s: mkiovar failed for cur_etheraddr\n", dhd_ifname(&dhd->pub, ifidx)));
dhd_linux.c:1076:		return -1;
dhd_linux.c:1084:	ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
dhd_linux.c:1086:		DHD_ERROR(("%s: set cur_etheraddr failed\n", dhd_ifname(&dhd->pub, ifidx)));
dhd_linux.c:1088:		memcpy(dhd->iflist[ifidx]->net->dev_addr, addr, ETHER_ADDR_LEN);
dhd_linux.c:1089:		memcpy(dhd->pub.mac.octet, addr, ETHER_ADDR_LEN);
dhd_linux.c:1109:	if (!ifp || !ifp->info || !ifp->idx)
dhd_linux.c:1111:	ASSERT(ifp && ifp->info && ifp->idx);	/* Virtual interfaces only */
dhd_linux.c:1112:	dhd = ifp->info;
dhd_linux.c:1114:	DHD_TRACE(("%s: idx %d, state %d\n", __FUNCTION__, ifp->idx, ifp->state));
dhd_linux.c:1121:	switch (ifp->state) {
dhd_linux.c:1127:		if (ifp->net != NULL) {
dhd_linux.c:1129:			 __FUNCTION__, ifp->net->name));
dhd_linux.c:1130:			netif_stop_queue(ifp->net);
dhd_linux.c:1131:			unregister_netdev(ifp->net);
dhd_linux.c:1132:			free_netdev(ifp->net);
dhd_linux.c:1135:		if (!(ifp->net = alloc_etherdev(sizeof(dhd)))) {
dhd_linux.c:1136:			DHD_ERROR(("%s: OOM - alloc_etherdev\n", __FUNCTION__));
dhd_linux.c:1137:			ret = -ENOMEM;
dhd_linux.c:1140:			strncpy(ifp->net->name, ifp->name, IFNAMSIZ);
dhd_linux.c:1141:			ifp->net->name[IFNAMSIZ - 1] = '\0';
dhd_linux.c:1142:			memcpy(netdev_priv(ifp->net), &dhd, sizeof(dhd));
dhd_linux.c:1144:			if (dhd->dhd_state & DHD_ATTACH_STATE_CFG80211)
dhd_linux.c:1145:				if (!wl_cfg80211_notify_ifadd(ifp->net, ifp->idx, ifp->bssidx,
dhd_linux.c:1147:					ifp->state = DHD_IF_NONE;
dhd_linux.c:1148:					ifp->event2cfg80211 = TRUE;
dhd_linux.c:1152:			if ((err = dhd_net_attach(&dhd->pub, ifp->idx)) != 0) {
dhd_linux.c:1155:				ret = -EOPNOTSUPP;
dhd_linux.c:1158:		if (ap_fw_loaded && !(dhd->dhd_state & DHD_ATTACH_STATE_CFG80211)) {
dhd_linux.c:1160:				flags = dhd_os_spin_lock(&dhd->pub);
dhd_linux.c:1163:				ap_net_dev = ifp->net;
dhd_linux.c:1166:				dhd_os_spin_unlock(&dhd->pub, flags);
dhd_linux.c:1170:					current->pid, ifp->net->name));
dhd_linux.c:1171:				ifp->state = DHD_IF_NONE;
dhd_linux.c:1178:		ifp->state = DHD_IF_DELETING;
dhd_linux.c:1179:		if (ifp->net != NULL) {
dhd_linux.c:1181:			netif_stop_queue(ifp->net);
dhd_linux.c:1183:			if (dhd->dhd_state & DHD_ATTACH_STATE_CFG80211) {
dhd_linux.c:1184:				wl_cfg80211_ifdel_ops(ifp->net);
dhd_linux.c:1187:			unregister_netdev(ifp->net);
dhd_linux.c:1190:			if (dhd->dhd_state & DHD_ATTACH_STATE_CFG80211) {
dhd_linux.c:1199:		DHD_ERROR(("%s: bad op %d\n", __FUNCTION__, ifp->state));
dhd_linux.c:1200:		ASSERT(!ifp->state);
dhd_linux.c:1205:		ifp->set_multicast = FALSE;
dhd_linux.c:1206:		if (ifp->net) {
dhd_linux.c:1207:			free_netdev(ifp->net);
dhd_linux.c:1208:			ifp->net = NULL;
dhd_linux.c:1210:		dhd->iflist[ifp->idx] = NULL;
dhd_linux.c:1212:		flags = dhd_os_spin_lock(&dhd->pub);
dhd_linux.c:1213:		if (ifp->net == ap_net_dev)
dhd_linux.c:1215:		dhd_os_spin_unlock(&dhd->pub, flags);
dhd_linux.c:1217:		MFREE(dhd->pub.osh, ifp, sizeof(*ifp));
dhd_linux.c:1225:	dhd_info_t *dhd = (dhd_info_t *)tsk->parent;
dhd_linux.c:1236:	complete(&tsk->completed);
dhd_linux.c:1239:	while (down_interruptible(&tsk->sema) == 0) {
dhd_linux.c:1242:		if (tsk->terminated) {
dhd_linux.c:1247:		DHD_OS_WAKE_LOCK(&dhd->pub);
dhd_linux.c:1250:			if (dhd->iflist[i]) {
dhd_linux.c:1253:				flags = dhd_os_spin_lock(&dhd->pub);
dhd_linux.c:1255:				dhd_os_spin_unlock(&dhd->pub, flags);
dhd_linux.c:1257:				if (dhd->iflist[i] && dhd->iflist[i]->state)
dhd_linux.c:1258:					dhd_op_if(dhd->iflist[i]);
dhd_linux.c:1260:				if (dhd->iflist[i] == NULL) {
dhd_linux.c:1266:				if (in_ap && dhd->set_macaddress == i+1)  {
dhd_linux.c:1268:						"blocked. \n", dhd->iflist[i]->net->name));
dhd_linux.c:1269:					dhd->set_macaddress = 0;
dhd_linux.c:1273:				if (in_ap && dhd->iflist[i]->set_multicast)  {
dhd_linux.c:1275:					 "in AP Mode, blocked. \n", dhd->iflist[i]->net->name));
dhd_linux.c:1276:					dhd->iflist[i]->set_multicast = FALSE;
dhd_linux.c:1280:				if (dhd->pub.up == 0)
dhd_linux.c:1282:				if (dhd->iflist[i]->set_multicast) {
dhd_linux.c:1283:					dhd->iflist[i]->set_multicast = FALSE;
dhd_linux.c:1286:				if (dhd->set_macaddress == i+1) {
dhd_linux.c:1287:					dhd->set_macaddress = 0;
dhd_linux.c:1288:					if (_dhd_set_mac_address(dhd, i, &dhd->macvalue) == 0) {
dhd_linux.c:1299:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:1303:	complete_and_exit(&tsk->completed, 0);
dhd_linux.c:1317:		return -1;
dhd_linux.c:1319:	ASSERT(dhd->thr_sysioc_ctl.thr_pid >= 0);
dhd_linux.c:1320:	memcpy(&dhd->macvalue, sa->sa_data, ETHER_ADDR_LEN);
dhd_linux.c:1321:	dhd->set_macaddress = ifidx+1;
dhd_linux.c:1322:	up(&dhd->thr_sysioc_ctl.sema);
dhd_linux.c:1337:	ASSERT(dhd->thr_sysioc_ctl.thr_pid >= 0);
dhd_linux.c:1338:	dhd->iflist[ifidx]->set_multicast = TRUE;
dhd_linux.c:1339:	up(&dhd->thr_sysioc_ctl.sema);
dhd_linux.c:1346:	dhd_info_t *di = (dhd_info_t *)(pub->info);
dhd_linux.c:1348:	spin_lock_bh(&di->wlfc_spinlock);
dhd_linux.c:1355:	dhd_info_t *di = (dhd_info_t *)(pub->info);
dhd_linux.c:1358:	spin_unlock_bh(&di->wlfc_spinlock);
dhd_linux.c:1371:	dhd_info_t *dhd = (dhd_info_t *)(dhdp->info);
dhd_linux.c:1375:	if (!dhdp->up || (dhdp->busstate == DHD_BUS_DOWN)) {
dhd_linux.c:1377:		PKTFREE(dhdp->osh, pktbuf, TRUE);
dhd_linux.c:1378:		return -ENODEV;
dhd_linux.c:1382:	if (PKTLEN(dhdp->osh, pktbuf) >= ETHER_HDR_LEN) {
dhd_linux.c:1383:		uint8 *pktdata = (uint8 *)PKTDATA(dhdp->osh, pktbuf);
dhd_linux.c:1386:		if (ETHER_ISMULTI(eh->ether_dhost))
dhd_linux.c:1387:			dhdp->tx_multicast++;
dhd_linux.c:1388:		if (ntoh16(eh->ether_type) == ETHER_TYPE_802_1X)
dhd_linux.c:1389:			atomic_inc(&dhd->pend_8021x_cnt);
dhd_linux.c:1391:		PKTFREE(dhd->pub.osh, pktbuf, TRUE);
dhd_linux.c:1402:	if (dhdp->wlfc_state) {
dhd_linux.c:1407:		DHD_PKTTAG_SETDSTN(PKTTAG(pktbuf), eh->ether_dhost);
dhd_linux.c:1410:		if (ETHER_ISMULTI(eh->ether_dhost))
dhd_linux.c:1426:	if (dhdp->wlfc_state && ((athost_wl_status_info_t*)dhdp->wlfc_state)->proptxstatus_mode
dhd_linux.c:1428:		ret = dhd_wlfc_enque_sendq(dhdp->wlfc_state, DHD_PKTTAG_FIFO(PKTTAG(pktbuf)),
dhd_linux.c:1430:		dhd_wlfc_commit_packets(dhdp->wlfc_state,  (f_commitpkt_t)dhd_bus_txdata,
dhd_linux.c:1431:			dhdp->bus);
dhd_linux.c:1432:		if (((athost_wl_status_info_t*)dhdp->wlfc_state)->toggle_host_if) {
dhd_linux.c:1433:			((athost_wl_status_info_t*)dhdp->wlfc_state)->toggle_host_if = 0;
dhd_linux.c:1439:		/* non-proptxstatus way */
dhd_linux.c:1440:		ret = dhd_bus_txdata(dhdp->bus, pktbuf);
dhd_linux.c:1443:	ret = dhd_bus_txdata(dhdp->bus, pktbuf);
dhd_linux.c:1457:	uint8 htsfdlystat_sz = dhd->pub.htsfdlystat_sz;
dhd_linux.c:1464:	DHD_OS_WAKE_LOCK(&dhd->pub);
dhd_linux.c:1467:	if (dhd->pub.busstate == DHD_BUS_DOWN || dhd->pub.hang_was_sent) {
dhd_linux.c:1469:			__FUNCTION__, dhd->pub.up, dhd->pub.busstate));
dhd_linux.c:1472:		if (dhd->pub.up) {
dhd_linux.c:1476:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:1478:		return -ENODEV;
dhd_linux.c:1488:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:1490:		return -ENODEV;
dhd_linux.c:1498:	if (skb_headroom(skb) < dhd->pub.hdrlen + htsfdlystat_sz) {
dhd_linux.c:1502:		          dhd_ifname(&dhd->pub, ifidx)));
dhd_linux.c:1503:		dhd->pub.tx_realloc++;
dhd_linux.c:1505:		skb2 = skb_realloc_headroom(skb, dhd->pub.hdrlen + htsfdlystat_sz);
dhd_linux.c:1510:			           dhd_ifname(&dhd->pub, ifidx)));
dhd_linux.c:1511:			ret = -ENOMEM;
dhd_linux.c:1517:	if (!(pktbuf = PKTFRMNATIVE(dhd->pub.osh, skb))) {
dhd_linux.c:1519:		           dhd_ifname(&dhd->pub, ifidx)));
dhd_linux.c:1521:		ret = -ENOMEM;
dhd_linux.c:1525:	if (htsfdlystat_sz && PKTLEN(dhd->pub.osh, pktbuf) >= ETHER_ADDR_LEN) {
dhd_linux.c:1526:		uint8 *pktdata = (uint8 *)PKTDATA(dhd->pub.osh, pktbuf);
dhd_linux.c:1529:		if (!ETHER_ISMULTI(eh->ether_dhost) &&
dhd_linux.c:1530:			(ntoh16(eh->ether_type) == ETHER_TYPE_IP)) {
dhd_linux.c:1531:			eh->ether_type = hton16(ETHER_TYPE_BRCM_PKTDLYSTATS);
dhd_linux.c:1536:	ret = dhd_sendpkt(&dhd->pub, ifidx, pktbuf);
dhd_linux.c:1541:		dhd->pub.dstats.tx_dropped++;
dhd_linux.c:1543:		dhd->pub.tx_packets++;
dhd_linux.c:1545:	DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:1559:	dhd_info_t *dhd = dhdp->info;
dhd_linux.c:1568:		dhdp->txoff = state;
dhd_linux.c:1570:			if (dhd->iflist[i]) {
dhd_linux.c:1571:				net = dhd->iflist[i]->net;
dhd_linux.c:1580:		if (dhd->iflist[ifidx]) {
dhd_linux.c:1581:			net = dhd->iflist[ifidx]->net;
dhd_linux.c:1609:	int n = sizeof(packet_type_info)/sizeof(packet_type_info[1]) - 1;
dhd_linux.c:1623:	dhd_info_t *dhd = (dhd_info_t *)dhdp->info;
dhd_linux.c:1650:		ifp = dhd->iflist[ifidx];
dhd_linux.c:1654:			PKTFREE(dhdp->osh, pktbuf, TRUE);
dhd_linux.c:1660:		if (!ifp->net || ifp->net->reg_state != NETREG_REGISTERED) {
dhd_linux.c:1662:		if (!ifp->net || ifp->net->reg_state != NETREG_REGISTERED || !dhd->pub.up) {
dhd_linux.c:1666:			PKTFREE(dhdp->osh, pktbuf, TRUE);
dhd_linux.c:1671:		pnext = PKTNEXT(dhdp->osh, pktbuf);
dhd_linux.c:1672:		PKTSETNEXT(wl->sh.osh, pktbuf, NULL);
dhd_linux.c:1675:		eh = (struct ether_header *)PKTDATA(wl->sh.osh, pktbuf);
dhd_linux.c:1678:		if ((ntoh16(eh->ether_type) < ETHER_TYPE_MIN) &&
dhd_linux.c:1679:		    (PKTLEN(wl->sh.osh, pktbuf) >= RFC1042_HDR_LEN) &&
dhd_linux.c:1680:		    bcmp(lsh, BT_SIG_SNAP_MPROT, DOT11_LLC_SNAP_HDR_LEN - 2) == 0 &&
dhd_linux.c:1681:		    lsh->type == HTON16(BTA_PROT_L2CAP)) {
dhd_linux.c:1689:		if (dhdp->wlfc_state && PKTLEN(wl->sh.osh, pktbuf) == 0) {
dhd_linux.c:1692:			piggy-back on
dhd_linux.c:1694:			((athost_wl_status_info_t*)dhdp->wlfc_state)->stats.wlfc_header_only_pkt++;
dhd_linux.c:1695:			PKTFREE(dhdp->osh, pktbuf, TRUE);
dhd_linux.c:1700:		skb = PKTTONATIVE(dhdp->osh, pktbuf);
dhd_linux.c:1704:		 * Linux 2.4 where 'eth_type_trans' uses the 'net->hard_header_len'
dhd_linux.c:1708:		 * we set the 'net->hard_header_len' to ETH_HLEN + extra space required
dhd_linux.c:1711:		eth = skb->data;
dhd_linux.c:1712:		len = skb->len;
dhd_linux.c:1715:		dump_data = skb->data;
dhd_linux.c:1717:		DHD_ERROR(("RX DUMP - %s\n", _get_packet_type_str(protocol)));
dhd_linux.c:1721:			for (k = 0; k < skb->len; k++) {
dhd_linux.c:1754:		ifp = dhd->iflist[ifidx];
dhd_linux.c:1756:			ifp = dhd->iflist[0];
dhd_linux.c:1759:		skb->dev = ifp->net;
dhd_linux.c:1760:		skb->protocol = eth_type_trans(skb, skb->dev);
dhd_linux.c:1762:		if (skb->pkt_type == PACKET_MULTICAST) {
dhd_linux.c:1763:			dhd->pub.rx_multicast++;
dhd_linux.c:1766:		skb->data = eth;
dhd_linux.c:1767:		skb->len = len;
dhd_linux.c:1776:		if (ntoh16(skb->protocol) == ETHER_TYPE_BRCM) {
dhd_linux.c:1779:			skb->mac_header,
dhd_linux.c:1781:			skb->mac.raw,
dhd_linux.c:1803:			PKTFREE(dhdp->osh, pktbuf, TRUE);
dhd_linux.c:1810:		ASSERT(ifidx < DHD_MAX_IFS && dhd->iflist[ifidx]);
dhd_linux.c:1811:		if (dhd->iflist[ifidx] && !dhd->iflist[ifidx]->state)
dhd_linux.c:1812:			ifp = dhd->iflist[ifidx];
dhd_linux.c:1814:		if (ifp->net)
dhd_linux.c:1815:			ifp->net->last_rx = jiffies;
dhd_linux.c:1817:		dhdp->dstats.rx_bytes += skb->len;
dhd_linux.c:1818:		dhdp->rx_packets++; /* Local count */
dhd_linux.c:1855:	dhd_info_t *dhd = (dhd_info_t *)(dhdp->info);
dhd_linux.c:1864:	eh = (struct ether_header *)PKTDATA(dhdp->osh, txp);
dhd_linux.c:1865:	type  = ntoh16(eh->ether_type);
dhd_linux.c:1868:		atomic_dec(&dhd->pend_8021x_cnt);
dhd_linux.c:1874:	len = PKTLEN(dhdp->osh, txp);
dhd_linux.c:1880:		if (bcmp(lsh, BT_SIG_SNAP_MPROT, DOT11_LLC_SNAP_HDR_LEN - 2) == 0 &&
dhd_linux.c:1881:		    ntoh16(lsh->type) == BTA_PROT_L2CAP) {
dhd_linux.c:1904:	ifp = dhd->iflist[ifidx];
dhd_linux.c:1907:	if (dhd->pub.up) {
dhd_linux.c:1909:		dhd_prot_dstats(&dhd->pub);
dhd_linux.c:1913:	ifp->stats.rx_packets = dhd->pub.dstats.rx_packets;
dhd_linux.c:1914:	ifp->stats.tx_packets = dhd->pub.dstats.tx_packets;
dhd_linux.c:1915:	ifp->stats.rx_bytes = dhd->pub.dstats.rx_bytes;
dhd_linux.c:1916:	ifp->stats.tx_bytes = dhd->pub.dstats.tx_bytes;
dhd_linux.c:1917:	ifp->stats.rx_errors = dhd->pub.dstats.rx_errors;
dhd_linux.c:1918:	ifp->stats.tx_errors = dhd->pub.dstats.tx_errors;
dhd_linux.c:1919:	ifp->stats.rx_dropped = dhd->pub.dstats.rx_dropped;
dhd_linux.c:1920:	ifp->stats.tx_dropped = dhd->pub.dstats.tx_dropped;
dhd_linux.c:1921:	ifp->stats.multicast = dhd->pub.dstats.multicast;
dhd_linux.c:1923:	return &ifp->stats;
dhd_linux.c:1931:	dhd_info_t *dhd = (dhd_info_t *)tsk->parent;
dhd_linux.c:1932:	/* This thread doesn't need any user-level access,
dhd_linux.c:1938:			dhd_watchdog_prio:(MAX_RT_PRIO-1);
dhd_linux.c:1945:	complete(&tsk->completed);
dhd_linux.c:1949:		if (down_interruptible (&tsk->sema) == 0) {
dhd_linux.c:1955:			if (tsk->terminated) {
dhd_linux.c:1959:			dhd_os_sdlock(&dhd->pub);
dhd_linux.c:1960:			if (dhd->pub.dongle_reset == FALSE) {
dhd_linux.c:1964:				dhd_bus_watchdog(&dhd->pub);
dhd_linux.c:1966:				flags = dhd_os_spin_lock(&dhd->pub);
dhd_linux.c:1968:				dhd->pub.tickcnt++;
dhd_linux.c:1969:				time_lapse = jiffies - jiffies_at_start;
dhd_linux.c:1972:				if (dhd->wd_timer_valid)
dhd_linux.c:1973:					mod_timer(&dhd->timer,
dhd_linux.c:1975:						msecs_to_jiffies(dhd_watchdog_ms) -
dhd_linux.c:1977:				dhd_os_spin_unlock(&dhd->pub, flags);
dhd_linux.c:1979:			dhd_os_sdunlock(&dhd->pub);
dhd_linux.c:1984:	complete_and_exit(&tsk->completed, 0);
dhd_linux.c:1993:	if (dhd->pub.dongle_reset) {
dhd_linux.c:1998:	if (dhd->thr_wdt_ctl.thr_pid >= 0) {
dhd_linux.c:1999:		up(&dhd->thr_wdt_ctl.sema);
dhd_linux.c:2004:	dhd_os_sdlock(&dhd->pub);
dhd_linux.c:2006:	dhd_bus_watchdog(&dhd->pub);
dhd_linux.c:2008:	flags = dhd_os_spin_lock(&dhd->pub);
dhd_linux.c:2010:	dhd->pub.tickcnt++;
dhd_linux.c:2013:	if (dhd->wd_timer_valid)
dhd_linux.c:2014:		mod_timer(&dhd->timer, jiffies + msecs_to_jiffies(dhd_watchdog_ms));
dhd_linux.c:2015:	dhd_os_spin_unlock(&dhd->pub, flags);
dhd_linux.c:2016:	dhd_os_sdunlock(&dhd->pub);
dhd_linux.c:2024:	dhd_info_t *dhd = (dhd_info_t *)tsk->parent;
dhd_linux.c:2026:	/* This thread doesn't need any user-level access,
dhd_linux.c:2032:		param.sched_priority = (dhd_dpc_prio < MAX_RT_PRIO)?dhd_dpc_prio:(MAX_RT_PRIO-1);
dhd_linux.c:2040:	complete(&tsk->completed);
dhd_linux.c:2045:		if (down_interruptible(&tsk->sema) == 0) {
dhd_linux.c:2048:			if (tsk->terminated) {
dhd_linux.c:2053:			if (dhd->pub.busstate != DHD_BUS_DOWN) {
dhd_linux.c:2054:				if (dhd_bus_dpc(dhd->pub.bus)) {
dhd_linux.c:2055:					up(&tsk->sema);
dhd_linux.c:2058:					DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2061:				if (dhd->pub.up)
dhd_linux.c:2062:					dhd_bus_stop(dhd->pub.bus, TRUE);
dhd_linux.c:2063:				DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2070:	complete_and_exit(&tsk->completed, 0);
dhd_linux.c:2086:	if (dhd->pub.busstate != DHD_BUS_DOWN) {
dhd_linux.c:2087:		if (dhd_bus_dpc(dhd->pub.bus))
dhd_linux.c:2088:			tasklet_schedule(&dhd->tasklet);
dhd_linux.c:2090:			DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2092:		dhd_bus_stop(dhd->pub.bus, TRUE);
dhd_linux.c:2093:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2100:	dhd_info_t *dhd = (dhd_info_t *)dhdp->info;
dhd_linux.c:2104:	if (dhd->thr_dpc_ctl.thr_pid >= 0) {
dhd_linux.c:2105:		up(&dhd->thr_dpc_ctl.sema);
dhd_linux.c:2110:	if (dhd->dhd_tasklet_create)
dhd_linux.c:2111:		tasklet_schedule(&dhd->tasklet);
dhd_linux.c:2130:	strncpy(buf, "toe_ol", sizeof(buf) - 1);
dhd_linux.c:2131:	buf[sizeof(buf) - 1] = '\0';
dhd_linux.c:2132:	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
dhd_linux.c:2134:		if (ret == -EIO) {
dhd_linux.c:2136:				dhd_ifname(&dhd->pub, ifidx)));
dhd_linux.c:2137:			return -EOPNOTSUPP;
dhd_linux.c:2140:		DHD_INFO(("%s: could not get toe_ol: ret=%d\n", dhd_ifname(&dhd->pub, ifidx), ret));
dhd_linux.c:2165:	strncpy(buf, "toe_ol", sizeof(buf) - 1);
dhd_linux.c:2166:	buf[sizeof(buf) - 1] = '\0';
dhd_linux.c:2169:	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
dhd_linux.c:2171:			dhd_ifname(&dhd->pub, ifidx), ret));
dhd_linux.c:2182:	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
dhd_linux.c:2183:		DHD_ERROR(("%s: could not set toe: ret=%d\n", dhd_ifname(&dhd->pub, ifidx), ret));
dhd_linux.c:2197:	snprintf(info->driver, sizeof(info->driver), "wl");
dhd_linux.c:2198:	snprintf(info->version, sizeof(info->version), "%lu", dhd->pub.drv_version);
dhd_linux.c:2224:		return -EFAULT;
dhd_linux.c:2230:			return -EFAULT;
dhd_linux.c:2232:		drvname[sizeof(info.driver)-1] = '\0';
dhd_linux.c:2241:			strncpy(info.version, EPI_VERSION_STR, sizeof(info.version) - 1);
dhd_linux.c:2242:			info.version[sizeof(info.version) - 1] = '\0';
dhd_linux.c:2246:		else if (!dhd->pub.up) {
dhd_linux.c:2248:			return -ENODEV;
dhd_linux.c:2252:		else if (dhd->pub.iswl)
dhd_linux.c:2257:		snprintf(info.version, sizeof(info.version), "%lu", dhd->pub.drv_version);
dhd_linux.c:2259:			return -EFAULT;
dhd_linux.c:2277:			return -EFAULT;
dhd_linux.c:2284:			return -EFAULT;
dhd_linux.c:2303:				dhd->iflist[0]->net->features |= NETIF_F_IP_CSUM;
dhd_linux.c:2305:				dhd->iflist[0]->net->features &= ~NETIF_F_IP_CSUM;
dhd_linux.c:2312:		return -EOPNOTSUPP;
dhd_linux.c:2326:	dhd = (dhd_info_t *)dhdp->info;
dhd_linux.c:2327:	if (dhd->thr_sysioc_ctl.thr_pid < 0) {
dhd_linux.c:2328:		DHD_ERROR(("%s : skipped due to negative pid - unloading?\n", __FUNCTION__));
dhd_linux.c:2332:	if ((error == -ETIMEDOUT) || (error == -EREMOTEIO) ||
dhd_linux.c:2333:		((dhdp->busstate == DHD_BUS_DOWN) && (!dhdp->dongle_reset))) {
dhd_linux.c:2335:			dhdp->rxcnt_timeout, dhdp->txcnt_timeout, error, dhdp->busstate));
dhd_linux.c:2354:	DHD_OS_WAKE_LOCK(&dhd->pub);
dhd_linux.c:2357:	if (dhd->pub.hang_was_sent) {
dhd_linux.c:2359:		DHD_OS_WAKE_LOCK_CTRL_TIMEOUT_ENABLE(&dhd->pub, DHD_EVENT_TIMEOUT_MS);
dhd_linux.c:2360:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2369:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2370:		return -1;
dhd_linux.c:2378:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2385:		ret = dhd_ethtool(dhd, (void*)ifr->ifr_data);
dhd_linux.c:2386:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2393:		dhd_check_hang(net, &dhd->pub, ret);
dhd_linux.c:2394:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2399:		DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2400:		return -EOPNOTSUPP;
dhd_linux.c:2406:	if (copy_from_user(&ioc, ifr->ifr_data, sizeof(wl_ioctl_t))) {
dhd_linux.c:2426:			if (!(buf = (char*)MALLOC(dhd->pub.osh, buflen))) {
dhd_linux.c:2438:	if ((copy_from_user(&driver, (char *)ifr->ifr_data + sizeof(wl_ioctl_t),
dhd_linux.c:2451:		bcmerror = dhd_ioctl((void *)&dhd->pub, &ioc, buf, buflen);
dhd_linux.c:2453:			dhd->pub.bcmerror = bcmerror;
dhd_linux.c:2458:	if (dhd->pub.busstate != DHD_BUS_DATA) {
dhd_linux.c:2463:	if (!dhd->pub.iswl) {
dhd_linux.c:2470:	 * Intercept WLC_SET_KEY IOCTL - serialize M4 send and set key IOCTL to
dhd_linux.c:2472:	 * intercept WLC_DISASSOC IOCTL - serialize WPS-DONE and WLC_DISASSOC IOCTL to
dhd_linux.c:2473:	 * prevent disassoc frame being sent before WPS-DONE frame.
dhd_linux.c:2536:		bcmerror = dhd_fdaggr_ioctl(&dhd->pub, ifidx, (wl_ioctl_t *)&ioc, buf, buflen);
dhd_linux.c:2542:	bcmerror = dhd_wl_ioctl(&dhd->pub, ifidx, (wl_ioctl_t *)&ioc, buf, buflen);
dhd_linux.c:2545:	dhd_check_hang(net, &dhd->pub, bcmerror);
dhd_linux.c:2549:			bcmerror = -EFAULT;
dhd_linux.c:2553:		MFREE(dhd->pub.osh, buf, buflen);
dhd_linux.c:2555:	DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2581:		if (dhd->iflist[i]) {
dhd_linux.c:2583:			if ((dhd->iflist[i]->state != DHD_IF_DEL) &&
dhd_linux.c:2584:				(dhd->iflist[i]->state != DHD_IF_DELETING)) {
dhd_linux.c:2585:				dhd->iflist[i]->state = DHD_IF_DEL;
dhd_linux.c:2586:				dhd->iflist[i]->idx = i;
dhd_linux.c:2587:				dhd_op_if(dhd->iflist[i]);
dhd_linux.c:2608:	DHD_OS_WAKE_LOCK(&dhd->pub);
dhd_linux.c:2610:	if (dhd->pub.up == 0) {
dhd_linux.c:2618:	dhd->pub.up = 0;
dhd_linux.c:2628:		if ((dhd->dhd_state & DHD_ATTACH_STATE_ADD_IF) &&
dhd_linux.c:2629:			(dhd->dhd_state & DHD_ATTACH_STATE_CFG80211)) {
dhd_linux.c:2636:	dhd_os_wlfc_block(&dhd->pub);
dhd_linux.c:2637:	dhd_wlfc_cleanup(&dhd->pub);
dhd_linux.c:2638:	dhd_os_wlfc_unblock(&dhd->pub);
dhd_linux.c:2641:	dhd_prot_stop(&dhd->pub);
dhd_linux.c:2651:	dhd->pub.rxcnt_timeout = 0;
dhd_linux.c:2652:	dhd->pub.txcnt_timeout = 0;
dhd_linux.c:2654:	DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2675:	DHD_OS_WAKE_LOCK(&dhd->pub);
dhd_linux.c:2678:		if (firmware_path[strlen(firmware_path)-1] == '\n')
dhd_linux.c:2679:			firmware_path[strlen(firmware_path)-1] = '\0';
dhd_linux.c:2680:		COPY_FW_PATH_BY_CHIP( dhd->pub.bus, fw_path, firmware_path);
dhd_linux.c:2684:	dhd->pub.dongle_trap_occured = 0;
dhd_linux.c:2685:	dhd->pub.hang_was_sent = 0;
dhd_linux.c:2695:		ret = -1;
dhd_linux.c:2705:		ret = -1;
dhd_linux.c:2709:	if (!dhd->iflist[ifidx] || dhd->iflist[ifidx]->state == DHD_IF_DEL) {
dhd_linux.c:2711:		ret = -1;
dhd_linux.c:2716:		atomic_set(&dhd->pend_8021x_cnt, 0);
dhd_linux.c:2723:				ret = -1;
dhd_linux.c:2730:		if (dhd->pub.busstate != DHD_BUS_DATA) {
dhd_linux.c:2733:			if ((ret = dhd_bus_start(&dhd->pub)) != 0) {
dhd_linux.c:2735:				ret = -1;
dhd_linux.c:2742:		memcpy(net->dev_addr, dhd->pub.mac.octet, ETHER_ADDR_LEN);
dhd_linux.c:2747:			dhd->iflist[ifidx]->net->features |= NETIF_F_IP_CSUM;
dhd_linux.c:2749:			dhd->iflist[ifidx]->net->features &= ~NETIF_F_IP_CSUM;
dhd_linux.c:2755:			ret = -1;
dhd_linux.c:2763:	dhd->pub.up = 1;
dhd_linux.c:2766:	dhd_dbg_init(&dhd->pub);
dhd_linux.c:2774:	DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:2788:		return -EINVAL;
dhd_linux.c:2804:	if (dhd->pub.busstate == DHD_BUS_DATA) {
dhd_linux.c:2811:		return -1;
dhd_linux.c:2845:	DHD_TRACE(("%s: idx %d, handle->%p\n", __FUNCTION__, ifidx, handle));
dhd_linux.c:2849:	ifp = dhd->iflist[ifidx];
dhd_linux.c:2851:		if (ifp->net != NULL) {
dhd_linux.c:2852:			netif_stop_queue(ifp->net);
dhd_linux.c:2853:			unregister_netdev(ifp->net);
dhd_linux.c:2854:			free_netdev(ifp->net);
dhd_linux.c:2857:		if ((ifp = MALLOC(dhd->pub.osh, sizeof(dhd_if_t))) == NULL) {
dhd_linux.c:2858:			DHD_ERROR(("%s: OOM - dhd_if_t\n", __FUNCTION__));
dhd_linux.c:2859:			return -ENOMEM;
dhd_linux.c:2863:	ifp->event2cfg80211 = FALSE;
dhd_linux.c:2864:	ifp->info = dhd;
dhd_linux.c:2865:	dhd->iflist[ifidx] = ifp;
dhd_linux.c:2866:	strncpy(ifp->name, name, IFNAMSIZ);
dhd_linux.c:2867:	ifp->name[IFNAMSIZ] = '\0';
dhd_linux.c:2869:		memcpy(&ifp->mac_addr, mac_addr, ETHER_ADDR_LEN);
dhd_linux.c:2872:		ifp->state = DHD_IF_ADD;
dhd_linux.c:2873:		ifp->idx = ifidx;
dhd_linux.c:2874:		ifp->bssidx = bssidx;
dhd_linux.c:2875:		ASSERT(dhd->thr_sysioc_ctl.thr_pid >= 0);
dhd_linux.c:2876:		up(&dhd->thr_sysioc_ctl.sema);
dhd_linux.c:2878:		ifp->net = (struct net_device *)handle;
dhd_linux.c:2881:		ifp->event2cfg80211 = TRUE;
dhd_linux.c:2895:	ifp = dhd->iflist[ifidx];
dhd_linux.c:2901:	ifp->state = DHD_IF_DEL;
dhd_linux.c:2902:	ifp->idx = ifidx;
dhd_linux.c:2903:	ASSERT(dhd->thr_sysioc_ctl.thr_pid >= 0);
dhd_linux.c:2904:	up(&dhd->thr_sysioc_ctl.sema);
dhd_linux.c:2948:		strncpy(nv_path, nvram_path, sizeof(nv_path) -1);
dhd_linux.c:2949:		nv_path[sizeof(nv_path) -1] = '\0';
dhd_linux.c:2954:		DHD_ERROR(("%s: OOM - alloc_etherdev\n", __FUNCTION__));
dhd_linux.c:2961:		DHD_ERROR(("%s: OOM - alloc dhd_info\n", __FUNCTION__));
dhd_linux.c:2967:	dhd->thr_dpc_ctl.thr_pid = DHD_PID_KT_TL_INVALID;
dhd_linux.c:2968:	dhd->thr_wdt_ctl.thr_pid = DHD_PID_KT_INVALID;
dhd_linux.c:2970:	dhd->dhd_tasklet_create = FALSE;
dhd_linux.c:2971:	dhd->thr_sysioc_ctl.thr_pid = DHD_PID_KT_INVALID;
dhd_linux.c:2978:	dhd->pub.osh = osh;
dhd_linux.c:2981:	dhd->pub.info = dhd;
dhd_linux.c:2983:	dhd->pub.bus = bus;
dhd_linux.c:2984:	dhd->pub.hdrlen = bus_hdrlen;
dhd_linux.c:2990:		strncpy(net->name, iface_name, IFNAMSIZ);
dhd_linux.c:2991:		net->name[IFNAMSIZ - 1] = 0;
dhd_linux.c:2992:		len = strlen(net->name);
dhd_linux.c:2993:		ch = net->name[len - 1];
dhd_linux.c:2994:		if ((ch > '9' || ch < '0') && (len < IFNAMSIZ - 2))
dhd_linux.c:2995:			strcat(net->name, "%d");
dhd_linux.c:2998:	if (dhd_add_if(dhd, 0, (void *)net, net->name, NULL, 0, 0) == DHD_BAD_IF)
dhd_linux.c:3003:	net->open = NULL;
dhd_linux.c:3005:	net->netdev_ops = NULL;
dhd_linux.c:3008:	sema_init(&dhd->proto_sem, 1);
dhd_linux.c:3011:	spin_lock_init(&dhd->wlfc_spinlock);
dhd_linux.c:3013:	dhd->pub.wlfc_enabled = FALSE;
dhd_linux.c:3015:	dhd->pub.wlfc_enabled = TRUE;
dhd_linux.c:3020:	init_waitqueue_head(&dhd->ioctl_resp_wait);
dhd_linux.c:3021:	init_waitqueue_head(&dhd->ctrl_wait);
dhd_linux.c:3024:	spin_lock_init(&dhd->sdlock);
dhd_linux.c:3025:	spin_lock_init(&dhd->txqlock);
dhd_linux.c:3026:	spin_lock_init(&dhd->dhd_lock);
dhd_linux.c:3029:	spin_lock_init(&dhd->wakelock_spinlock);
dhd_linux.c:3030:	dhd->wakelock_counter = 0;
dhd_linux.c:3031:	dhd->wakelock_wd_counter = 0;
dhd_linux.c:3032:	dhd->wakelock_rx_timeout_enable = 0;
dhd_linux.c:3033:	dhd->wakelock_ctrl_timeout_enable = 0;
dhd_linux.c:3035:	dhd->wl_wifi = MALLOC(osh, sizeof(struct wake_lock));
dhd_linux.c:3036:	dhd->wl_rxwake = MALLOC(osh, sizeof(struct wake_lock));
dhd_linux.c:3037:	dhd->wl_ctrlwake = MALLOC(osh, sizeof(struct wake_lock));
dhd_linux.c:3038:	dhd->wl_wdwake = MALLOC(osh, sizeof(struct wake_lock));
dhd_linux.c:3039:	if (!dhd->wl_wifi || !dhd->wl_rxwake || !dhd->wl_ctrlwake || !dhd->wl_wdwake) {
dhd_linux.c:3043:	wake_lock_init(dhd->wl_wifi, WAKE_LOCK_SUSPEND, "wlan_wake");
dhd_linux.c:3044:	wake_lock_init(dhd->wl_rxwake, WAKE_LOCK_SUSPEND, "wlan_rx_wake");
dhd_linux.c:3045:	wake_lock_init(dhd->wl_ctrlwake, WAKE_LOCK_SUSPEND, "wlan_ctrl_wake");
dhd_linux.c:3046:	wake_lock_init(dhd->wl_wdwake, WAKE_LOCK_SUSPEND, "wlan_wd_wake");
dhd_linux.c:3049:	mutex_init(&dhd->dhd_net_if_mutex);
dhd_linux.c:3050:	mutex_init(&dhd->dhd_suspend_mutex);
dhd_linux.c:3055:	if (dhd_prot_attach(&dhd->pub) != 0) {
dhd_linux.c:3066:	if (unlikely(wl_cfg80211_attach(net, &dhd->pub))) {
dhd_linux.c:3071:	dhd_monitor_init(&dhd->pub);
dhd_linux.c:3077:		if (wl_iw_attach(net, (void *)&dhd->pub) != 0) {
dhd_linux.c:3087:	init_timer(&dhd->timer);
dhd_linux.c:3088:	dhd->timer.data = (ulong)dhd;
dhd_linux.c:3089:	dhd->timer.function = dhd_watchdog;
dhd_linux.c:3093:	sema_init(&dhd->sdsem, 1);
dhd_linux.c:3095:		dhd->threads_only = TRUE;
dhd_linux.c:3098:		dhd->threads_only = FALSE;
dhd_linux.c:3104:		PROC_START2(dhd_watchdog_thread, dhd, &dhd->thr_wdt_ctl, 0, "dhd_watchdog_thread");
dhd_linux.c:3106:		PROC_START(dhd_watchdog_thread, dhd, &dhd->thr_wdt_ctl, 0);
dhd_linux.c:3109:		dhd->thr_wdt_ctl.thr_pid = -1;
dhd_linux.c:3116:		PROC_START2(dhd_dpc_thread, dhd, &dhd->thr_dpc_ctl, 0, "dhd_dpc");
dhd_linux.c:3118:		PROC_START(dhd_dpc_thread, dhd, &dhd->thr_dpc_ctl, 0);
dhd_linux.c:3122:		tasklet_init(&dhd->tasklet, dhd_dpc, (ulong)dhd);
dhd_linux.c:3123:		dhd->thr_dpc_ctl.thr_pid = -1;
dhd_linux.c:3127:	tasklet_init(&dhd->tasklet, dhd_dpc, (ulong)dhd);
dhd_linux.c:3128:	dhd->dhd_tasklet_create = TRUE;
dhd_linux.c:3133:		PROC_START2(_dhd_sysioc_thread, dhd, &dhd->thr_sysioc_ctl, 0, "dhd_sysioc");
dhd_linux.c:3135:		PROC_START(_dhd_sysioc_thread, dhd, &dhd->thr_sysioc_ctl, 0);
dhd_linux.c:3138:		dhd->thr_sysioc_ctl.thr_pid = -1;
dhd_linux.c:3142:	INIT_WORK(&dhd->work_hang, dhd_hang_process);
dhd_linux.c:3154:	dhd->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 20;
dhd_linux.c:3155:	dhd->early_suspend.suspend = dhd_early_suspend;
dhd_linux.c:3156:	dhd->early_suspend.resume = dhd_late_resume;
dhd_linux.c:3157:	register_early_suspend(&dhd->early_suspend);
dhd_linux.c:3162:	dhd->pend_ipaddr = 0;
dhd_linux.c:3167:	dhd->dhd_state = dhd_state;
dhd_linux.c:3168:	return &dhd->pub;
dhd_linux.c:3174:		DHD_TRACE(("%s: Calling dhd_detach dhd_state 0x%x &dhd->pub %p\n",
dhd_linux.c:3175:			__FUNCTION__, dhd_state, &dhd->pub));
dhd_linux.c:3176:		dhd->dhd_state = dhd_state;
dhd_linux.c:3177:		dhd_detach(&dhd->pub);
dhd_linux.c:3178:		dhd_free(&dhd->pub);
dhd_linux.c:3187:	int ret = -1;
dhd_linux.c:3188:	dhd_info_t *dhd = (dhd_info_t*)dhdp->info;
dhd_linux.c:3196:	if (dhd->threads_only)
dhd_linux.c:3202:	if  ((dhd->pub.busstate == DHD_BUS_DOWN) &&
dhd_linux.c:3206:		if (!(dhd_bus_download_firmware(dhd->pub.bus, dhd->pub.osh,
dhd_linux.c:3211:			if (dhd->threads_only)
dhd_linux.c:3214:			return -1;
dhd_linux.c:3217:	if (dhd->pub.busstate != DHD_BUS_LOAD) {
dhd_linux.c:3219:		if (dhd->threads_only)
dhd_linux.c:3222:		return -ENETDOWN;
dhd_linux.c:3226:	dhd->pub.tickcnt = 0;
dhd_linux.c:3227:	dhd_os_wd_timer(&dhd->pub, dhd_watchdog_ms);
dhd_linux.c:3230:	if ((ret = dhd_bus_init(&dhd->pub, FALSE)) != 0) {
dhd_linux.c:3234:		if (dhd->threads_only)
dhd_linux.c:3245:		flags = dhd_os_spin_lock(&dhd->pub);
dhd_linux.c:3246:		dhd->wd_timer_valid = FALSE;
dhd_linux.c:3247:		dhd_os_spin_unlock(&dhd->pub, flags);
dhd_linux.c:3248:		del_timer_sync(&dhd->timer);
dhd_linux.c:3251:		if (dhd->threads_only)
dhd_linux.c:3254:		DHD_OS_WD_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:3255:		return -ENODEV;
dhd_linux.c:3259:	dhd_enable_oob_intr(dhd->pub.bus, TRUE);
dhd_linux.c:3263:	if (dhd->pub.busstate != DHD_BUS_DATA) {
dhd_linux.c:3264:		flags = dhd_os_spin_lock(&dhd->pub);
dhd_linux.c:3265:		dhd->wd_timer_valid = FALSE;
dhd_linux.c:3266:		dhd_os_spin_unlock(&dhd->pub, flags);
dhd_linux.c:3267:		del_timer_sync(&dhd->timer);
dhd_linux.c:3270:		if (dhd->threads_only)
dhd_linux.c:3273:		DHD_OS_WD_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:3274:		return -ENODEV;
dhd_linux.c:3278:	if (dhd->threads_only)
dhd_linux.c:3283:	if ((dhd->pub.busstate == DHD_BUS_DATA) && bcmsdh_glom_enabled()) {
dhd_linux.c:3293:	if ((ret = dhd_prot_init(&dhd->pub)) < 0)
dhd_linux.c:3297:	dhd_write_macaddr(dhd->pub.mac.octet);
dhd_linux.c:3301:	if (dhd->pend_ipaddr) {
dhd_linux.c:3303:		aoe_update_host_ipv4_table(&dhd->pub, dhd->pend_ipaddr, TRUE, 0);
dhd_linux.c:3305:		dhd->pend_ipaddr = 0;
dhd_linux.c:3317:	if (dhd->op_mode & DHD_FLAG_CONCURR_MULTI_CHAN_MODE)
dhd_linux.c:3319:	else if ((dhd->op_mode & DHD_FLAG_CONCURR_SINGLE_CHAN_MODE) ==
dhd_linux.c:3338:	/* if dhd->op_mode is already set for HOSTAP,
dhd_linux.c:3341:	if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE)
dhd_linux.c:3457:	dhd->suspend_bcn_li_dtim = CUSTOM_SUSPEND_BCN_LI_DTIM;
dhd_linux.c:3460:	dhd->wlfc_enabled = FALSE;
dhd_linux.c:3463:	dhd->wlfc_enabled = TRUE;
dhd_linux.c:3467:	dhd->op_mode = 0;
dhd_linux.c:3478:		memcpy(dhd->mac.octet, ea_addr.octet, ETHER_ADDR_LEN);
dhd_linux.c:3490:		memcpy(dhd->mac.octet, buf, ETHER_ADDR_LEN);
dhd_linux.c:3503:		dhd->op_mode = DHD_FLAG_HOSTAP_MODE;
dhd_linux.c:3525:			memcpy(dhd->mac.octet, iovbuf, ETHER_ADDR_LEN);
dhd_linux.c:3547:			dhd->op_mode = DHD_FLAG_P2P_MODE;
dhd_linux.c:3550:			dhd->op_mode = DHD_FLAG_STA_MODE;
dhd_linux.c:3556:			dhd->op_mode |= concurrent_mode;
dhd_linux.c:3560:		if (dhd->op_mode & DHD_FLAG_P2P_MODE) {
dhd_linux.c:3567:			memcpy(&p2p_ea, &dhd->mac, ETHER_ADDR_LEN);
dhd_linux.c:3585:		dhd->op_mode,
dhd_linux.c:3586:		MAC2STRDBG(dhd->mac.octet)));
dhd_linux.c:3588:	if (dhd->dhd_cspec.ccode[0] != 0) {
dhd_linux.c:3589:		bcm_mkiovar("country", (char *)&dhd->dhd_cspec,
dhd_linux.c:3601:	/* Disable built-in roaming to allowed ext supplicant to take care of roaming */
dhd_linux.c:3655:	/* Set Keep Alive : be sure to use FW with -keepalive */
dhd_linux.c:3661:		if (!(dhd->op_mode & DHD_FLAG_HOSTAP_MODE)) {
dhd_linux.c:3712:	if (dhd->op_mode & DHD_FLAG_P2P_MODE) {
dhd_linux.c:3750:	dhd->pktfilter_count = 5;
dhd_linux.c:3752:	dhd->pktfilter[0] = "100 0 0 0 0x01 0x00";
dhd_linux.c:3753:	dhd->pktfilter[1] = NULL;
dhd_linux.c:3754:	dhd->pktfilter[2] = NULL;
dhd_linux.c:3755:	dhd->pktfilter[3] = NULL;
dhd_linux.c:3757:	dhd->pktfilter[4] = "104 0 0 0 0xFFFFFFFFFFFF 0x01005E0000FB";
dhd_linux.c:3846:	struct dhd_info *dhd = dhdp->info;
dhd_linux.c:3849:	ASSERT(dhd && dhd->iflist[ifidx]);
dhd_linux.c:3850:	dev = dhd->iflist[ifidx]->net;
dhd_linux.c:3854:		DHD_ERROR(("%s: Must be down to change its MTU", dev->name));
dhd_linux.c:3866:	dev->mtu = new_mtu;
dhd_linux.c:3939:	if (!ifa || !(ifa->ifa_dev->dev))
dhd_linux.c:3944:	if ((ifa->ifa_dev->dev->netdev_ops != &dhd_ops_pri) &&
dhd_linux.c:3945:	    (ifa->ifa_dev->dev->netdev_ops != &dhd_ops_virt)) {
dhd_linux.c:3947:		if (!wl_cfgp2p_is_ifops(ifa->ifa_dev->dev->netdev_ops))
dhd_linux.c:3953:	dhd = *(dhd_info_t **)netdev_priv(ifa->ifa_dev->dev);
dhd_linux.c:3957:	dhd_pub = &dhd->pub;
dhd_linux.c:3959:	if (dhd_pub->arp_version == 1) {
dhd_linux.c:3964:			if (dhd->iflist[idx] && dhd->iflist[idx]->net == ifa->ifa_dev->dev)
dhd_linux.c:3968:			DHD_TRACE(("ifidx : %p %s %d\n", dhd->iflist[idx]->net,
dhd_linux.c:3969:				dhd->iflist[idx]->name, dhd->iflist[idx]->idx));
dhd_linux.c:3971:			DHD_ERROR(("Cannot find ifidx for(%s) set to 0\n", ifa->ifa_label));
dhd_linux.c:3979:				__FUNCTION__, ifa->ifa_label, ifa->ifa_address));
dhd_linux.c:3981:			if (dhd->pub.busstate != DHD_BUS_DATA) {
dhd_linux.c:3983:				if (dhd->pend_ipaddr) {
dhd_linux.c:3985:						__FUNCTION__, dhd->pend_ipaddr));
dhd_linux.c:3987:				dhd->pend_ipaddr = ifa->ifa_address;
dhd_linux.c:3994:			aoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, TRUE, idx);
dhd_linux.c:4000:				__FUNCTION__, ifa->ifa_label, ifa->ifa_address));
dhd_linux.c:4001:			dhd->pend_ipaddr = 0;
dhd_linux.c:4005:			aoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, FALSE, idx);
dhd_linux.c:4007:			dhd_aoe_hostip_clr(&dhd->pub, idx);
dhd_linux.c:4008:			dhd_aoe_arp_clr(&dhd->pub, idx);
dhd_linux.c:4014:				__func__, ifa->ifa_label, event));
dhd_linux.c:4024:	dhd_info_t *dhd = (dhd_info_t *)dhdp->info;
dhd_linux.c:4031:	ASSERT(dhd && dhd->iflist[ifidx]);
dhd_linux.c:4033:	net = dhd->iflist[ifidx]->net;
dhd_linux.c:4037:	ASSERT(!net->open);
dhd_linux.c:4038:	net->get_stats = dhd_get_stats;
dhd_linux.c:4039:	net->do_ioctl = dhd_ioctl_entry;
dhd_linux.c:4040:	net->hard_start_xmit = dhd_start_xmit;
dhd_linux.c:4041:	net->set_mac_address = dhd_set_mac_address;
dhd_linux.c:4042:	net->set_multicast_list = dhd_set_multicast_list;
dhd_linux.c:4043:	net->open = net->stop = NULL;
dhd_linux.c:4045:	ASSERT(!net->netdev_ops);
dhd_linux.c:4046:	net->netdev_ops = &dhd_ops_virt;
dhd_linux.c:4055:		net->open = dhd_open;
dhd_linux.c:4056:		net->stop = dhd_stop;
dhd_linux.c:4058:		net->netdev_ops = &dhd_ops_pri;
dhd_linux.c:4060:		if (!ETHER_ISNULLADDR(dhd->pub.mac.octet))
dhd_linux.c:4061:			memcpy(temp_addr, dhd->pub.mac.octet, ETHER_ADDR_LEN);
dhd_linux.c:4066:		memcpy(temp_addr, dhd->iflist[ifidx]->mac_addr, ETHER_ADDR_LEN);
dhd_linux.c:4072:		if (!memcmp(temp_addr, dhd->iflist[0]->mac_addr,
dhd_linux.c:4075:			__func__, net->name));
dhd_linux.c:4080:	net->hard_header_len = ETH_HLEN + dhd->pub.hdrlen;
dhd_linux.c:4082:	net->ethtool_ops = &dhd_ethtool_ops;
dhd_linux.c:4087:	net->get_wireless_stats = dhd_get_wireless_stats;
dhd_linux.c:4090:	net->wireless_handlers = (struct iw_handler_def *)&wl_iw_handler_def;
dhd_linux.c:4094:	dhd->pub.rxsz = DBUS_RX_BUFFER_SIZE_DHD(net);
dhd_linux.c:4096:	memcpy(net->dev_addr, temp_addr, ETHER_ADDR_LEN);
dhd_linux.c:4104:		net->name,
dhd_linux.c:4105:		MAC2STRDBG(net->dev_addr));
dhd_linux.c:4121:	net->open = NULL;
dhd_linux.c:4123:	net->netdev_ops = NULL;
dhd_linux.c:4136:		dhd = (dhd_info_t *)dhdp->info;
dhd_linux.c:4143:			if (dhd->pub.busstate != DHD_BUS_DOWN) {
dhd_linux.c:4145:				dhd_prot_stop(&dhd->pub);
dhd_linux.c:4148:				dhd_bus_stop(dhd->pub.bus, TRUE);
dhd_linux.c:4168:	dhd = (dhd_info_t *)dhdp->info;
dhd_linux.c:4172:	DHD_TRACE(("%s: Enter state 0x%x\n", __FUNCTION__, dhd->dhd_state));
dhd_linux.c:4174:	dhd->pub.up = 0;
dhd_linux.c:4175:	if (!(dhd->dhd_state & DHD_ATTACH_STATE_DONE)) {
dhd_linux.c:4182:	if (dhd->dhd_state & DHD_ATTACH_STATE_PROT_ATTACH) {
dhd_linux.c:4185:		if (dhdp->prot)
dhd_linux.c:4194:	if (dhd->dhd_state & DHD_ATTACH_STATE_EARLYSUSPEND_DONE) {
dhd_linux.c:4195:		if (dhd->early_suspend.suspend)
dhd_linux.c:4196:			unregister_early_suspend(&dhd->early_suspend);
dhd_linux.c:4201:	cancel_work_sync(&dhd->work_hang);
dhd_linux.c:4205:	if (dhd->dhd_state & DHD_ATTACH_STATE_WL_ATTACH) {
dhd_linux.c:4211:	if (dhd->thr_sysioc_ctl.thr_pid >= 0) {
dhd_linux.c:4212:		PROC_STOP(&dhd->thr_sysioc_ctl);
dhd_linux.c:4216:	if (dhd->dhd_state & DHD_ATTACH_STATE_ADD_IF) {
dhd_linux.c:4223:			if (dhd->iflist[i]) {
dhd_linux.c:4224:				dhd->iflist[i]->state = DHD_IF_DEL;
dhd_linux.c:4225:				dhd->iflist[i]->idx = i;
dhd_linux.c:4226:				dhd_op_if(dhd->iflist[i]);
dhd_linux.c:4232:		ifp = dhd->iflist[0];
dhd_linux.c:4234:		ASSERT(ifp->net);
dhd_linux.c:4235:		if (ifp && ifp->net) {
dhd_linux.c:4237:			if (ifp->net->open)
dhd_linux.c:4239:			if (ifp->net->netdev_ops == &dhd_ops_pri)
dhd_linux.c:4242:				unregister_netdev(ifp->net);
dhd_linux.c:4243:				free_netdev(ifp->net);
dhd_linux.c:4244:				ifp->net = NULL;
dhd_linux.c:4245:				MFREE(dhd->pub.osh, ifp, sizeof(*ifp));
dhd_linux.c:4246:				dhd->iflist[0] = NULL;
dhd_linux.c:4252:	flags = dhd_os_spin_lock(&dhd->pub);
dhd_linux.c:4253:	timer_valid = dhd->wd_timer_valid;
dhd_linux.c:4254:	dhd->wd_timer_valid = FALSE;
dhd_linux.c:4255:	dhd_os_spin_unlock(&dhd->pub, flags);
dhd_linux.c:4257:		del_timer_sync(&dhd->timer);
dhd_linux.c:4259:	if (dhd->dhd_state & DHD_ATTACH_STATE_THREADS_CREATED) {
dhd_linux.c:4261:		if (dhd->thr_wdt_ctl.thr_pid >= 0) {
dhd_linux.c:4262:			PROC_STOP(&dhd->thr_wdt_ctl);
dhd_linux.c:4265:		if (dhd->thr_dpc_ctl.thr_pid >= 0) {
dhd_linux.c:4266:			PROC_STOP(&dhd->thr_dpc_ctl);
dhd_linux.c:4270:		tasklet_kill(&dhd->tasklet);
dhd_linux.c:4274:	if (dhd->dhd_state & DHD_ATTACH_STATE_CFG80211) {
dhd_linux.c:4286:	if (dhd->dhd_state & DHD_ATTACH_STATE_WAKELOCKS_INIT) {
dhd_linux.c:4288:		dhd->wakelock_counter = 0;
dhd_linux.c:4289:		dhd->wakelock_wd_counter = 0;
dhd_linux.c:4290:		dhd->wakelock_rx_timeout_enable = 0;
dhd_linux.c:4291:		dhd->wakelock_ctrl_timeout_enable = 0;
dhd_linux.c:4292:		if (dhd->wl_wifi) {
dhd_linux.c:4293:			wake_lock_destroy(dhd->wl_wifi);
dhd_linux.c:4294:			MFREE(dhd->pub.osh, dhd->wl_wifi, sizeof(struct wake_lock));
dhd_linux.c:4295:			dhd->wl_wifi = NULL;
dhd_linux.c:4297:		if (dhd->wl_rxwake) {
dhd_linux.c:4298:			wake_lock_destroy(dhd->wl_rxwake);
dhd_linux.c:4299:			MFREE(dhd->pub.osh, dhd->wl_rxwake, sizeof(struct wake_lock));
dhd_linux.c:4300:			dhd->wl_rxwake = NULL;
dhd_linux.c:4302:		if (dhd->wl_ctrlwake) {
dhd_linux.c:4303:			wake_lock_destroy(dhd->wl_ctrlwake);
dhd_linux.c:4304:			MFREE(dhd->pub.osh, dhd->wl_ctrlwake, sizeof(struct wake_lock));
dhd_linux.c:4305:			dhd->wl_ctrlwake = NULL;
dhd_linux.c:4307:		if (dhd->wl_wdwake) {
dhd_linux.c:4308:			wake_lock_destroy(dhd->wl_wdwake);
dhd_linux.c:4309:			MFREE(dhd->pub.osh, dhd->wl_wdwake, sizeof(struct wake_lock));
dhd_linux.c:4310:			dhd->wl_wdwake = NULL;
dhd_linux.c:4325:		for (i = 0; i < ARRAYSIZE(dhdp->reorder_bufs); i++) {
dhd_linux.c:4326:			if (dhdp->reorder_bufs[i]) {
dhd_linux.c:4330:				ptr = dhdp->reorder_bufs[i];
dhd_linux.c:4332:				buf_size += ((ptr->max_idx + 1) * sizeof(void*));
dhd_linux.c:4334:					i, ptr->max_idx, buf_size));
dhd_linux.c:4336:				MFREE(dhdp->osh, dhdp->reorder_bufs[i], buf_size);
dhd_linux.c:4337:				dhdp->reorder_bufs[i] = NULL;
dhd_linux.c:4340:		dhd = (dhd_info_t *)dhdp->info;
dhd_linux.c:4342:			MFREE(dhd->pub.osh, dhd, sizeof(*dhd));
dhd_linux.c:4389:		return -EINVAL;
dhd_linux.c:4417:	} while (retry-- > 0);
dhd_linux.c:4421:		return -ENODEV;
dhd_linux.c:4455:		error = -ENODEV;
dhd_linux.c:4497:	dhd_info_t * dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:4500:		down(&dhd->proto_sem);
dhd_linux.c:4510:	dhd_info_t * dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:4513:		up(&dhd->proto_sem);
dhd_linux.c:4535:	dhd_info_t * dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:4545:	timeout = wait_event_timeout(dhd->ioctl_resp_wait, (*condition), timeout);
dhd_linux.c:4552:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:4554:	if (waitqueue_active(&dhd->ioctl_resp_wait)) {
dhd_linux.c:4555:		wake_up(&dhd->ioctl_resp_wait);
dhd_linux.c:4565:	dhd_info_t *dhd = (dhd_info_t *)pub->info;
dhd_linux.c:4578:	if (pub->busstate == DHD_BUS_DOWN) {
dhd_linux.c:4585:	if (!wdtick && dhd->wd_timer_valid == TRUE) {
dhd_linux.c:4586:		dhd->wd_timer_valid = FALSE;
dhd_linux.c:4589:		del_timer_sync(&dhd->timer);
dhd_linux.c:4591:		del_timer(&dhd->timer);
dhd_linux.c:4601:		mod_timer(&dhd->timer, jiffies + msecs_to_jiffies(dhd_watchdog_ms));
dhd_linux.c:4602:		dhd->wd_timer_valid = TRUE;
dhd_linux.c:4634:	rdlen = kernel_read(fp, fp->f_pos, buf, len);
dhd_linux.c:4636:		fp->f_pos += rdlen;
dhd_linux.c:4654:	dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:4657:	if (dhd->threads_only)
dhd_linux.c:4658:		down(&dhd->sdsem);
dhd_linux.c:4661:	spin_lock_bh(&dhd->sdlock);
dhd_linux.c:4669:	dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:4672:	if (dhd->threads_only)
dhd_linux.c:4673:		up(&dhd->sdsem);
dhd_linux.c:4676:	spin_unlock_bh(&dhd->sdlock);
dhd_linux.c:4684:	dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:4685:	spin_lock_bh(&dhd->txqlock);
dhd_linux.c:4693:	dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:4694:	spin_unlock_bh(&dhd->txqlock);
dhd_linux.c:4737:	if (!dhd->pub.up) {
dhd_linux.c:4741:	res = wl_iw_get_wireless_stats(dev, &dhd->iw.wstats);
dhd_linux.c:4744:		return &dhd->iw.wstats;
dhd_linux.c:4757:	bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, event, data);
dhd_linux.c:4762:	if (event->bsscfgidx == 0) {
dhd_linux.c:4767:	ASSERT(dhd->iflist[*ifidx] != NULL);
dhd_linux.c:4768:	ASSERT(dhd->iflist[*ifidx]->net != NULL);
dhd_linux.c:4770:		if (dhd->iflist[*ifidx]->net) {
dhd_linux.c:4771:		wl_iw_event(dhd->iflist[*ifidx]->net, event, *data);
dhd_linux.c:4777:	if ((ntoh32(event->event_type) == WLC_E_IF) &&
dhd_linux.c:4778:		(((dhd_if_event_t *)*data)->action == WLC_E_IF_ADD))
dhd_linux.c:4793:	ASSERT(dhd->iflist[*ifidx] != NULL);
dhd_linux.c:4794:	ASSERT(dhd->iflist[*ifidx]->net != NULL);
dhd_linux.c:4795:	if (dhd->iflist[*ifidx]->event2cfg80211 && dhd->iflist[*ifidx]->net) {
dhd_linux.c:4796:		wl_cfg80211_event(dhd->iflist[*ifidx]->net, event, *data);
dhd_linux.c:4807:	switch (ntoh32(event->event_type)) {
dhd_linux.c:4822:		len = ntoh32(event->datalen);
dhd_linux.c:4824:		dhd = dhdp->info;
dhd_linux.c:4825:		ifidx = dhd_ifname2idx(dhd, event->ifname);
dhd_linux.c:4827:		if ((p = PKTGET(dhdp->osh, pktlen, FALSE))) {
dhd_linux.c:4828:			ASSERT(ISALIGNED((uintptr)PKTDATA(dhdp->osh, p), sizeof(uint32)));
dhd_linux.c:4830:			msg = (bcm_event_t *) PKTDATA(dhdp->osh, p);
dhd_linux.c:4832:			bcopy(&dhdp->mac, &msg->eth.ether_dhost, ETHER_ADDR_LEN);
dhd_linux.c:4833:			bcopy(&dhdp->mac, &msg->eth.ether_shost, ETHER_ADDR_LEN);
dhd_linux.c:4834:			ETHER_TOGGLE_LOCALADDR(&msg->eth.ether_shost);
dhd_linux.c:4836:			msg->eth.ether_type = hton16(ETHER_TYPE_BRCM);
dhd_linux.c:4839:			msg->bcm_hdr.subtype = hton16(BCMILCP_SUBTYPE_VENDOR_LONG);
dhd_linux.c:4840:			msg->bcm_hdr.version = BCMILCP_BCM_SUBTYPEHDR_VERSION;
dhd_linux.c:4841:			bcopy(BRCM_OUI, &msg->bcm_hdr.oui[0], DOT11_OUI_LEN);
dhd_linux.c:4846:			msg->bcm_hdr.length = hton16(BCMILCP_BCM_SUBTYPEHDR_MINLENGTH +
dhd_linux.c:4848:			msg->bcm_hdr.usr_subtype = hton16(BCMILCP_BCM_SUBTYPE_EVENT);
dhd_linux.c:4850:			PKTSETLEN(dhdp->osh, p, (sizeof(bcm_event_t) + len + 2));
dhd_linux.c:4855:			p_bcm_event = &msg->event;
dhd_linux.c:4861:			msg->bcm_hdr.length  = hton16(sizeof(wl_event_msg_t) +
dhd_linux.c:4862:				ntoh16(msg->bcm_hdr.length));
dhd_linux.c:4863:			PKTSETLEN(dhdp->osh, p, (sizeof(bcm_event_t) + len + 2));
dhd_linux.c:4872:			skb = PKTTONATIVE(dhdp->osh, p);
dhd_linux.c:4873:			eth = skb->data;
dhd_linux.c:4874:			len = skb->len;
dhd_linux.c:4876:			ifp = dhd->iflist[ifidx];
dhd_linux.c:4878:			     ifp = dhd->iflist[0];
dhd_linux.c:4881:			skb->dev = ifp->net;
dhd_linux.c:4882:			skb->protocol = eth_type_trans(skb, skb->dev);
dhd_linux.c:4884:			skb->data = eth;
dhd_linux.c:4885:			skb->len = len;
dhd_linux.c:4913:	struct dhd_info *dhdinfo =  dhd->info;
dhd_linux.c:4922:	wait_event_timeout(dhdinfo->ctrl_wait, (*lockvar == FALSE), timeout);
dhd_linux.c:4931:	struct dhd_info *dhdinfo =  dhd->info;
dhd_linux.c:4932:	if (waitqueue_active(&dhdinfo->ctrl_wait))
dhd_linux.c:4933:		wake_up(&dhdinfo->ctrl_wait);
dhd_linux.c:4947:		if (dhd_wl_ioctl_cmd(&dhd->pub, WLC_DOWN, NULL, 0, TRUE, 0) < 0) {
dhd_linux.c:4952:	ret = dhd_bus_devreset(&dhd->pub, flag);
dhd_linux.c:4967:		ret = dhd->pub.suspend_disable_flag;
dhd_linux.c:4968:		dhd->pub.suspend_disable_flag = val;
dhd_linux.c:4980:		ret = dhd_set_suspend(val, &dhd->pub);
dhd_linux.c:4996:		dhd->pub.suspend_bcn_li_dtim = val;
dhd_linux.c:5012:	if (num >= dhd->pub.pktfilter_count)
dhd_linux.c:5013:		return -EINVAL;
dhd_linux.c:5026:			return -EINVAL;
dhd_linux.c:5029:	dhd->pub.pktfilter[num] = filterp;
dhd_linux.c:5030:	dhd_pktfilter_offload_set(&dhd->pub, dhd->pub.pktfilter[num]);
dhd_linux.c:5041:	/* Packet filtering is set only if we still in early-suspend and
dhd_linux.c:5043:	 * We can always turn it OFF in case of early-suspend, but we turn it
dhd_linux.c:5046:	if (dhdp && dhdp->up) {
dhd_linux.c:5047:		if (dhdp->in_suspend) {
dhd_linux.c:5048:			if (!val || (val && !dhdp->suspend_disable_flag))
dhd_linux.c:5060:	return dhd_os_enable_packet_filter(&dhd->pub, val);
dhd_linux.c:5068:	return dhd_preinit_ioctls(&dhd->pub);
dhd_linux.c:5078:	return (dhd_pno_clean(&dhd->pub));
dhd_linux.c:5088:	return (dhd_pno_enable(&dhd->pub, pfn_enabled));
dhd_linux.c:5099:	return (dhd_pno_set(&dhd->pub, ssids_local, nssid, scan_fr, pno_repeat, pno_freq_expo_max));
dhd_linux.c:5108:	return (dhd_pno_get_status(&dhd->pub));
dhd_linux.c:5120:	dev = dhd->iflist[0]->net;
dhd_linux.c:5139:		if (!dhdp->hang_was_sent) {
dhd_linux.c:5140:			dhdp->hang_was_sent = 1;
dhd_linux.c:5141:			schedule_work(&dhdp->info->work_hang);
dhd_linux.c:5154:		ret = dhd_os_send_hang_message(&dhd->pub);
dhd_linux.c:5166:	if (dhd && dhd->pub.up) {
dhd_linux.c:5167:		memcpy(&dhd->pub.dhd_cspec, cspec, sizeof(wl_country_t));
dhd_linux.c:5177:	if (dhd && dhd->pub.up) {
dhd_linux.c:5200:		mutex_lock(&dhd->dhd_net_if_mutex);
dhd_linux.c:5208:		mutex_unlock(&dhd->dhd_net_if_mutex);
dhd_linux.c:5215:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5217:		mutex_lock(&dhd->dhd_suspend_mutex);
dhd_linux.c:5224:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5226:		mutex_unlock(&dhd->dhd_suspend_mutex);
dhd_linux.c:5232:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5236:		spin_lock_irqsave(&dhd->dhd_lock, flags);
dhd_linux.c:5243:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5246:		spin_unlock_irqrestore(&dhd->dhd_lock, flags);
dhd_linux.c:5252:	return (atomic_read(&dhd->pend_8021x_cnt));
dhd_linux.c:5270:			ntimes--;
dhd_linux.c:5296:		ret = -1;
dhd_linux.c:5301:	fp->f_op->write(fp, buf, size, &pos);
dhd_linux.c:5305:	MFREE(dhd->osh, buf, size);
dhd_linux.c:5308:		filp_close(fp, current->files);
dhd_linux.c:5318:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5323:		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5324:		ret = dhd->wakelock_rx_timeout_enable > dhd->wakelock_ctrl_timeout_enable ?
dhd_linux.c:5325:			dhd->wakelock_rx_timeout_enable : dhd->wakelock_ctrl_timeout_enable;
dhd_linux.c:5327:		if (dhd->wakelock_rx_timeout_enable)
dhd_linux.c:5328:			wake_lock_timeout(dhd->wl_rxwake,
dhd_linux.c:5329:				msecs_to_jiffies(dhd->wakelock_rx_timeout_enable));
dhd_linux.c:5330:		if (dhd->wakelock_ctrl_timeout_enable)
dhd_linux.c:5331:			wake_lock_timeout(dhd->wl_ctrlwake,
dhd_linux.c:5332:				msecs_to_jiffies(dhd->wakelock_ctrl_timeout_enable));
dhd_linux.c:5334:		dhd->wakelock_rx_timeout_enable = 0;
dhd_linux.c:5335:		dhd->wakelock_ctrl_timeout_enable = 0;
dhd_linux.c:5336:		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5347:		ret = dhd_os_wake_lock_timeout(&dhd->pub);
dhd_linux.c:5353:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5357:		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5358:		if (val > dhd->wakelock_rx_timeout_enable)
dhd_linux.c:5359:			dhd->wakelock_rx_timeout_enable = val;
dhd_linux.c:5360:		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5367:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5371:		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5372:		if (val > dhd->wakelock_ctrl_timeout_enable)
dhd_linux.c:5373:			dhd->wakelock_ctrl_timeout_enable = val;
dhd_linux.c:5374:		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5385:		ret = dhd_os_wake_lock_rx_timeout_enable(&dhd->pub, val);
dhd_linux.c:5395:		ret = dhd_os_wake_lock_ctrl_timeout_enable(&dhd->pub, val);
dhd_linux.c:5401:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5406:		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5408:		if (!dhd->wakelock_counter)
dhd_linux.c:5409:			wake_lock(dhd->wl_wifi);
dhd_linux.c:5411:		dhd->wakelock_counter++;
dhd_linux.c:5412:		ret = dhd->wakelock_counter;
dhd_linux.c:5413:		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5424:		ret = dhd_os_wake_lock(&dhd->pub);
dhd_linux.c:5430:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5436:		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5437:		if (dhd->wakelock_counter) {
dhd_linux.c:5438:			dhd->wakelock_counter--;
dhd_linux.c:5440:			if (!dhd->wakelock_counter)
dhd_linux.c:5441:				wake_unlock(dhd->wl_wifi);
dhd_linux.c:5443:			ret = dhd->wakelock_counter;
dhd_linux.c:5445:		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5458:	dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5461:	if (dhd && (wake_lock_active(dhd->wl_wifi) ||
dhd_linux.c:5462:		(wake_lock_active(dhd->wl_wdwake))))
dhd_linux.c:5474:		ret = dhd_os_wake_unlock(&dhd->pub);
dhd_linux.c:5480:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5485:		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5488:		if (!dhd->wakelock_wd_counter) {
dhd_linux.c:5489:			if (dhd->wl_wdwake)
dhd_linux.c:5490:				wake_lock(dhd->wl_wdwake);
dhd_linux.c:5492:				spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5497:		dhd->wakelock_wd_counter++;
dhd_linux.c:5498:		ret = dhd->wakelock_wd_counter;
dhd_linux.c:5499:		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5506:	dhd_info_t *dhd = (dhd_info_t *)(pub->info);
dhd_linux.c:5511:		spin_lock_irqsave(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5512:		if (dhd->wakelock_wd_counter) {
dhd_linux.c:5513:			dhd->wakelock_wd_counter = 0;
dhd_linux.c:5515:			wake_unlock(dhd->wl_wdwake);
dhd_linux.c:5518:		spin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);
dhd_linux.c:5533:	return pub->up;
dhd_linux.c:5547:	i = snprintf(&info_string[i], sizeof(info_string) - i,
dhd_linux.c:5560:		return -EINVAL;
dhd_linux.c:5567:		return -ENODEV;
dhd_linux.c:5570:	DHD_OS_WAKE_LOCK(&dhd->pub);
dhd_linux.c:5571:	ret = dhd_wl_ioctl(&dhd->pub, ifidx, ioc, ioc->buf, ioc->len);
dhd_linux.c:5572:	dhd_check_hang(net, &dhd->pub, ret);
dhd_linux.c:5573:	DHD_OS_WAKE_UNLOCK(&dhd->pub);
dhd_linux.c:5597:	dhd_os_wlfc_block(&dhd->pub);
dhd_linux.c:5598:	if (dhd->pub.wlfc_state == NULL) {
dhd_linux.c:5599:		dhd_os_wlfc_unblock(&dhd->pub);
dhd_linux.c:5603:	status = dhd_wlfc_interface_entry_update(dhd->pub.wlfc_state, action, ifid, iftype, ea);
dhd_linux.c:5604:	dhd_os_wlfc_unblock(&dhd->pub);
dhd_linux.c:5612:	dhd_os_wlfc_block(&dhd->pub);
dhd_linux.c:5613:	if (dhd->pub.wlfc_state == NULL) {
dhd_linux.c:5614:		dhd_os_wlfc_unblock(&dhd->pub);
dhd_linux.c:5618:	status = dhd_wlfc_FIFOcreditmap_update(dhd->pub.wlfc_state, event_data);
dhd_linux.c:5619:	dhd_os_wlfc_unblock(&dhd->pub);
dhd_linux.c:5627:	dhd_os_wlfc_block(&dhd->pub);
dhd_linux.c:5628:	status =  dhd_wlfc_enable(&dhd->pub);
dhd_linux.c:5629:	dhd_os_wlfc_unblock(&dhd->pub);
dhd_linux.c:5653:	file->private_data = inode->i_private;
dhd_linux.c:5667:		return -EINVAL;
dhd_linux.c:5670:	if (count > g_dbgfs.size - pos)
dhd_linux.c:5671:		count = g_dbgfs.size - pos;
dhd_linux.c:5674:	tmp = dhd_readregl(g_dbgfs.dhdp->bus, file->f_pos & (~3));
dhd_linux.c:5678:		return -EFAULT;
dhd_linux.c:5680:	count -= ret;
dhd_linux.c:5696:		return -EINVAL;
dhd_linux.c:5699:	if (count > g_dbgfs.size - pos)
dhd_linux.c:5700:		count = g_dbgfs.size - pos;
dhd_linux.c:5704:		return -EFAULT;
dhd_linux.c:5707:	dhd_writeregl(g_dbgfs.dhdp->bus, file->f_pos & (~3), buf);
dhd_linux.c:5716:	loff_t pos = -1;
dhd_linux.c:5723:			pos = file->f_pos + off;
dhd_linux.c:5726:			pos = g_dbgfs.size - off;
dhd_linux.c:5728:	return (pos < 0 || pos > g_dbgfs.size) ? -EINVAL : (file->f_pos = pos);
dhd_linux.c:5780:	dhd_info_t *dhd = (dhd_info_t *)(dhdp->info);
dhd_linux.c:5789:	p1 = (char*) PKTDATA(dhdp->osh, pktbuf);
dhd_linux.c:5791:	if (PKTLEN(dhdp->osh, pktbuf) > HTSF_MINLEN) {
dhd_linux.c:5805:		memset(skb->data + 44, 0, 2); /* clear checksum */
dhd_linux.c:5806:		memcpy(skb->data+82, &oldmagic, 2);
dhd_linux.c:5807:		memcpy(skb->data+84, &htsf, 4);
dhd_linux.c:5817:		memcpy(skb->data + HTSF_HOSTOFFSET, &ts, sizeof(ts));
dhd_linux.c:5824:	for (i = 0; i < (NUMBIN-2); i++) {
dhd_linux.c:5826:		printf("%d ",  his->bin[i]);
dhd_linux.c:5827:		pktcnt += his->bin[i];
dhd_linux.c:5829:	printf(" max: %d TotPkt: %d neg: %d [%s]\n", his->bin[NUMBIN-2], pktcnt,
dhd_linux.c:5830:		his->bin[NUMBIN-1], s);
dhd_linux.c:5839:		histo->bin[NUMBIN-1]++;
dhd_linux.c:5842:	if (value > histo->bin[NUMBIN-2])  /* store the max value  */
dhd_linux.c:5843:		histo->bin[NUMBIN-2] = value;
dhd_linux.c:5845:	for (i = 0; i < (NUMBIN-2); i++) {
dhd_linux.c:5848:			histo->bin[i]++;
dhd_linux.c:5852:	histo->bin[NUMBIN-3]++;
dhd_linux.c:5858:	dhd_info_t *dhd = (dhd_info_t *)dhdp->info;
dhd_linux.c:5866:	skb = PKTTONATIVE(dhdp->osh, pktbuf);
dhd_linux.c:5867:	p1 = (char*)PKTDATA(dhdp->osh, pktbuf);
dhd_linux.c:5871:		htsf_ts = (htsfts_t*) (p1 + HTSF_HOSTOFFSET - 4);
dhd_linux.c:5876:	if (htsf_ts->magic == HTSFMAGIC) {
dhd_linux.c:5877:		htsf_ts->tE0 = dhd_get_htsf(dhd, 0);
dhd_linux.c:5878:		htsf_ts->cE0 = get_cycles();
dhd_linux.c:5885:		memcpy(skb->data+92, &htsf, sizeof(uint32));
dhd_linux.c:5887:		memcpy(&ts[tsidx].t1, skb->data+80, 16);
dhd_linux.c:5889:		d1 = ts[tsidx].t2 - ts[tsidx].t1;
dhd_linux.c:5890:		d2 = ts[tsidx].t3 - ts[tsidx].t2;
dhd_linux.c:5891:		d3 = ts[tsidx].t4 - ts[tsidx].t3;
dhd_linux.c:5892:		end2end = ts[tsidx].t4 - ts[tsidx].t1;
dhd_linux.c:5918:	if (cur_cycle >  dhd->htsf.last_cycle)
dhd_linux.c:5919:		delta = cur_cycle -  dhd->htsf.last_cycle;
dhd_linux.c:5921:		delta = cur_cycle + (0xFFFFFFFF -  dhd->htsf.last_cycle);
dhd_linux.c:5926:	if (dhd->htsf.coef) {
dhd_linux.c:5928:	        factor = (dhd->htsf.coef*10 + dhd->htsf.coefdec1);
dhd_linux.c:5931:		delta_us  = (baseval -  (((baseval - baseval2) * dhd->htsf.coefdec2)) / 10);
dhd_linux.c:5932:		htsf = (delta_us << 4) +  dhd->htsf.last_tsf + HTSF_BUS_DELAY;
dhd_linux.c:5935:		DHD_ERROR(("-------dhd->htsf.coef = 0 -------\n"));
dhd_linux.c:5946:	printf("T1       T2       T3       T4           d1  d2   t4-t1     i    \n");
dhd_linux.c:5948:		d1 = ts[i].t2 - ts[i].t1;
dhd_linux.c:5949:		d2 = ts[i].t3 - ts[i].t2;
dhd_linux.c:5950:		d3 = ts[i].t4 - ts[i].t3;
dhd_linux.c:5951:		d4 = ts[i].t4 - ts[i].t1;
dhd_linux.c:5952:		d5 = ts[max].t4-ts[max].t1;
dhd_linux.c:5966:	maxdelayts.t2 - maxdelayts.t1,
dhd_linux.c:5967:	maxdelayts.t3 - maxdelayts.t2,
dhd_linux.c:5968:	maxdelayts.t4 - maxdelayts.t3,
dhd_linux.c:5969:	maxdelayts.t4 - maxdelayts.t1);
dhd_linux.c:5994:	strncpy(buf, "tsf", sizeof(buf) - 1);
dhd_linux.c:5995:	buf[sizeof(buf) - 1] = '\0';
dhd_linux.c:5997:	if ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {
dhd_linux.c:5998:		if (ret == -EIO) {
dhd_linux.c:6000:				dhd_ifname(&dhd->pub, ifidx)));
dhd_linux.c:6001:			return -EOPNOTSUPP;
dhd_linux.c:6009:		tsf_buf.high, tsf_buf.low, s2, dhd->htsf.coef, dhd->htsf.coefdec1,
dhd_linux.c:6010:		dhd->htsf.coefdec2, s2-tsf_buf.low);
dhd_linux.c:6011:	printf("lasttsf=%08X lastcycle=%08X\n", dhd->htsf.last_tsf, dhd->htsf.last_cycle);
dhd_linux.c:6031:		cyc_delta = cur_cycle - prev_cycle;
dhd_linux.c:6035:		cyc_delta = cur_cycle + (0xFFFFFFFF - prev_cycle);
dhd_linux.c:6045:		DHD_INFO((" ---- 0 TSF, do not update, return\n"));
dhd_linux.c:6050:		tsf_delta = (cur_tsf.low - prev_tsf.low);
dhd_linux.c:6052:		DHD_INFO((" ---- tsf low is smaller cur_tsf= %08X, prev_tsf=%08X, \n",
dhd_linux.c:6055:			tsf_delta = cur_tsf.low + (0xFFFFFFFF - prev_tsf.low);
dhd_linux.c:6056:			DHD_INFO((" ---- Wrap around tsf coutner  adjusted TSF=%08X\n", tsf_delta));
dhd_linux.c:6064:		tmp  = 	(cyc_delta - (hfactor * tsf_delta))*10;
dhd_linux.c:6066:		dec2 =  ((tmp - dec1*tsf_delta)*10) / tsf_delta;
dhd_linux.c:6067:		tmp  = 	(tmp   - (dec1*tsf_delta))*10;
dhd_linux.c:6068:		dec3 =  ((tmp - dec2*tsf_delta)*10) / tsf_delta;
dhd_linux.c:6088:		dhd->htsf.coef = hfactor;
dhd_linux.c:6089:		dhd->htsf.last_cycle = cur_cycle;
dhd_linux.c:6090:		dhd->htsf.last_tsf = cur_tsf.low;
dhd_linux.c:6091:		dhd->htsf.coefdec1 = dec1;
dhd_linux.c:6092:		dhd->htsf.coefdec2 = dec2;
dhd_linux_sched.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_linux_sched.c:24: * $Id: dhd_linux_sched.c 291086 2011-10-21 01:17:24Z $
dhd_proto.h:2: * Header file describing the internal (inter-module) DHD interfaces.
dhd_proto.h:7: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_proto.h:27: * $Id: dhd_proto.h 343390 2012-07-06 22:34:19Z $
dhd_proto.h:62:/* Add any protocol-specific data header.
dhd_proto.h:67:/* Remove any protocol-specific data header. */
dhd_proto.h:76:/* Check for and handle local prot-specific iovar commands */
dhd_proto.h:101: * For version-string expansion *
dhd_sdio.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
dhd_sdio.c:24: * $Id: dhd_sdio.c 373330 2012-12-07 04:46:17Z $
dhd_sdio.c:74:#define FCHI		(QLEN - 10)
dhd_sdio.c:147:#define PKTFREE2()		if ((bus->bus != SPI_BUS) || bus->usebufpool) \
dhd_sdio.c:148:					PKTFREE(bus->dhd->osh, pkt, FALSE);
dhd_sdio.c:175:#define	REMAP_ENAB(bus)			((bus)->remap)
dhd_sdio.c:176:#define	REMAP_ISADDR(bus, a)		(((a) >= ((bus)->orig_ramsize)) && ((a) < ((bus)->ramsize)))
dhd_sdio.c:177:#define	KSO_ENAB(bus)			((bus)->kso)
dhd_sdio.c:178:#define	SR_ENAB(bus)			((bus)->_srenab)
dhd_sdio.c:179:#define	SLPAUTO_ENAB(bus)		((SR_ENAB(bus)) && ((bus)->_slpauto))
dhd_sdio.c:187:#define	OOB_WAKEUP_ENAB(bus)		((bus)->_oobwakeup)
dhd_sdio.c:202:	uint32		sbaddr;			/* Current SB window pointer (-1, invalid) */
dhd_sdio.c:216:	bool		fcstate;		/* State of dongle flow-control */
dhd_sdio.c:226:	struct pktq	txq;			/* Queue length used for flow-control */
dhd_sdio.c:282:	/* Field to decide if rx of control frames happen in rxbuf or lb-pool */
dhd_sdio.c:329:	uint		fc_rcvd;		/* Number of flow-control events received */
dhd_sdio.c:330:	uint		fc_xoff;		/* Number which turned on flow-control */
dhd_sdio.c:331:	uint		fc_xon;			/* Number which turned off flow-control */
dhd_sdio.c:346:					 * Remap region not DMA-able
dhd_sdio.c:361:	uint8		glom_mode;	/* Glom mode - 0-copy mode, 1 - Multi-descriptor mode */
dhd_sdio.c:411:#define HDATLEN (firstread - (SDPCM_HDRLEN))
dhd_sdio.c:486:		datalign = ROUNDUP(datalign, (align)) - datalign;	\
dhd_sdio.c:503:	(((uint8)(bus->tx_max - bus->tx_seq) > 1) && \
dhd_sdio.c:504:	(((uint8)(bus->tx_max - bus->tx_seq) & 0x80) == 0))
dhd_sdio.c:508:	(((uint8)(bus->tx_max - bus->tx_seq) != 0) && \
dhd_sdio.c:509:	(((uint8)(bus->tx_max - bus->tx_seq) & 0x80) == 0))
dhd_sdio.c:513:	((uint8)(bus->tx_max - bus->tx_seq) - 1)
dhd_sdio.c:521:		regvar = R_REG(bus->dhd->osh, regaddr); \
dhd_sdio.c:522:	} while (bcmsdh_regfail(bus->sdh) && (++retryvar <= retry_limit)); \
dhd_sdio.c:524:		bus->regfails += (retryvar-1); \
dhd_sdio.c:537:		W_REG(bus->dhd->osh, regaddr, regval); \
dhd_sdio.c:538:	} while (bcmsdh_regfail(bus->sdh) && (++retryvar <= retry_limit)); \
dhd_sdio.c:540:		bus->regfails += (retryvar-1); \
dhd_sdio.c:549:		bus->idlecount = 0; \
dhd_sdio.c:550:		if ((bus)->sleeping) \
dhd_sdio.c:577:	((bus->rxint_mode == SDIO_DEVICE_HMB_RXINT) ? I_HMB_FRAME_IND : I_XMTDATA_AVAIL)
dhd_sdio.c:648:		(dhd_dongle_memsize < (int32)bus->orig_ramsize))
dhd_sdio.c:649:		bus->ramsize = dhd_dongle_memsize;
dhd_sdio.c:656:	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRLOW,
dhd_sdio.c:659:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRMID,
dhd_sdio.c:662:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRHIGH,
dhd_sdio.c:674:	bcmsdh_gpioouten(bus->sdh, GPIO_DEV_WAKEUP);
dhd_sdio.c:680:	bcmsdh_reg_write(bus->sdh, addr, 4, 2);
dhd_sdio.c:681:	val = bcmsdh_reg_read(bus->sdh, data, 4);
dhd_sdio.c:683:	bcmsdh_reg_write(bus->sdh, data, 4, val);
dhd_sdio.c:685:	bus->_oobwakeup = TRUE;
dhd_sdio.c:699:	if (bus->sih->chip == BCM4324_CHIP_ID) {
dhd_sdio.c:702:			bcmsdh_reg_write(bus->sdh, addr, 4, 3);
dhd_sdio.c:703:			core_capext = bcmsdh_reg_read(bus->sdh, data, 4);
dhd_sdio.c:704:	} else if (bus->sih->chip == BCM4330_CHIP_ID) {
dhd_sdio.c:706:	} else if (bus->sih->chip == BCM4335_CHIP_ID) {
dhd_sdio.c:709:			core_capext = bcmsdh_reg_read(bus->sdh, CORE_CAPEXT_ADDR, 4);
dhd_sdio.c:715:	if (bus->sih->chip == BCM4324_CHIP_ID) {
dhd_sdio.c:717:		min = bcmsdh_reg_read(bus->sdh, MIN_RSRC_ADDR, 4);
dhd_sdio.c:720:	} else if (bus->sih->chip == BCM4335_CHIP_ID) {
dhd_sdio.c:724:		bcmsdh_reg_write(bus->sdh, addr, 4, CC_PMUCC3);
dhd_sdio.c:725:		enabval = bcmsdh_reg_read(bus->sdh, data, 4);
dhd_sdio.c:730:		data = bcmsdh_reg_read(bus->sdh,
dhd_sdio.c:743:	bcmsdh_gpio_init(bus->sdh);
dhd_sdio.c:759:	if ((bus->sih->chip == BCM4334_CHIP_ID) && (bus->sih->chiprev == 2))
dhd_sdio.c:762:	val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_WAKEUPCTRL, NULL);
dhd_sdio.c:764:	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_WAKEUPCTRL,
dhd_sdio.c:766:	val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_WAKEUPCTRL, NULL);
dhd_sdio.c:772:	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1,
dhd_sdio.c:775:	bus->_slpauto = dhd_slpauto ? TRUE : FALSE;
dhd_sdio.c:777:	bus->_srenab = TRUE;
dhd_sdio.c:793:	bus->kso = TRUE;
dhd_sdio.c:799:	val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, NULL);
dhd_sdio.c:802:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, val, &err);
dhd_sdio.c:823:	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, wr_val, &err);
dhd_sdio.c:838:		rd_val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, &err);
dhd_sdio.c:845:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, wr_val, &err);
dhd_sdio.c:873:			bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1,
dhd_sdio.c:880:		if (bus->clkstate == CLK_NONE) {
dhd_sdio.c:885:		/* Double-write to be safe in case transition of AOS */
dhd_sdio.c:890:		/* Wait for device ready during transition to wake-up */
dhd_sdio.c:900:	bus->kso = on;
dhd_sdio.c:912:	val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, &err);
dhd_sdio.c:922:	return bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_BRCM_CARDCAP, NULL);
dhd_sdio.c:930:	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_BRCM_CARDCAP, cap, &err);
dhd_sdio.c:948:		 * so we can wake-up with clk request already set
dhd_sdio.c:954:			val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
dhd_sdio.c:960:				bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
dhd_sdio.c:963:					bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1,
dhd_sdio.c:969:			bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1,
dhd_sdio.c:972:		err = bcmsdh_sleep(bus->sdh, TRUE);
dhd_sdio.c:976:			err = bcmsdh_gpioout(bus->sdh, GPIO_DEV_WAKEUP, FALSE);  /* GPIO_1 is off */
dhd_sdio.c:981:		if (bus->clkstate == CLK_NONE) {
dhd_sdio.c:986:		if ((bus->sih->chip == BCM4334_CHIP_ID) && (bus->sih->chiprev == 2)) {
dhd_sdio.c:987:			SPINWAIT((bcmsdh_gpioin(bus->sdh, GPIO_DEV_SRSTATE) != TRUE),
dhd_sdio.c:990:			if (bcmsdh_gpioin(bus->sdh, GPIO_DEV_SRSTATE) == FALSE) {
dhd_sdio.c:995:		err = bcmsdh_sleep(bus->sdh, FALSE);
dhd_sdio.c:1001:			err = bcmsdh_sleep(bus->sdh, TRUE);
dhd_sdio.c:1003:			err = bcmsdh_sleep(bus->sdh, FALSE);
dhd_sdio.c:1010:				err = bcmsdh_sleep(bus->sdh, TRUE);
dhd_sdio.c:1012:				err = bcmsdh_sleep(bus->sdh, FALSE);
dhd_sdio.c:1015:					DHD_ERROR(("%s: FATAL: Device non-response!\n",
dhd_sdio.c:1023:			err = bcmsdh_gpioout(bus->sdh, GPIO_DEV_WAKEUP, TRUE);  /* GPIO_1 is on */
dhd_sdio.c:1040:			/* Wait for device ready during transition to wake-up */
dhd_sdio.c:1053:			SPINWAIT((((csr = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1,
dhd_sdio.c:1062:		bus->kso = on ? FALSE : TRUE;
dhd_sdio.c:1066:			bus->kso = TRUE;
dhd_sdio.c:1088:	sdh = bus->sdh;
dhd_sdio.c:1095:		bus->clkstate = (on ? CLK_AVAIL : CLK_SDONLY);
dhd_sdio.c:1101:		clkreq = bus->alp_only ? SBSDIO_ALP_AVAIL_REQ : SBSDIO_HT_AVAIL_REQ;
dhd_sdio.c:1114:				dhd_os_send_hang_message(bus->dhd);
dhd_sdio.c:1123:		    ((bus->sih->buscoretype == PCMCIA_CORE_ID) && (bus->sih->buscorerev == 9))) {
dhd_sdio.c:1125:			R_SDREG(dummy, &bus->regs->clockctlstatus, retries);
dhd_sdio.c:1137:		if (!SBSDIO_CLKAV(clkctl, bus->alp_only) && pendok) {
dhd_sdio.c:1138:			/* Allow only clock-available interrupt */
dhd_sdio.c:1149:			bus->clkstate = CLK_PENDING;
dhd_sdio.c:1151:		} else if (bus->clkstate == CLK_PENDING) {
dhd_sdio.c:1152:			/* Cancel CA-only interrupt filter */
dhd_sdio.c:1159:		if (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
dhd_sdio.c:1163:			          !SBSDIO_CLKAV(clkctl, bus->alp_only)), PMU_MAX_TRANSITION_DLY);
dhd_sdio.c:1169:		if (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {
dhd_sdio.c:1176:		bus->clkstate = CLK_AVAIL;
dhd_sdio.c:1180:		if (bus->alp_only == TRUE) {
dhd_sdio.c:1193:		bus->activity = TRUE;
dhd_sdio.c:1195:		bus->idlecount = 0;
dhd_sdio.c:1199:		if (bus->clkstate == CLK_PENDING) {
dhd_sdio.c:1200:			/* Cancel CA-only interrupt filter */
dhd_sdio.c:1206:		bus->clkstate = CLK_SDONLY;
dhd_sdio.c:1230:		if (bus->idleclock == DHD_IDLE_STOP) {
dhd_sdio.c:1233:			err = bcmsdh_iovar_op(bus->sdh, "sd_clock", NULL, 0,
dhd_sdio.c:1241:			iovalue = bus->sd_mode;
dhd_sdio.c:1242:			err = bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL, 0,
dhd_sdio.c:1249:		} else if (bus->idleclock != DHD_IDLE_ACTIVE) {
dhd_sdio.c:1251:			iovalue = bus->sd_divisor;
dhd_sdio.c:1252:			err = bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
dhd_sdio.c:1260:		bus->clkstate = CLK_SDONLY;
dhd_sdio.c:1263:		if ((bus->sd_divisor == -1) || (bus->sd_mode == -1)) {
dhd_sdio.c:1265:			           __FUNCTION__, bus->sd_divisor, bus->sd_mode));
dhd_sdio.c:1268:		if (bus->idleclock == DHD_IDLE_STOP) {
dhd_sdio.c:1272:				err = bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL, 0,
dhd_sdio.c:1282:			err = bcmsdh_iovar_op(bus->sdh, "sd_clock", NULL, 0,
dhd_sdio.c:1289:		} else if (bus->idleclock != DHD_IDLE_ACTIVE) {
dhd_sdio.c:1291:			iovalue = bus->idleclock;
dhd_sdio.c:1292:			err = bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
dhd_sdio.c:1300:		bus->clkstate = CLK_NONE;
dhd_sdio.c:1312:	uint oldstate = bus->clkstate;
dhd_sdio.c:1318:	if (bus->clkstate == target) {
dhd_sdio.c:1320:			dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
dhd_sdio.c:1321:			bus->activity = TRUE;
dhd_sdio.c:1323:			bus->idlecount = 0;
dhd_sdio.c:1332:		if (bus->clkstate == CLK_NONE)
dhd_sdio.c:1337:			dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
dhd_sdio.c:1338:		bus->activity = TRUE;
dhd_sdio.c:1340:			bus->idlecount = 0;
dhd_sdio.c:1347:		if (bus->clkstate == CLK_NONE)
dhd_sdio.c:1349:		else if (bus->clkstate == CLK_AVAIL)
dhd_sdio.c:1352:			DHD_ERROR(("dhdsdio_clkctl: request for %d -> %d\n",
dhd_sdio.c:1353:			           bus->clkstate, target));
dhd_sdio.c:1355:			dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
dhd_sdio.c:1361:		if (bus->clkstate == CLK_AVAIL)
dhd_sdio.c:1368:		if (bus->poll == 0)
dhd_sdio.c:1369:			dhd_os_wd_timer(bus->dhd, 0);
dhd_sdio.c:1373:	DHD_INFO(("dhdsdio_clkctl: %d -> %d\n", oldstate, bus->clkstate));
dhd_sdio.c:1383:	bcmsdh_info_t *sdh = bus->sdh;
dhd_sdio.c:1384:	sdpcmd_regs_t *regs = bus->regs;
dhd_sdio.c:1389:	          (bus->sleeping ? "SLEEP" : "WAKE")));
dhd_sdio.c:1392:	if (sleep == bus->sleeping)
dhd_sdio.c:1398:		if (bus->dpc_sched || bus->rxskip || pktq_len(&bus->txq))
dhd_sdio.c:1404:			bcmsdh_intr_disable(bus->sdh);
dhd_sdio.c:1410:			W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
dhd_sdio.c:1421:			if (bus->sih->chip != BCM4329_CHIP_ID &&
dhd_sdio.c:1422:				bus->sih->chip != BCM4319_CHIP_ID) {
dhd_sdio.c:1434:		bus->sleeping = TRUE;
dhd_sdio.c:1450:			W_SDREG(0, &regs->tosbmailboxdata, retries);
dhd_sdio.c:1452:				W_SDREG(SMB_DEV_INT, &regs->tosbmailbox, retries);
dhd_sdio.c:1461:			if (bus->intr && (bus->dhd->busstate == DHD_BUS_DATA)) {
dhd_sdio.c:1462:				bus->intdis = FALSE;
dhd_sdio.c:1463:				bcmsdh_intr_enable(bus->sdh);
dhd_sdio.c:1471:			bus->sleeping = FALSE;
dhd_sdio.c:1483:	bcmsdh_enable_hw_oob_intr(bus->sdh, enable);
dhd_sdio.c:1485:	sdpcmd_regs_t *regs = bus->regs;
dhd_sdio.c:1492:		W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
dhd_sdio.c:1498:		W_SDREG(0, &regs->tosbmailboxdata, retries);
dhd_sdio.c:1500:			W_SDREG(SMB_DEV_INT, &regs->tosbmailbox, retries);
dhd_sdio.c:1535:	sdh = bus->sdh;
dhd_sdio.c:1536:	osh = bus->dhd->osh;
dhd_sdio.c:1538:	if (bus->dhd->dongle_reset) {
dhd_sdio.c:1549:		if (htsf_ts->magic == HTSFMAGIC) {
dhd_sdio.c:1550:			htsf_ts->c20 = get_cycles();
dhd_sdio.c:1551:			htsf_ts->t20 = dhd_get_htsf(bus->dhd->info, 0);
dhd_sdio.c:1561:			bus->dhd->tx_realloc++;
dhd_sdio.c:1564:				DHD_ERROR(("%s: couldn't allocate new %d-byte packet\n",
dhd_sdio.c:1596:	if (bus->glom_enable) {
dhd_sdio.c:1601:			((bus->tx_seq + bus->glom_cnt) % SDPCM_SEQUENCE_WRAP) |
dhd_sdio.c:1607:			if (forcealign && (len & (ALIGNMENT - 1)))
dhd_sdio.c:1610:			/* 2byte frame length, 1byte-, 1byte frame flag,
dhd_sdio.c:1611:			 * 2byte-hdrlength, 2byte padlenght
dhd_sdio.c:1613:			hwheader1 = (act_len - SDPCM_FRAMETAG_LEN) | (0 << 24);
dhd_sdio.c:1614:			hwheader2 = (len - act_len) << 16;
dhd_sdio.c:1620:			bus->glom_pkt_arr[bus->glom_cnt] = pkt;
dhd_sdio.c:1621:			bus->glom_total_len += len;
dhd_sdio.c:1622:			bus->glom_cnt++;
dhd_sdio.c:1626:				if (bus->roundup && bus->blocksize &&
dhd_sdio.c:1627:					((bus->glom_total_len + len) > bus->blocksize)) {
dhd_sdio.c:1628:					uint16 pad2 = bus->blocksize -
dhd_sdio.c:1629:						((bus->glom_total_len + len) % bus->blocksize);
dhd_sdio.c:1630:					if ((pad2 <= bus->roundup) && (pad2 < bus->blocksize)) {
dhd_sdio.c:1634:				} else if ((bus->glom_total_len + len) % DHD_SDALIGN) {
dhd_sdio.c:1636:					    - ((bus->glom_total_len + len) % DHD_SDALIGN);
dhd_sdio.c:1638:				if (forcealign && (len & (ALIGNMENT - 1))) {
dhd_sdio.c:1643:				/* 2byte frame length, 1byte-, 1byte frame flag,
dhd_sdio.c:1644:				 * 2byte-hdrlength, 2byte padlenght
dhd_sdio.c:1646:				hwheader1 = (act_len - SDPCM_FRAMETAG_LEN) | (1 << 24);
dhd_sdio.c:1647:				hwheader2 = (len - act_len) << 16;
dhd_sdio.c:1654:				bus->glom_pkt_arr[bus->glom_cnt] = pkt;
dhd_sdio.c:1655:				bus->glom_cnt++;
dhd_sdio.c:1656:				bus->glom_total_len += len;
dhd_sdio.c:1659:				frame_tmp = (uint8*)PKTDATA(osh, bus->glom_pkt_arr[0]);
dhd_sdio.c:1660:				*(uint16*)frame_tmp = htol16(bus->glom_total_len);
dhd_sdio.c:1661:				*(((uint16*)frame_tmp) + 1) = htol16(~bus->glom_total_len);
dhd_sdio.c:1667:	swheader = ((chan << SDPCM_CHANNEL_SHIFT) & SDPCM_CHANNEL_MASK) | bus->tx_seq |
dhd_sdio.c:1686:	if (bus->roundup && bus->blocksize && (len > bus->blocksize)) {
dhd_sdio.c:1687:		uint16 pad2 = bus->blocksize - (len % bus->blocksize);
dhd_sdio.c:1688:		if ((pad2 <= bus->roundup) && (pad2 < bus->blocksize))
dhd_sdio.c:1694:		len += DHD_SDALIGN - (len % DHD_SDALIGN);
dhd_sdio.c:1697:	/* Some controllers have trouble with odd bytes -- round to even */
dhd_sdio.c:1698:	if (forcealign && (len & (ALIGNMENT - 1))) {
dhd_sdio.c:1705:			DHD_ERROR(("%s: sending unrounded %d-byte packet\n", __FUNCTION__, len));
dhd_sdio.c:1713:		bus->f2txdata++;
dhd_sdio.c:1722:			bus->tx_sderrs++;
dhd_sdio.c:1727:			bus->f1regdata++;
dhd_sdio.c:1735:				bus->f1regdata += 2;
dhd_sdio.c:1742:			if (bus->glom_enable) {
dhd_sdio.c:1743:				bus->tx_seq = (bus->tx_seq + bus->glom_cnt) % SDPCM_SEQUENCE_WRAP;
dhd_sdio.c:1747:			bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
dhd_sdio.c:1755:	if (bus->glom_enable) {
dhd_sdio.c:1757:		pkt_cnt = bus->glom_cnt;
dhd_sdio.c:1767:		if (bus->glom_enable) {
dhd_sdio.c:1768:			pkt = bus->glom_pkt_arr[bus->glom_cnt - pkt_cnt];
dhd_sdio.c:1779:	if (bus->dhd->wlfc_state) {
dhd_sdio.c:1780:		dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:1781:		dhd_wlfc_txcomplete(bus->dhd, pkt, ret == 0);
dhd_sdio.c:1782:		dhd_os_sdlock(bus->dhd);
dhd_sdio.c:1787:		dhd_txcomplete(bus->dhd, pkt, ret != 0);
dhd_sdio.c:1790:	dhd_txcomplete(bus->dhd, pkt, ret != 0);
dhd_sdio.c:1798:		pkt_cnt--;
dhd_sdio.c:1803:	if (bus->glom_enable) {
dhd_sdio.c:1804:		bus->glom_cnt = 0;
dhd_sdio.c:1805:		bus->glom_total_len = 0;
dhd_sdio.c:1826:	osh = bus->dhd->osh;
dhd_sdio.c:1831:	if (bus->ext_loop) {
dhd_sdio.c:1836:		*data++ = (uint8)bus->loopid++;
dhd_sdio.c:1850:	for (i = 0; i < (datalen - 4); i++) {
dhd_sdio.c:1871:	dhd_os_sdlock(bus->dhd);
dhd_sdio.c:1874:	/* Check for existing queue, current flow-control, pending event, or pending clock */
dhd_sdio.c:1875:	if (dhd_deferred_tx || bus->fcstate || pktq_len(&bus->txq) || bus->dpc_sched ||
dhd_sdio.c:1876:	    (!DATAOK(bus)) || (bus->flowcontrol & NBITVAL(prec)) ||
dhd_sdio.c:1877:	    (bus->clkstate != CLK_AVAIL)) {
dhd_sdio.c:1879:			pktq_len(&bus->txq)));
dhd_sdio.c:1880:		bus->fcqueued++;
dhd_sdio.c:1883:		dhd_os_sdlock_txq(bus->dhd);
dhd_sdio.c:1884:		if (dhd_prec_enq(bus->dhd, &bus->txq, pkt, prec) == FALSE) {
dhd_sdio.c:1892:			dhd_os_sdunlock_txq(bus->dhd);
dhd_sdio.c:1893:			dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:1896:			if (bus->dhd->wlfc_state)
dhd_sdio.c:1897:				dhd_wlfc_txcomplete(bus->dhd, pkt, FALSE);
dhd_sdio.c:1900:			dhd_txcomplete(bus->dhd, pkt, FALSE);
dhd_sdio.c:1902:			dhd_os_sdlock(bus->dhd);
dhd_sdio.c:1903:			dhd_os_sdlock_txq(bus->dhd);
dhd_sdio.c:1907:			if (!bus->dhd->wlfc_state)
dhd_sdio.c:1914:		dhd_os_sdunlock_txq(bus->dhd);
dhd_sdio.c:1916:		if ((pktq_len(&bus->txq) >= FCHI) && dhd_doflow)
dhd_sdio.c:1917:			dhd_txflowcontrol(bus->dhd, ALL_INTERFACES, ON);
dhd_sdio.c:1920:		if (pktq_plen(&bus->txq, prec) > qcount[prec])
dhd_sdio.c:1921:			qcount[prec] = pktq_plen(&bus->txq, prec);
dhd_sdio.c:1924:		if (dhd_deferred_tx && !bus->dpc_sched) {
dhd_sdio.c:1925:			bus->dpc_sched = TRUE;
dhd_sdio.c:1926:			dhd_sched_dpc(bus->dhd);
dhd_sdio.c:1931:		dhd_os_sdlock(bus->dhd);
dhd_sdio.c:1942:		        (bus->ext_loop ? SDPCM_TEST_CHANNEL : SDPCM_DATA_CHANNEL), TRUE, FALSE);
dhd_sdio.c:1945:			bus->dhd->tx_errors++;
dhd_sdio.c:1947:			bus->dhd->dstats.tx_bytes += datalen;
dhd_sdio.c:1949:		if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
dhd_sdio.c:1950:			bus->activity = FALSE;
dhd_sdio.c:1955:		dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:1960:	dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:1981:	dhd_pub_t *dhd = bus->dhd;
dhd_sdio.c:1982:	sdpcmd_regs_t *regs = bus->regs;
dhd_sdio.c:1991:	tx_prec_map = ~bus->flowcontrol;
dhd_sdio.c:1996:		if (bus->glom_enable) {
dhd_sdio.c:1997:			glom_cnt = MIN(DATABUFCNT(bus), bus->glomsize);
dhd_sdio.c:1998:			glom_cnt = MIN(glom_cnt, pktq_mlen(&bus->txq, tx_prec_map));
dhd_sdio.c:1999:			glom_cnt = MIN(glom_cnt, maxframes-cnt);
dhd_sdio.c:2002:			if (bus->glom_mode == SDPCM_TXGLOM_CPY)
dhd_sdio.c:2009:				dhd_os_sdlock_txq(bus->dhd);
dhd_sdio.c:2010:				if ((pkt = pktq_mdeq(&bus->txq, tx_prec_map, &prec_out)) == NULL) {
dhd_sdio.c:2013:					dhd_os_sdunlock_txq(bus->dhd);
dhd_sdio.c:2016:				dhd_os_sdunlock_txq(bus->dhd);
dhd_sdio.c:2018:				datalen += (PKTLEN(bus->dhd->osh, pkt) - SDPCM_HDRLEN);
dhd_sdio.c:2024:					(i == (glom_cnt-1))? FALSE: TRUE);
dhd_sdio.c:2028:					(bus->ext_loop ? SDPCM_TEST_CHANNEL : SDPCM_DATA_CHANNEL),
dhd_sdio.c:2030:					(i == (glom_cnt-1))? FALSE: TRUE);
dhd_sdio.c:2033:			cnt += i-1;
dhd_sdio.c:2037:		dhd_os_sdlock_txq(bus->dhd);
dhd_sdio.c:2038:		if ((pkt = pktq_mdeq(&bus->txq, tx_prec_map, &prec_out)) == NULL) {
dhd_sdio.c:2039:			dhd_os_sdunlock_txq(bus->dhd);
dhd_sdio.c:2042:		dhd_os_sdunlock_txq(bus->dhd);
dhd_sdio.c:2043:		datalen = PKTLEN(bus->dhd->osh, pkt) - SDPCM_HDRLEN;
dhd_sdio.c:2050:			(bus->ext_loop ? SDPCM_TEST_CHANNEL : SDPCM_DATA_CHANNEL),
dhd_sdio.c:2057:			bus->dhd->tx_errors++;
dhd_sdio.c:2059:			bus->dhd->dstats.tx_bytes += datalen;
dhd_sdio.c:2062:		if (!bus->intr && cnt)
dhd_sdio.c:2065:			R_SDREG(intstatus, &regs->intstatus, retries);
dhd_sdio.c:2066:			bus->f2txdata++;
dhd_sdio.c:2067:			if (bcmsdh_regfail(bus->sdh))
dhd_sdio.c:2069:			if (intstatus & bus->hostintmask)
dhd_sdio.c:2070:				bus->ipend = TRUE;
dhd_sdio.c:2074:	/* Deflow-control stack if needed */
dhd_sdio.c:2075:	if (dhd_doflow && dhd->up && (dhd->busstate == DHD_BUS_DATA) &&
dhd_sdio.c:2076:	    dhd->txoff && (pktq_len(&bus->txq) < FCLOW))
dhd_sdio.c:2089:	bcmsdh_info_t *sdh = bus->sdh;
dhd_sdio.c:2091:	int ret = -1;
dhd_sdio.c:2096:	if (bus->dhd->dongle_reset)
dhd_sdio.c:2097:		return -EIO;
dhd_sdio.c:2100:	frame = msg - SDPCM_HDRLEN;
dhd_sdio.c:2106:			frame -= doff;
dhd_sdio.c:2116:	if (bus->roundup && bus->blocksize && (len > bus->blocksize)) {
dhd_sdio.c:2117:		uint16 pad = bus->blocksize - (len % bus->blocksize);
dhd_sdio.c:2118:		if ((pad <= bus->roundup) && (pad < bus->blocksize))
dhd_sdio.c:2121:		len += DHD_SDALIGN - (len % DHD_SDALIGN);
dhd_sdio.c:2124:	/* Satisfy length-alignment requirements */
dhd_sdio.c:2125:	if (forcealign && (len & (ALIGNMENT - 1)))
dhd_sdio.c:2132:	dhd_os_sdlock(bus->dhd);
dhd_sdio.c:2144:	if (bus->glom_enable) {
dhd_sdio.c:2148:				| bus->tx_seq
dhd_sdio.c:2154:		hwheader1 = (msglen - SDPCM_FRAMETAG_LEN) | (1 << 24);
dhd_sdio.c:2155:		hwheader2 = (len - (msglen)) << 16;
dhd_sdio.c:2166:	        | bus->tx_seq | ((doff << SDPCM_DOFFSET_SHIFT) & SDPCM_DOFFSET_MASK);
dhd_sdio.c:2171:		DHD_INFO(("%s: No bus credit bus->tx_max %d, bus->tx_seq %d\n",
dhd_sdio.c:2172:			__FUNCTION__, bus->tx_max, bus->tx_seq));
dhd_sdio.c:2173:		bus->ctrl_frame_stat = TRUE;
dhd_sdio.c:2175:		bus->ctrl_frame_buf = frame;
dhd_sdio.c:2176:		bus->ctrl_frame_len = len;
dhd_sdio.c:2178:		if (!bus->dpc_sched) {
dhd_sdio.c:2179:			bus->dpc_sched = TRUE;
dhd_sdio.c:2180:			dhd_sched_dpc(bus->dhd);
dhd_sdio.c:2182:		if (bus->ctrl_frame_stat) {
dhd_sdio.c:2183:			dhd_wait_for_event(bus->dhd, &bus->ctrl_frame_stat);
dhd_sdio.c:2186:		if (bus->ctrl_frame_stat == FALSE) {
dhd_sdio.c:2190:			bus->dhd->txcnt_timeout++;
dhd_sdio.c:2191:			if (!bus->dhd->hang_was_sent) {
dhd_sdio.c:2193:					__FUNCTION__, bus->dhd->txcnt_timeout));
dhd_sdio.c:2195:			ret = -1;
dhd_sdio.c:2196:			bus->ctrl_frame_stat = FALSE;
dhd_sdio.c:2201:	bus->dhd->txcnt_timeout = 0;
dhd_sdio.c:2203:	if (ret == -1) {
dhd_sdio.c:2223:				bus->tx_sderrs++;
dhd_sdio.c:2229:				bus->f1regdata++;
dhd_sdio.c:2237:					bus->f1regdata += 2;
dhd_sdio.c:2243:				bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
dhd_sdio.c:2249:	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
dhd_sdio.c:2250:		bus->activity = FALSE;
dhd_sdio.c:2254:	dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:2257:		bus->dhd->tx_ctlerrs++;
dhd_sdio.c:2259:		bus->dhd->tx_ctlpkts++;
dhd_sdio.c:2261:	if (bus->dhd->txcnt_timeout >= MAX_CNTL_TIMEOUT)
dhd_sdio.c:2262:		return -ETIMEDOUT;
dhd_sdio.c:2264:	return ret ? -EIO : 0;
dhd_sdio.c:2276:	if (bus->dhd->dongle_reset)
dhd_sdio.c:2277:		return -EIO;
dhd_sdio.c:2280:	timeleft = dhd_os_ioctl_resp_wait(bus->dhd, &bus->rxlen, &pending);
dhd_sdio.c:2282:	dhd_os_sdlock(bus->dhd);
dhd_sdio.c:2283:	rxlen = bus->rxlen;
dhd_sdio.c:2284:	bcopy(bus->rxctl, msg, MIN(msglen, rxlen));
dhd_sdio.c:2285:	bus->rxlen = 0;
dhd_sdio.c:2286:	dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:2294:		R_SDREG(status, &bus->regs->intstatus, retry);
dhd_sdio.c:2301:		dhd_os_sdlock(bus->dhd);
dhd_sdio.c:2303:		dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:2308:		return -EINTR;
dhd_sdio.c:2312:		dhd_os_sdlock(bus->dhd);
dhd_sdio.c:2314:		dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:2318:		bus->dhd->rxcnt_timeout++;
dhd_sdio.c:2319:		DHD_ERROR(("%s: rxcnt_timeout=%d\n", __FUNCTION__, bus->dhd->rxcnt_timeout));
dhd_sdio.c:2322:		bus->dhd->rxcnt_timeout = 0;
dhd_sdio.c:2325:		bus->dhd->rx_ctlpkts++;
dhd_sdio.c:2327:		bus->dhd->rx_ctlerrs++;
dhd_sdio.c:2329:	if (bus->dhd->rxcnt_timeout >= MAX_CNTL_TIMEOUT)
dhd_sdio.c:2330:		return -ETIMEDOUT;
dhd_sdio.c:2332:	if (bus->dhd->dongle_trap_occured)
dhd_sdio.c:2333:		return -EREMOTEIO;
dhd_sdio.c:2335:	return rxlen ? (int)rxlen : -EIO;
dhd_sdio.c:2450:		q2 = (100 * (num - (q1 * div))) / div;
dhd_sdio.c:2458:	dhd_bus_t *bus = dhdp->bus;
dhd_sdio.c:2462:	            bus->hostintmask, bus->intstatus, bus->sdpcm_ver);
dhd_sdio.c:2464:	            bus->fcstate, pktq_len(&bus->txq), bus->tx_seq, bus->tx_max, bus->rxskip,
dhd_sdio.c:2465:	            bus->rxlen, bus->rx_seq);
dhd_sdio.c:2467:	            bus->intr, bus->intrcount, bus->lastintrs, bus->spurious);
dhd_sdio.c:2469:	            bus->pollrate, bus->pollcnt, bus->regfails);
dhd_sdio.c:2473:	            bus->tx_sderrs, bus->fcqueued, bus->rxrtx, bus->rx_toolong,
dhd_sdio.c:2474:	            bus->rxc_errors);
dhd_sdio.c:2476:	            bus->rx_hdrfail, bus->rx_badhdr, bus->rx_badseq);
dhd_sdio.c:2478:	            bus->fc_rcvd, bus->fc_xoff, bus->fc_xon);
dhd_sdio.c:2480:	            bus->rxglomfail, bus->rxglomframes, bus->rxglompkts);
dhd_sdio.c:2482:	            (bus->f2rxhdrs + bus->f2rxdata), bus->f2rxhdrs, bus->f2rxdata,
dhd_sdio.c:2483:	            bus->f2txdata, bus->f1regdata);
dhd_sdio.c:2485:		dhd_dump_pct(strbuf, "\nRx: pkts/f2rd", bus->dhd->rx_packets,
dhd_sdio.c:2486:		             (bus->f2rxhdrs + bus->f2rxdata));
dhd_sdio.c:2487:		dhd_dump_pct(strbuf, ", pkts/f1sd", bus->dhd->rx_packets, bus->f1regdata);
dhd_sdio.c:2488:		dhd_dump_pct(strbuf, ", pkts/sd", bus->dhd->rx_packets,
dhd_sdio.c:2489:		             (bus->f2rxhdrs + bus->f2rxdata + bus->f1regdata));
dhd_sdio.c:2490:		dhd_dump_pct(strbuf, ", pkts/int", bus->dhd->rx_packets, bus->intrcount);
dhd_sdio.c:2493:		dhd_dump_pct(strbuf, "Rx: glom pct", (100 * bus->rxglompkts),
dhd_sdio.c:2494:		             bus->dhd->rx_packets);
dhd_sdio.c:2495:		dhd_dump_pct(strbuf, ", pkts/glom", bus->rxglompkts, bus->rxglomframes);
dhd_sdio.c:2498:		dhd_dump_pct(strbuf, "Tx: pkts/f2wr", bus->dhd->tx_packets, bus->f2txdata);
dhd_sdio.c:2499:		dhd_dump_pct(strbuf, ", pkts/f1sd", bus->dhd->tx_packets, bus->f1regdata);
dhd_sdio.c:2500:		dhd_dump_pct(strbuf, ", pkts/sd", bus->dhd->tx_packets,
dhd_sdio.c:2501:		             (bus->f2txdata + bus->f1regdata));
dhd_sdio.c:2502:		dhd_dump_pct(strbuf, ", pkts/int", bus->dhd->tx_packets, bus->intrcount);
dhd_sdio.c:2506:		             (bus->dhd->tx_packets + bus->dhd->rx_packets),
dhd_sdio.c:2507:		             (bus->f2txdata + bus->f2rxhdrs + bus->f2rxdata));
dhd_sdio.c:2509:		             (bus->dhd->tx_packets + bus->dhd->rx_packets), bus->f1regdata);
dhd_sdio.c:2511:		             (bus->dhd->tx_packets + bus->dhd->rx_packets),
dhd_sdio.c:2512:		             (bus->f2txdata + bus->f2rxhdrs + bus->f2rxdata + bus->f1regdata));
dhd_sdio.c:2514:		             (bus->dhd->tx_packets + bus->dhd->rx_packets), bus->intrcount);
dhd_sdio.c:2519:	if (bus->pktgen_count) {
dhd_sdio.c:2522:		            bus->pktgen_freq, bus->pktgen_count, bus->pktgen_print,
dhd_sdio.c:2523:		            bus->pktgen_total, bus->pktgen_minlen, bus->pktgen_maxlen);
dhd_sdio.c:2525:		            bus->pktgen_sent, bus->pktgen_rcvd, bus->pktgen_fail);
dhd_sdio.c:2530:	            bus->dpc_sched, (bcmsdh_intr_pending(bus->sdh) ? " " : " not "));
dhd_sdio.c:2531:	bcm_bprintf(strbuf, "blocksize %d roundup %d\n", bus->blocksize, bus->roundup);
dhd_sdio.c:2534:	            bus->clkstate, bus->activity, bus->idletime, bus->idlecount, bus->sleeping);
dhd_sdio.c:2540:	dhd_bus_t *bus = (dhd_bus_t *)dhdp->bus;
dhd_sdio.c:2542:	bus->intrcount = bus->lastintrs = bus->spurious = bus->regfails = 0;
dhd_sdio.c:2543:	bus->rxrtx = bus->rx_toolong = bus->rxc_errors = 0;
dhd_sdio.c:2544:	bus->rx_hdrfail = bus->rx_badhdr = bus->rx_badseq = 0;
dhd_sdio.c:2545:	bus->tx_sderrs = bus->fc_rcvd = bus->fc_xoff = bus->fc_xon = 0;
dhd_sdio.c:2546:	bus->rxglomfail = bus->rxglomframes = bus->rxglompkts = 0;
dhd_sdio.c:2547:	bus->f2rxhdrs = bus->f2rxdata = bus->f2txdata = bus->f1regdata = 0;
dhd_sdio.c:2557:	pktgen.freq = bus->pktgen_freq;
dhd_sdio.c:2558:	pktgen.count = bus->pktgen_count;
dhd_sdio.c:2559:	pktgen.print = bus->pktgen_print;
dhd_sdio.c:2560:	pktgen.total = bus->pktgen_total;
dhd_sdio.c:2561:	pktgen.minlen = bus->pktgen_minlen;
dhd_sdio.c:2562:	pktgen.maxlen = bus->pktgen_maxlen;
dhd_sdio.c:2563:	pktgen.numsent = bus->pktgen_sent;
dhd_sdio.c:2564:	pktgen.numrcvd = bus->pktgen_rcvd;
dhd_sdio.c:2565:	pktgen.numfail = bus->pktgen_fail;
dhd_sdio.c:2566:	pktgen.mode = bus->pktgen_mode;
dhd_sdio.c:2567:	pktgen.stop = bus->pktgen_stop;
dhd_sdio.c:2584:	oldcnt = bus->pktgen_count;
dhd_sdio.c:2585:	oldmode = bus->pktgen_mode;
dhd_sdio.c:2587:	bus->pktgen_freq = pktgen.freq;
dhd_sdio.c:2588:	bus->pktgen_count = pktgen.count;
dhd_sdio.c:2589:	bus->pktgen_print = pktgen.print;
dhd_sdio.c:2590:	bus->pktgen_total = pktgen.total;
dhd_sdio.c:2591:	bus->pktgen_minlen = pktgen.minlen;
dhd_sdio.c:2592:	bus->pktgen_maxlen = pktgen.maxlen;
dhd_sdio.c:2593:	bus->pktgen_mode = pktgen.mode;
dhd_sdio.c:2594:	bus->pktgen_stop = pktgen.stop;
dhd_sdio.c:2596:	bus->pktgen_tick = bus->pktgen_ptick = 0;
dhd_sdio.c:2597:	bus->pktgen_prev_time = jiffies;
dhd_sdio.c:2598:	bus->pktgen_len = MAX(bus->pktgen_len, bus->pktgen_minlen);
dhd_sdio.c:2599:	bus->pktgen_len = MIN(bus->pktgen_len, bus->pktgen_maxlen);
dhd_sdio.c:2602:	if (bus->pktgen_count && (!oldcnt || oldmode != bus->pktgen_mode)) {
dhd_sdio.c:2603:		bus->pktgen_sent = bus->pktgen_prev_sent = bus->pktgen_rcvd = 0;
dhd_sdio.c:2604:		bus->pktgen_prev_rcvd = bus->pktgen_fail = 0;
dhd_sdio.c:2616:	si_socdevram(bus->sih, FALSE, &enable, &protect, &remap);
dhd_sdio.c:2618:	si_socdevram(bus->sih, TRUE, &enable, &protect, &remap);
dhd_sdio.c:2633:		address -= bus->orig_ramsize;
dhd_sdio.c:2640:		dsize = (SBSDIO_SB_OFT_ADDR_LIMIT - sdaddr);
dhd_sdio.c:2655:		if ((bcmerror = bcmsdh_rwdata(bus->sdh, write, sdaddr, data, dsize))) {
dhd_sdio.c:2661:		if ((size -= dsize)) {
dhd_sdio.c:2676:	if (dhdsdio_set_siaddr_window(bus, bcmsdh_cur_sbwad(bus->sdh))) {
dhd_sdio.c:2678:			bcmsdh_cur_sbwad(bus->sdh)));
dhd_sdio.c:2692:	shaddr = bus->dongle_ram_base + bus->ramsize - 4;
dhd_sdio.c:2708:			if ((bus->srmemsize > 0) && (i++ == 0)) {
dhd_sdio.c:2709:				shaddr -= bus->srmemsize;
dhd_sdio.c:2724:	sh->flags = ltoh32(sh->flags);
dhd_sdio.c:2725:	sh->trap_addr = ltoh32(sh->trap_addr);
dhd_sdio.c:2726:	sh->assert_exp_addr = ltoh32(sh->assert_exp_addr);
dhd_sdio.c:2727:	sh->assert_file_addr = ltoh32(sh->assert_file_addr);
dhd_sdio.c:2728:	sh->assert_line = ltoh32(sh->assert_line);
dhd_sdio.c:2729:	sh->console_addr = ltoh32(sh->console_addr);
dhd_sdio.c:2730:	sh->msgtrace_addr = ltoh32(sh->msgtrace_addr);
dhd_sdio.c:2732:	if ((sh->flags & SDPCM_SHARED_VERSION_MASK) == 3 && SDPCM_SHARED_VERSION == 1)
dhd_sdio.c:2735:	if ((sh->flags & SDPCM_SHARED_VERSION_MASK) != SDPCM_SHARED_VERSION) {
dhd_sdio.c:2739:		           sh->flags & SDPCM_SHARED_VERSION_MASK));
dhd_sdio.c:2751:	dhd_console_t *c = &bus->console;
dhd_sdio.c:2757:	if (bus->console_addr == 0)
dhd_sdio.c:2764:	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, log);
dhd_sdio.c:2765:	if ((rv = dhdsdio_membytes(bus, FALSE, addr, (uint8 *)&c->log, sizeof(c->log))) < 0)
dhd_sdio.c:2769:	if (c->buf == NULL) {
dhd_sdio.c:2770:		c->bufsize = ltoh32(c->log.buf_size);
dhd_sdio.c:2771:		if ((c->buf = MALLOC(bus->dhd->osh, c->bufsize)) == NULL)
dhd_sdio.c:2775:	idx = ltoh32(c->log.idx);
dhd_sdio.c:2778:	if (idx > c->bufsize)
dhd_sdio.c:2782:	if (idx == c->last)
dhd_sdio.c:2786:	addr = ltoh32(c->log.buf);
dhd_sdio.c:2787:	if ((rv = dhdsdio_membytes(bus, FALSE, addr, c->buf, c->bufsize)) < 0)
dhd_sdio.c:2790:	while (c->last != idx) {
dhd_sdio.c:2791:		for (n = 0; n < CONSOLE_LINE_MAX - 2; n++) {
dhd_sdio.c:2792:			if (c->last == idx) {
dhd_sdio.c:2796:				if (c->last >= n)
dhd_sdio.c:2797:					c->last -= n;
dhd_sdio.c:2799:					c->last = c->bufsize - n;
dhd_sdio.c:2802:			ch = c->buf[c->last];
dhd_sdio.c:2803:			c->last = (c->last + 1) % c->bufsize;
dhd_sdio.c:2810:			if (line[n - 1] == '\r')
dhd_sdio.c:2811:				n--;
dhd_sdio.c:2846:		mbuffer = data = MALLOC(bus->dhd->osh, msize);
dhd_sdio.c:2854:	if ((str = MALLOC(bus->dhd->osh, maxstrlen)) == NULL) {
dhd_sdio.c:2869:		/* NOTE: Misspelled assert is intentional - DO NOT FIX.
dhd_sdio.c:2876:		/* NOTE: Misspelled assert is intentional - DO NOT FIX.
dhd_sdio.c:2893:				str[maxstrlen - 1] = '\0';
dhd_sdio.c:2904:				str[maxstrlen - 1] = '\0';
dhd_sdio.c:2912:			bus->dhd->dongle_trap_occured = TRUE;
dhd_sdio.c:2949:				!(console_buffer = MALLOC(bus->dhd->osh, console_size)))
dhd_sdio.c:2957:				for (n = 0; n < CONSOLE_LINE_MAX - 2; n++) {
dhd_sdio.c:2966:					if (line[n - 1] == '\r')
dhd_sdio.c:2967:						n--;
dhd_sdio.c:2989:		MFREE(bus->dhd->osh, mbuffer, msize);
dhd_sdio.c:2991:		MFREE(bus->dhd->osh, str, maxstrlen);
dhd_sdio.c:2993:		MFREE(bus->dhd->osh, console_buffer, console_size);
dhd_sdio.c:3008:	if (bus->dhd->up) {
dhd_sdio.c:3018:	if (bus->vars)
dhd_sdio.c:3019:		MFREE(bus->dhd->osh, bus->vars, bus->varsz);
dhd_sdio.c:3021:	bus->vars = MALLOC(bus->dhd->osh, len);
dhd_sdio.c:3022:	bus->varsz = bus->vars ? len : 0;
dhd_sdio.c:3023:	if (bus->vars == NULL) {
dhd_sdio.c:3028:	/* Copy the passed variables, which should include the terminating double-null */
dhd_sdio.c:3029:	bcopy(arg, bus->vars, bus->varsz);
dhd_sdio.c:3053:	bcmsdh_reg_write(bus->sdh, addr, 4, 1);
dhd_sdio.c:3054:	if (bcmsdh_regfail(bus->sdh)) {
dhd_sdio.c:3056:		return -1;
dhd_sdio.c:3058:	int_val = bcmsdh_reg_read(bus->sdh, data, 4);
dhd_sdio.c:3059:	if (bcmsdh_regfail(bus->sdh)) {
dhd_sdio.c:3061:		return -1;
dhd_sdio.c:3063:	if (bus->sih->chip == BCM4330_CHIP_ID) {
dhd_sdio.c:3066:	else if (bus->sih->chip == BCM4334_CHIP_ID ||
dhd_sdio.c:3067:		bus->sih->chip == BCM43341_CHIP_ID) {
dhd_sdio.c:3085:	bcmsdh_reg_write(bus->sdh, data, 4, int_val);
dhd_sdio.c:3086:	if (bcmsdh_regfail(bus->sdh)) {
dhd_sdio.c:3088:		return -1;
dhd_sdio.c:3090:	if (bus->sih->chip == BCM4330_CHIP_ID) {
dhd_sdio.c:3093:		chipcontrol = bcmsdh_reg_read(bus->sdh, addr, 4);
dhd_sdio.c:3099:		bcmsdh_reg_write(bus->sdh, addr, 4, chipcontrol);
dhd_sdio.c:3127:	dhd_os_sdlock(bus->dhd);
dhd_sdio.c:3130:	if (bus->dhd->dongle_reset && !(actionid == IOV_SVAL(IOV_DEVRESET) ||
dhd_sdio.c:3137:	 * Special handling for keepSdioOn: New SDIO Wake-up Mechanism
dhd_sdio.c:3139:	if ((vi->varid == IOV_KSO) && (IOV_ISSET(actionid))) {
dhd_sdio.c:3142:	} else if ((vi->varid == IOV_DEVSLEEP) && (IOV_ISSET(actionid))) {
dhd_sdio.c:3145:			if (!SLPAUTO_ENAB(bus) && (bool_val == FALSE) && (bus->ipend)) {
dhd_sdio.c:3147:					bus->dpc_sched));
dhd_sdio.c:3148:				if (!bus->dpc_sched) {
dhd_sdio.c:3149:					bus->dpc_sched = TRUE;
dhd_sdio.c:3150:					dhd_sched_dpc(bus->dhd);
dhd_sdio.c:3158:	if (vi->varid == IOV_SLEEP) {
dhd_sdio.c:3162:			int_val = (int32)bus->sleeping;
dhd_sdio.c:3169:	if (!bus->dhd->dongle_reset) {
dhd_sdio.c:3176:		int_val = (int32)bus->intr;
dhd_sdio.c:3181:		bus->intr = bool_val;
dhd_sdio.c:3182:		bus->intdis = FALSE;
dhd_sdio.c:3183:		if (bus->dhd->up) {
dhd_sdio.c:3184:			if (bus->intr) {
dhd_sdio.c:3186:				bcmsdh_intr_enable(bus->sdh);
dhd_sdio.c:3189:				bcmsdh_intr_disable(bus->sdh);
dhd_sdio.c:3195:		int_val = (int32)bus->pollrate;
dhd_sdio.c:3200:		bus->pollrate = (uint)int_val;
dhd_sdio.c:3201:		bus->poll = (bus->pollrate != 0);
dhd_sdio.c:3205:		int_val = bus->idletime;
dhd_sdio.c:3213:			bus->idletime = int_val;
dhd_sdio.c:3218:		int_val = (int32)bus->idleclock;
dhd_sdio.c:3223:		bus->idleclock = int_val;
dhd_sdio.c:3252:		dsize = set ? plen - (2 * sizeof(int)) : len;
dhd_sdio.c:3264:		if ((bus->orig_ramsize) &&
dhd_sdio.c:3265:		    ((address > bus->orig_ramsize) || (address + size > bus->orig_ramsize)))
dhd_sdio.c:3268:			si_socdevram(bus->sih, FALSE, &enable, &protect, &remap);
dhd_sdio.c:3271:					__FUNCTION__, bus->orig_ramsize, size, address));
dhd_sdio.c:3279:				uint32 devramsize = si_socdevram_size(bus->sih);
dhd_sdio.c:3290:				address -= SOCDEVRAM_ARM_ADDR;
dhd_sdio.c:3315:		int_val = (int32)bus->ramsize;
dhd_sdio.c:3326:		si_sdiod_drive_strength_init(bus->sih, bus->dhd->osh, dhd_sdiod_drive_strength);
dhd_sdio.c:3348:			bus->nextlen = 0;
dhd_sdio.c:3353:		int_val = (int32)bus->use_rxchain;
dhd_sdio.c:3358:		if (bool_val && !bus->sd_rxchain)
dhd_sdio.c:3361:			bus->use_rxchain = bool_val;
dhd_sdio.c:3379:		if (bus->varsz < (uint)len)
dhd_sdio.c:3380:			bcopy(bus->vars, arg, bus->varsz);
dhd_sdio.c:3394:		addr = (uintptr)bus->regs + sd_ptr->offset;
dhd_sdio.c:3395:		size = sd_ptr->func;
dhd_sdio.c:3396:		int_val = (int32)bcmsdh_reg_read(bus->sdh, addr, size);
dhd_sdio.c:3397:		if (bcmsdh_regfail(bus->sdh))
dhd_sdio.c:3410:		addr = (uintptr)bus->regs + sd_ptr->offset;
dhd_sdio.c:3411:		size = sd_ptr->func;
dhd_sdio.c:3412:		bcmsdh_reg_write(bus->sdh, addr, size, sd_ptr->value);
dhd_sdio.c:3413:		if (bcmsdh_regfail(bus->sdh))
dhd_sdio.c:3428:		int_val = (int32)bcmsdh_reg_read(bus->sdh, addr, size);
dhd_sdio.c:3429:		if (bcmsdh_regfail(bus->sdh))
dhd_sdio.c:3444:		bcmsdh_reg_write(bus->sdh, addr, size, sdreg.value);
dhd_sdio.c:3445:		if (bcmsdh_regfail(bus->sdh))
dhd_sdio.c:3455:		bcmsdh_cis_read(bus->sdh, 0x10, (uint8 *)arg + strlen(arg), SBSDIO_CIS_SIZE_LIMIT);
dhd_sdio.c:3457:		bcmsdh_cis_read(bus->sdh, 0x11, (uint8 *)arg + strlen(arg), SBSDIO_CIS_SIZE_LIMIT);
dhd_sdio.c:3459:		bcmsdh_cis_read(bus->sdh, 0x12, (uint8 *)arg + strlen(arg), SBSDIO_CIS_SIZE_LIMIT);
dhd_sdio.c:3518:		int_val = (int32)bus->ext_loop;
dhd_sdio.c:3523:		bus->ext_loop = bool_val;
dhd_sdio.c:3545:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK, (uint8)watermark, NULL);
dhd_sdio.c:3558:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_MESBUSYCTRL,
dhd_sdio.c:3564:		int_val = bus->dhd->dongle_isolation;
dhd_sdio.c:3569:		bus->dhd->dongle_isolation = bool_val;
dhd_sdio.c:3574:		           __FUNCTION__, bool_val, bus->dhd->dongle_reset,
dhd_sdio.c:3575:		           bus->dhd->busstate));
dhd_sdio.c:3577:		ASSERT(bus->dhd->osh);
dhd_sdio.c:3578:		/* ASSERT(bus->cl_devid); */
dhd_sdio.c:3580:		dhd_bus_devreset(bus->dhd, (uint8)bool_val);
dhd_sdio.c:3588:		fw_path_len = strlen(bus->fw_path);
dhd_sdio.c:3591:		if (fw_path_len > len-1) {
dhd_sdio.c:3597:			bcopy(bus->fw_path, arg, fw_path_len);
dhd_sdio.c:3608:			bus->fw_path = fw_path; /* ordinary one */
dhd_sdio.c:3611:			bus->fw_path = fw_path2;
dhd_sdio.c:3618:		DHD_INFO(("[softap] new fw path: %s\n", (bus->fw_path[0] ? bus->fw_path : "NULL")));
dhd_sdio.c:3626:		int_val = (bool) bus->dhd->dongle_reset;
dhd_sdio.c:3647:		int_val = (int32)bus->glomsize;
dhd_sdio.c:3655:			bus->glomsize = (uint)int_val;
dhd_sdio.c:3659:		int_val = (int32)bus->glom_mode;
dhd_sdio.c:3667:			if ((bus->glom_mode = bcmsdh_set_mode(bus->sdh, (uint)int_val)) != int_val)
dhd_sdio.c:3678:	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
dhd_sdio.c:3679:		bus->activity = FALSE;
dhd_sdio.c:3683:	dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:3701:	varsize = bus->varsz ? ROUNDUP(bus->varsz, 4) : 0;
dhd_sdio.c:3702:	varaddr = (bus->ramsize - 4) - varsize;
dhd_sdio.c:3704:	varaddr += bus->dongle_ram_base;
dhd_sdio.c:3706:	if (bus->vars) {
dhd_sdio.c:3707:		if ((bus->sih->buscoretype == SDIOD_CORE_ID) && (bus->sdpcmrev == 7)) {
dhd_sdio.c:3711:				varaddr -= 4;
dhd_sdio.c:3715:		vbuffer = (uint8 *)MALLOC(bus->dhd->osh, varsize);
dhd_sdio.c:3720:		bcopy(bus->vars, vbuffer, bus->varsz);
dhd_sdio.c:3727:		nvram_ularray = (uint8*)MALLOC(bus->dhd->osh, varsize);
dhd_sdio.c:3747:		MFREE(bus->dhd->osh, nvram_ularray, varsize);
dhd_sdio.c:3750:		MFREE(bus->dhd->osh, vbuffer, varsize);
dhd_sdio.c:3753:	phys_size = REMAP_ENAB(bus) ? bus->ramsize : bus->orig_ramsize;
dhd_sdio.c:3755:	phys_size += bus->dongle_ram_base;
dhd_sdio.c:3759:		phys_size, bus->ramsize));
dhd_sdio.c:3762:	varsize = ((phys_size - 4) - varaddr);
dhd_sdio.c:3766:	 * Varsize, converted to words, in lower 16-bits, checksum in upper 16-bits.
dhd_sdio.c:3779:	bcmerror = dhdsdio_membytes(bus, TRUE, (phys_size - 4),
dhd_sdio.c:3796:		bus->alp_only = TRUE;
dhd_sdio.c:3798:		if (!(si_setcore(bus->sih, ARM7S_CORE_ID, 0)) &&
dhd_sdio.c:3799:		    !(si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
dhd_sdio.c:3800:			if (si_setcore(bus->sih, ARMCR4_CORE_ID, 0)) {
dhd_sdio.c:3810:		si_core_disable(bus->sih, 0);
dhd_sdio.c:3811:		if (bcmsdh_regfail(bus->sdh)) {
dhd_sdio.c:3816:		if (!(si_setcore(bus->sih, SOCRAM_CORE_ID, 0))) {
dhd_sdio.c:3822:		si_core_reset(bus->sih, 0, 0);
dhd_sdio.c:3823:		if (bcmsdh_regfail(bus->sdh)) {
dhd_sdio.c:3830:		if (REMAP_ENAB(bus) && si_socdevram_remap_isenb(bus->sih))
dhd_sdio.c:3834:		if (bus->ramsize) {
dhd_sdio.c:3836:			if (dhdsdio_membytes(bus, TRUE, bus->ramsize - 4, (uint8*)&zeros, 4) < 0) {
dhd_sdio.c:3851:			si_core_reset(bus->sih, SICF_CPUHALT, SICF_CPUHALT);
dhd_sdio.c:3854:		if (!si_setcore(bus->sih, ARMCR4_CORE_ID, 0)) {
dhd_sdio.c:3855:		if (!(si_setcore(bus->sih, SOCRAM_CORE_ID, 0))) {
dhd_sdio.c:3861:		if (!si_iscoreup(bus->sih)) {
dhd_sdio.c:3875:		if (REMAP_ENAB(bus) && !si_socdevram_remap_isenb(bus->sih))
dhd_sdio.c:3878:		if (!si_setcore(bus->sih, PCMCIA_CORE_ID, 0) &&
dhd_sdio.c:3879:		    !si_setcore(bus->sih, SDIOD_CORE_ID, 0)) {
dhd_sdio.c:3884:		W_SDREG(0xFFFFFFFF, &bus->regs->intstatus, retries);
dhd_sdio.c:3887:		if (!(si_setcore(bus->sih, ARM7S_CORE_ID, 0)) &&
dhd_sdio.c:3888:		    !(si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
dhd_sdio.c:3901:			if (!si_setcore(bus->sih, PCMCIA_CORE_ID, 0) &&
dhd_sdio.c:3902:			    !si_setcore(bus->sih, SDIOD_CORE_ID, 0)) {
dhd_sdio.c:3907:			W_SDREG(0xFFFFFFFF, &bus->regs->intstatus, retries);
dhd_sdio.c:3910:			if (!(si_setcore(bus->sih, ARMCR4_CORE_ID, 0))) {
dhd_sdio.c:3917:				(uint8 *)&bus->resetinstr, sizeof(bus->resetinstr));
dhd_sdio.c:3922:		si_core_reset(bus->sih, 0, 0);
dhd_sdio.c:3923:		if (bcmsdh_regfail(bus->sdh)) {
dhd_sdio.c:3930:		bus->alp_only = FALSE;
dhd_sdio.c:3932:		bus->dhd->busstate = DHD_BUS_LOAD;
dhd_sdio.c:3937:	if (!si_setcore(bus->sih, PCMCIA_CORE_ID, 0))
dhd_sdio.c:3938:		si_setcore(bus->sih, SDIOD_CORE_ID, 0);
dhd_sdio.c:3947:	dhd_bus_t *bus = dhdp->bus;
dhd_sdio.c:3966:		dhd_os_sdlock(bus->dhd);
dhd_sdio.c:3973:		bcmerror = bcmsdh_iovar_op(bus->sdh, name, params, plen, arg, len, set);
dhd_sdio.c:3979:			if (bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
dhd_sdio.c:3980:			                    &bus->sd_divisor, sizeof(int32), FALSE) != BCME_OK) {
dhd_sdio.c:3981:				bus->sd_divisor = -1;
dhd_sdio.c:3985:				          __FUNCTION__, name, bus->sd_divisor));
dhd_sdio.c:3990:			if (bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL, 0,
dhd_sdio.c:3991:			                    &bus->sd_mode, sizeof(int32), FALSE) != BCME_OK) {
dhd_sdio.c:3992:				bus->sd_mode = -1;
dhd_sdio.c:3996:				          __FUNCTION__, name, bus->sd_mode));
dhd_sdio.c:4002:			if (bcmsdh_iovar_op(bus->sdh, "sd_blocksize", &fnum, sizeof(int32),
dhd_sdio.c:4003:			                    &bus->blocksize, sizeof(int32), FALSE) != BCME_OK) {
dhd_sdio.c:4004:				bus->blocksize = 0;
dhd_sdio.c:4008:				          __FUNCTION__, "sd_blocksize", bus->blocksize));
dhd_sdio.c:4011:		bus->roundup = MIN(max_roundup, bus->blocksize);
dhd_sdio.c:4013:		if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
dhd_sdio.c:4014:			bus->activity = FALSE;
dhd_sdio.c:4018:		dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:4033:	if (vi->type == IOVT_VOID)
dhd_sdio.c:4035:	else if (vi->type == IOVT_BUFFER)
dhd_sdio.c:4041:	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
dhd_sdio.c:4056:	if (!bus->dhd)
dhd_sdio.c:4059:	osh = bus->dhd->osh;
dhd_sdio.c:4065:		dhd_os_sdlock(bus->dhd);
dhd_sdio.c:4067:	if ((bus->dhd->busstate == DHD_BUS_DOWN) || bus->dhd->hang_was_sent) {
dhd_sdio.c:4069:		bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:4070:		bus->hostintmask = 0;
dhd_sdio.c:4071:		bcmsdh_intr_disable(bus->sdh);
dhd_sdio.c:4077:			dat = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_INTEN, NULL);
dhd_sdio.c:4079:			bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_INTEN, dat, NULL);
dhd_sdio.c:4083:		bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:4091:			W_SDREG(0, &bus->regs->hostintmask, retries);
dhd_sdio.c:4092:			local_hostintmask = bus->hostintmask;
dhd_sdio.c:4093:			bus->hostintmask = 0;
dhd_sdio.c:4096:			saveclk = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
dhd_sdio.c:4098:				bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
dhd_sdio.c:4107:			bcmsdh_intr_disable(bus->sdh);
dhd_sdio.c:4108:			bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1, NULL);
dhd_sdio.c:4111:			W_SDREG(local_hostintmask, &bus->regs->intstatus, retries);
dhd_sdio.c:4119:	pktq_flush(osh, &bus->txq, TRUE, NULL, 0);
dhd_sdio.c:4122:	if (bus->glomd)
dhd_sdio.c:4123:		PKTFREE(osh, bus->glomd, FALSE);
dhd_sdio.c:4125:	if (bus->glom)
dhd_sdio.c:4126:		PKTFREE(osh, bus->glom, FALSE);
dhd_sdio.c:4128:	bus->glom = bus->glomd = NULL;
dhd_sdio.c:4131:	bus->rxlen = 0;
dhd_sdio.c:4132:	dhd_os_ioctl_resp_wake(bus->dhd);
dhd_sdio.c:4135:	bus->rxskip = FALSE;
dhd_sdio.c:4136:	bus->tx_seq = bus->rx_seq = 0;
dhd_sdio.c:4139:		dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:4146:	dhd_bus_t *bus = dhdp->bus;
dhd_sdio.c:4162:			bus->glom_enable = TRUE;
dhd_sdio.c:4165:		bus->glom_enable = FALSE;
dhd_sdio.c:4173:	dhd_bus_t *bus = dhdp->bus;
dhd_sdio.c:4182:	ASSERT(bus->dhd);
dhd_sdio.c:4183:	if (!bus->dhd)
dhd_sdio.c:4187:		dhd_os_sdlock(bus->dhd);
dhd_sdio.c:4191:	if (bus->clkstate != CLK_AVAIL) {
dhd_sdio.c:4192:		DHD_ERROR(("%s: clock state is wrong. state = %d\n", __FUNCTION__, bus->clkstate));
dhd_sdio.c:4193:		ret = -1;
dhd_sdio.c:4199:	saveclk = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
dhd_sdio.c:4201:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
dhd_sdio.c:4206:		ret = -1;
dhd_sdio.c:4212:	        &bus->regs->tosbmailboxdata, retries);
dhd_sdio.c:4215:	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, enable, NULL);
dhd_sdio.c:4222:	        ready = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IORDY, NULL);
dhd_sdio.c:4231:		if (!(bus->regs = si_setcore(bus->sih, PCMCIA_CORE_ID, 0)))
dhd_sdio.c:4232:			bus->regs = si_setcore(bus->sih, SDIOD_CORE_ID, 0);
dhd_sdio.c:4233:		ASSERT(bus->regs != NULL);
dhd_sdio.c:4236:		bus->hostintmask = HOSTINTMASK;
dhd_sdio.c:4238:		if ((bus->sih->buscoretype == SDIOD_CORE_ID) && (bus->sdpcmrev == 4) &&
dhd_sdio.c:4239:			(bus->rxint_mode != SDIO_DEVICE_HMB_RXINT)) {
dhd_sdio.c:4240:			bus->hostintmask &= ~I_HMB_FRAME_IND;
dhd_sdio.c:4241:			bus->hostintmask |= I_XMTDATA_AVAIL;
dhd_sdio.c:4243:		W_SDREG(bus->hostintmask, &bus->regs->hostintmask, retries);
dhd_sdio.c:4245:		if (bus->blocksize < 512) {
dhd_sdio.c:4246:			mesbusyctrl = watermark = bus->blocksize / 4;
dhd_sdio.c:4250:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK, (uint8)watermark, &err);
dhd_sdio.c:4252:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_MESBUSYCTRL,
dhd_sdio.c:4254:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
dhd_sdio.c:4259:		dhdp->busstate = DHD_BUS_DATA;
dhd_sdio.c:4261:		/* bcmsdh_intr_unmask(bus->sdh); */
dhd_sdio.c:4263:		bus->intdis = FALSE;
dhd_sdio.c:4264:		if (bus->intr) {
dhd_sdio.c:4266:			bcmsdh_intr_enable(bus->sdh);
dhd_sdio.c:4269:			bcmsdh_intr_disable(bus->sdh);
dhd_sdio.c:4278:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, enable, NULL);
dhd_sdio.c:4284:		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1,
dhd_sdio.c:4288:	if (dhdp->busstate != DHD_BUS_DATA)
dhd_sdio.c:4293:		dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:4301:	bcmsdh_info_t *sdh = bus->sdh;
dhd_sdio.c:4302:	sdpcmd_regs_t *regs = bus->regs;
dhd_sdio.c:4321:	bus->f1regdata++;
dhd_sdio.c:4324:	for (lastrbc = retries = 0xffff; retries > 0; retries--) {
dhd_sdio.c:4327:		bus->f1regdata += 2;
dhd_sdio.c:4342:		DHD_INFO(("%s: flush took %d iterations\n", __FUNCTION__, (0xffff - retries)));
dhd_sdio.c:4346:		bus->rxrtx++;
dhd_sdio.c:4347:		W_SDREG(SMB_NAK, &regs->tosbmailbox, retries);
dhd_sdio.c:4348:		bus->f1regdata++;
dhd_sdio.c:4350:			bus->rxskip = TRUE;
dhd_sdio.c:4355:	bus->nextlen = 0;
dhd_sdio.c:4359:		bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:4365:	bcmsdh_info_t *sdh = bus->sdh;
dhd_sdio.c:4373:	if ((bus->bus == SPI_BUS) && (!bus->usebufpool))
dhd_sdio.c:4376:	ASSERT(bus->rxbuf);
dhd_sdio.c:4378:	bus->rxctl = bus->rxbuf;
dhd_sdio.c:4380:		bus->rxctl += firstread;
dhd_sdio.c:4381:		if ((pad = ((uintptr)bus->rxctl % DHD_SDALIGN)))
dhd_sdio.c:4382:			bus->rxctl += (DHD_SDALIGN - pad);
dhd_sdio.c:4383:		bus->rxctl -= firstread;
dhd_sdio.c:4385:	ASSERT(bus->rxctl >= bus->rxbuf);
dhd_sdio.c:4387:	/* Copy the already-read portion over */
dhd_sdio.c:4388:	bcopy(hdr, bus->rxctl, firstread);
dhd_sdio.c:4393:	if (bus->bus == SPI_BUS) {
dhd_sdio.c:4394:		bcopy(hdr, bus->rxctl, len);
dhd_sdio.c:4399:	rdlen = len - firstread;
dhd_sdio.c:4400:	if (bus->roundup && bus->blocksize && (rdlen > bus->blocksize)) {
dhd_sdio.c:4401:		pad = bus->blocksize - (rdlen % bus->blocksize);
dhd_sdio.c:4402:		if ((pad <= bus->roundup) && (pad < bus->blocksize) &&
dhd_sdio.c:4403:		    ((len + pad) < bus->dhd->maxctl))
dhd_sdio.c:4406:		rdlen += DHD_SDALIGN - (rdlen % DHD_SDALIGN);
dhd_sdio.c:4409:	/* Satisfy length-alignment requirements */
dhd_sdio.c:4410:	if (forcealign && (rdlen & (ALIGNMENT - 1)))
dhd_sdio.c:4414:	if ((rdlen + firstread) > bus->dhd->maxctl) {
dhd_sdio.c:4415:		DHD_ERROR(("%s: %d-byte control read exceeds %d-byte buffer\n",
dhd_sdio.c:4416:		           __FUNCTION__, rdlen, bus->dhd->maxctl));
dhd_sdio.c:4417:		bus->dhd->rx_errors++;
dhd_sdio.c:4422:	if ((len - doff) > bus->dhd->maxctl) {
dhd_sdio.c:4423:		DHD_ERROR(("%s: %d-byte ctl frame (%d-byte ctl data) exceeds %d-byte limit\n",
dhd_sdio.c:4424:		           __FUNCTION__, len, (len - doff), bus->dhd->maxctl));
dhd_sdio.c:4425:		bus->dhd->rx_errors++; bus->rx_toolong++;
dhd_sdio.c:4433:	                            (bus->rxctl + firstread), rdlen, NULL, NULL, NULL);
dhd_sdio.c:4434:	bus->f2rxdata++;
dhd_sdio.c:4440:		bus->rxc_errors++; /* dhd.rx_ctlerrs is higher level */
dhd_sdio.c:4449:		prhex("RxCtrl", bus->rxctl, len);
dhd_sdio.c:4454:	bus->rxctl += doff;
dhd_sdio.c:4455:	bus->rxlen = len - doff;
dhd_sdio.c:4459:	dhd_os_ioctl_resp_wake(bus->dhd);
dhd_sdio.c:4473:	osl_t *osh = bus->dhd->osh;
dhd_sdio.c:4482:	bool usechain = bus->use_rxchain;
dhd_sdio.c:4487:	DHD_TRACE(("dhdsdio_rxglom: start: glomd %p glom %p\n", bus->glomd, bus->glom));
dhd_sdio.c:4490:	if (bus->glomd) {
dhd_sdio.c:4491:		dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:4494:		dlen = (uint16)PKTLEN(osh, bus->glomd);
dhd_sdio.c:4495:		dptr = PKTDATA(osh, bus->glomd);
dhd_sdio.c:4505:			dlen -= sizeof(uint16);
dhd_sdio.c:4523:				sublen += (ROUNDUP(totlen, bus->blocksize) - totlen);
dhd_sdio.c:4524:				totlen = ROUNDUP(totlen, bus->blocksize);
dhd_sdio.c:4549:			DHD_GLOM(("%s: allocated %d-byte packet chain for %d subframes\n",
dhd_sdio.c:4551:			if (DHD_GLOM_ON() && bus->nextlen) {
dhd_sdio.c:4552:				if (totlen != bus->nextlen) {
dhd_sdio.c:4554:					          "rxseq %d\n", __FUNCTION__, bus->nextlen,
dhd_sdio.c:4558:			bus->glom = pfirst;
dhd_sdio.c:4563:			bus->glom = NULL;
dhd_sdio.c:4568:		PKTFREE(osh, bus->glomd, FALSE);
dhd_sdio.c:4569:		bus->glomd = NULL;
dhd_sdio.c:4570:		bus->nextlen = 0;
dhd_sdio.c:4572:		dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:4575:	/* Ok -- either we just generated a packet chain, or had one from before */
dhd_sdio.c:4576:	if (bus->glom) {
dhd_sdio.c:4579:			for (pnext = bus->glom; pnext; pnext = PKTNEXT(osh, pnext)) {
dhd_sdio.c:4586:		pfirst = bus->glom;
dhd_sdio.c:4595:			                              bcmsdh_cur_sbwad(bus->sdh), SDIO_FUNC_2,
dhd_sdio.c:4598:		} else if (bus->dataptr) {
dhd_sdio.c:4600:			                              bcmsdh_cur_sbwad(bus->sdh), SDIO_FUNC_2,
dhd_sdio.c:4601:			                              F2SYNC, bus->dataptr,
dhd_sdio.c:4603:			sublen = (uint16)pktfrombuf(osh, pfirst, 0, dlen, bus->dataptr);
dhd_sdio.c:4607:				errcode = -1;
dhd_sdio.c:4611:			DHD_ERROR(("COULDN'T ALLOC %d-BYTE GLOM, FORCE FAILURE\n", dlen));
dhd_sdio.c:4612:			errcode = -1;
dhd_sdio.c:4614:		bus->f2rxdata++;
dhd_sdio.c:4621:			bus->dhd->rx_errors++;
dhd_sdio.c:4623:			if (bus->glomerr++ < 3) {
dhd_sdio.c:4626:				bus->glomerr = 0;
dhd_sdio.c:4628:				dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:4629:				PKTFREE(osh, bus->glom, FALSE);
dhd_sdio.c:4630:				dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:4631:				bus->rxglomfail++;
dhd_sdio.c:4632:				bus->glom = NULL;
dhd_sdio.c:4652:		bus->nextlen = dptr[SDPCM_FRAMETAG_LEN + SDPCM_NEXTLEN_OFFSET];
dhd_sdio.c:4653:		if ((bus->nextlen << 4) > MAX_RX_DATASZ) {
dhd_sdio.c:4655:			          __FUNCTION__, bus->nextlen, seq));
dhd_sdio.c:4656:			bus->nextlen = 0;
dhd_sdio.c:4665:			errcode = -1;
dhd_sdio.c:4666:		} else if (ROUNDUP(sublen, bus->blocksize) != dlen) {
dhd_sdio.c:4668:			           __FUNCTION__, sublen, ROUNDUP(sublen, bus->blocksize), dlen));
dhd_sdio.c:4669:			errcode = -1;
dhd_sdio.c:4673:			errcode = -1;
dhd_sdio.c:4676:			errcode = -1;
dhd_sdio.c:4678:		           (doff > (PKTLEN(osh, pfirst) - SDPCM_HDRLEN_RX))) {
dhd_sdio.c:4682:			errcode = -1;
dhd_sdio.c:4689:			bus->rx_badseq++;
dhd_sdio.c:4694:		if ((uint8)(txmax - bus->tx_seq) > 0x40) {
dhd_sdio.c:4696:			           __FUNCTION__, txmax, bus->tx_seq));
dhd_sdio.c:4697:			txmax = bus->tx_max;
dhd_sdio.c:4699:		bus->tx_max = txmax;
dhd_sdio.c:4724:				errcode = -1;
dhd_sdio.c:4729:				errcode = -1;
dhd_sdio.c:4734:				errcode = -1;
dhd_sdio.c:4738:				errcode = -1;
dhd_sdio.c:4744:			if (bus->glomerr++ < 3) {
dhd_sdio.c:4749:				bus->glomerr = 0;
dhd_sdio.c:4751:				dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:4752:				PKTFREE(osh, bus->glom, FALSE);
dhd_sdio.c:4753:				dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:4754:				bus->rxglomfail++;
dhd_sdio.c:4755:				bus->glom = NULL;
dhd_sdio.c:4757:			bus->nextlen = 0;
dhd_sdio.c:4761:		/* Basic SD framing looks ok - process each packet (header) */
dhd_sdio.c:4762:		bus->glom = NULL;
dhd_sdio.c:4765:		dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:4785:				bus->rx_badseq++;
dhd_sdio.c:4801:				PKTFREE(bus->dhd->osh, pfirst, FALSE);
dhd_sdio.c:4803:			} else if (dhd_prot_hdrpull(bus->dhd, &ifidx, pfirst, reorder_info_buf,
dhd_sdio.c:4806:				bus->dhd->rx_errors++;
dhd_sdio.c:4816:				dhd_process_pkt_reorder_info(bus->dhd, reorder_info_buf,
dhd_sdio.c:4866:		dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:4878:					dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:4879:					dhd_rx_frame(bus->dhd, idx, list_head[idx], cnt, 0);
dhd_sdio.c:4880:					dhd_os_sdlock(bus->dhd);
dhd_sdio.c:4884:		bus->rxglomframes++;
dhd_sdio.c:4885:		bus->rxglompkts += num;
dhd_sdio.c:4895:	osl_t *osh = bus->dhd->osh;
dhd_sdio.c:4896:	bcmsdh_info_t *sdh = bus->sdh;
dhd_sdio.c:4910:	bool len_consistent; /* Result of comparing readahead len and len from hw-hdr */
dhd_sdio.c:4924:	bus->readframes = TRUE;
dhd_sdio.c:4928:		bus->readframes = FALSE;
dhd_sdio.c:4936:	if (bus->pktgen_count && (bus->pktgen_mode == DHD_PKTGEN_RECV)) {
dhd_sdio.c:4937:		maxframes = bus->pktgen_count;
dhd_sdio.c:4946:	for (rxseq = bus->rx_seq, rxleft = maxframes;
dhd_sdio.c:4947:	     !bus->rxskip && rxleft && bus->dhd->busstate != DHD_BUS_DOWN;
dhd_sdio.c:4948:	     rxseq++, rxleft--) {
dhd_sdio.c:4952:		if (bus->sih->chip!=BCM43362_CHIP_ID && bus->sih->chiprev!=BCM43362A0_CHIP_REV) {
dhd_sdio.c:4954:			if ((bus->clkstate == CLK_AVAIL) && !bus->fcstate &&
dhd_sdio.c:4955:				pktq_mlen(&bus->txq, ~bus->flowcontrol) && DATAOK(bus)) {
dhd_sdio.c:4962:		if (bus->glom || bus->glomd) {
dhd_sdio.c:4965:			          __FUNCTION__, bus->glomd, bus->glom));
dhd_sdio.c:4968:			rxseq += cnt - 1;
dhd_sdio.c:4969:			rxleft = (rxleft > cnt) ? (rxleft - cnt) : 1;
dhd_sdio.c:4974:		if (dhd_readahead && bus->nextlen) {
dhd_sdio.c:4975:			uint16 nextlen = bus->nextlen;
dhd_sdio.c:4976:			bus->nextlen = 0;
dhd_sdio.c:4978:			if (bus->bus == SPI_BUS) {
dhd_sdio.c:4985:				if (bus->roundup && bus->blocksize && (rdlen > bus->blocksize)) {
dhd_sdio.c:4986:					pad = bus->blocksize - (rdlen % bus->blocksize);
dhd_sdio.c:4987:					if ((pad <= bus->roundup) && (pad < bus->blocksize) &&
dhd_sdio.c:4991:					rdlen += DHD_SDALIGN - (rdlen % DHD_SDALIGN);
dhd_sdio.c:4995:			/* We use bus->rxctl buffer in WinXP for initial control pkt receives.
dhd_sdio.c:4996:			 * Later we use buffer-poll for data as well as control packets.
dhd_sdio.c:4999:			 * or non-data frame.
dhd_sdio.c:5002:			dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5004:				if (bus->bus == SPI_BUS) {
dhd_sdio.c:5005:					bus->usebufpool = FALSE;
dhd_sdio.c:5006:					bus->rxctl = bus->rxbuf;
dhd_sdio.c:5008:						bus->rxctl += firstread;
dhd_sdio.c:5009:						if ((pad = ((uintptr)bus->rxctl % DHD_SDALIGN)))
dhd_sdio.c:5010:							bus->rxctl += (DHD_SDALIGN - pad);
dhd_sdio.c:5011:						bus->rxctl -= firstread;
dhd_sdio.c:5013:					ASSERT(bus->rxctl >= bus->rxbuf);
dhd_sdio.c:5014:					rxbuf = bus->rxctl;
dhd_sdio.c:5021:					bus->f2rxdata++;
dhd_sdio.c:5030:						bus->rxc_errors++;
dhd_sdio.c:5031:						dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5033:						    (bus->bus == SPI_BUS) ? FALSE : TRUE);
dhd_sdio.c:5042:					dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5046:				if (bus->bus == SPI_BUS)
dhd_sdio.c:5047:					bus->usebufpool = TRUE;
dhd_sdio.c:5057:				bus->f2rxdata++;
dhd_sdio.c:5063:					PKTFREE(bus->dhd->osh, pkt, FALSE);
dhd_sdio.c:5064:					bus->dhd->rx_errors++;
dhd_sdio.c:5065:					dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5070:					      (bus->bus == SPI_BUS) ? FALSE : TRUE);
dhd_sdio.c:5074:			dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5077:			bcopy(rxbuf, bus->rxhdr, SDPCM_HDRLEN_RX);
dhd_sdio.c:5080:			len = ltoh16_ua(bus->rxhdr);
dhd_sdio.c:5081:			check = ltoh16_ua(bus->rxhdr + sizeof(uint16));
dhd_sdio.c:5087:				dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5089:				dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5099:				dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5101:				dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5102:				bus->rx_badhdr++;
dhd_sdio.c:5112:				dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5114:				dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5126:				dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5128:				dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5129:				dhdsdio_rxfail(bus, TRUE, (bus->bus == SPI_BUS) ? FALSE : TRUE);
dhd_sdio.c:5136:			chan = SDPCM_PACKET_CHANNEL(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5137:			seq = SDPCM_PACKET_SEQUENCE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5138:			doff = SDPCM_DOFFSET_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5139:			txmax = SDPCM_WINDOW_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5141:				bus->nextlen =
dhd_sdio.c:5142:				         bus->rxhdr[SDPCM_FRAMETAG_LEN + SDPCM_NEXTLEN_OFFSET];
dhd_sdio.c:5143:				if ((bus->nextlen << 4) > MAX_RX_DATASZ) {
dhd_sdio.c:5145:					          " (%d), seq %d\n", __FUNCTION__, bus->nextlen,
dhd_sdio.c:5147:					bus->nextlen = 0;
dhd_sdio.c:5150:				bus->dhd->rx_readahead_cnt ++;
dhd_sdio.c:5152:			fcbits = SDPCM_FCMASK_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5155:			if (~bus->flowcontrol & fcbits) {
dhd_sdio.c:5156:				bus->fc_xoff++;
dhd_sdio.c:5159:			if (bus->flowcontrol & ~fcbits) {
dhd_sdio.c:5160:				bus->fc_xon++;
dhd_sdio.c:5165:				bus->fc_rcvd++;
dhd_sdio.c:5166:				bus->flowcontrol = fcbits;
dhd_sdio.c:5173:				bus->rx_badseq++;
dhd_sdio.c:5178:			if ((uint8)(txmax - bus->tx_seq) > 0x40) {
dhd_sdio.c:5180:						__FUNCTION__, txmax, bus->tx_seq));
dhd_sdio.c:5181:					txmax = bus->tx_max;
dhd_sdio.c:5183:			bus->tx_max = txmax;
dhd_sdio.c:5189:				prhex("RxHdr", bus->rxhdr, SDPCM_HDRLEN_RX);
dhd_sdio.c:5194:				if (bus->bus == SPI_BUS) {
dhd_sdio.c:5196:					if (bus->usebufpool) {
dhd_sdio.c:5197:						dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5198:						PKTFREE(bus->dhd->osh, pkt, FALSE);
dhd_sdio.c:5199:						dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5206:					bus->nextlen = 0;
dhd_sdio.c:5208:					dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5210:					dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5215:			if ((bus->bus == SPI_BUS) && !bus->usebufpool) {
dhd_sdio.c:5225:				dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5227:				dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5233:			/* All done with this one -- now deliver the packet */
dhd_sdio.c:5237:		if (bus->bus == SPI_BUS) {
dhd_sdio.c:5243:		                            bus->rxhdr, firstread, NULL, NULL, NULL);
dhd_sdio.c:5244:		bus->f2rxhdrs++;
dhd_sdio.c:5249:			bus->rx_hdrfail++;
dhd_sdio.c:5256:			prhex("RxHdr", bus->rxhdr, SDPCM_HDRLEN_RX);
dhd_sdio.c:5261:		len = ltoh16_ua(bus->rxhdr);
dhd_sdio.c:5262:		check = ltoh16_ua(bus->rxhdr + sizeof(uint16));
dhd_sdio.c:5274:			bus->rx_badhdr++;
dhd_sdio.c:5286:		chan = SDPCM_PACKET_CHANNEL(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5287:		seq = SDPCM_PACKET_SEQUENCE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5288:		doff = SDPCM_DOFFSET_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5289:		txmax = SDPCM_WINDOW_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5295:			bus->rx_badhdr++;
dhd_sdio.c:5302:		bus->nextlen = bus->rxhdr[SDPCM_FRAMETAG_LEN + SDPCM_NEXTLEN_OFFSET];
dhd_sdio.c:5303:		if ((bus->nextlen << 4) > MAX_RX_DATASZ) {
dhd_sdio.c:5305:			          __FUNCTION__, bus->nextlen, seq));
dhd_sdio.c:5306:			bus->nextlen = 0;
dhd_sdio.c:5310:		fcbits = SDPCM_FCMASK_VALUE(&bus->rxhdr[SDPCM_FRAMETAG_LEN]);
dhd_sdio.c:5313:		if (~bus->flowcontrol & fcbits) {
dhd_sdio.c:5314:			bus->fc_xoff++;
dhd_sdio.c:5317:		if (bus->flowcontrol & ~fcbits) {
dhd_sdio.c:5318:			bus->fc_xon++;
dhd_sdio.c:5323:			bus->fc_rcvd++;
dhd_sdio.c:5324:			bus->flowcontrol = fcbits;
dhd_sdio.c:5330:			bus->rx_badseq++;
dhd_sdio.c:5335:		if ((uint8)(txmax - bus->tx_seq) > 0x40) {
dhd_sdio.c:5337:			           __FUNCTION__, txmax, bus->tx_seq));
dhd_sdio.c:5338:			txmax = bus->tx_max;
dhd_sdio.c:5340:		bus->tx_max = txmax;
dhd_sdio.c:5344:			dhdsdio_read_control(bus, bus->rxhdr, len, doff);
dhd_sdio.c:5352:		rdlen = (len > firstread) ? (len - firstread) : 0;
dhd_sdio.c:5355:		if (bus->roundup && bus->blocksize && (rdlen > bus->blocksize)) {
dhd_sdio.c:5356:			pad = bus->blocksize - (rdlen % bus->blocksize);
dhd_sdio.c:5357:			if ((pad <= bus->roundup) && (pad < bus->blocksize) &&
dhd_sdio.c:5361:			rdlen += DHD_SDALIGN - (rdlen % DHD_SDALIGN);
dhd_sdio.c:5364:		/* Satisfy length-alignment requirements */
dhd_sdio.c:5365:		if (forcealign && (rdlen & (ALIGNMENT - 1)))
dhd_sdio.c:5369:			/* Too long -- skip this frame */
dhd_sdio.c:5371:			bus->dhd->rx_errors++; bus->rx_toolong++;
dhd_sdio.c:5376:		dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5381:			bus->dhd->rx_dropped++;
dhd_sdio.c:5382:			dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5386:		dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5398:		bus->f2rxdata++;
dhd_sdio.c:5405:			dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5406:			PKTFREE(bus->dhd->osh, pkt, FALSE);
dhd_sdio.c:5407:			dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5408:			bus->dhd->rx_errors++;
dhd_sdio.c:5413:		/* Copy the already-read portion */
dhd_sdio.c:5415:		bcopy(bus->rxhdr, PKTDATA(osh, pkt), firstread);
dhd_sdio.c:5426:			if (SDPCM_GLOMDESC(&bus->rxhdr[SDPCM_FRAMETAG_LEN])) {
dhd_sdio.c:5437:				bus->glomd = pkt;
dhd_sdio.c:5458:			dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5459:			PKTFREE(bus->dhd->osh, pkt, FALSE);
dhd_sdio.c:5460:			dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5462:		} else if (dhd_prot_hdrpull(bus->dhd, &ifidx, pkt, reorder_info_buf,
dhd_sdio.c:5465:			dhd_os_sdlock_rxq(bus->dhd);
dhd_sdio.c:5466:			PKTFREE(bus->dhd->osh, pkt, FALSE);
dhd_sdio.c:5467:			dhd_os_sdunlock_rxq(bus->dhd);
dhd_sdio.c:5468:			bus->dhd->rx_errors++;
dhd_sdio.c:5473:			dhd_process_pkt_reorder_info(bus->dhd, reorder_info_buf, reorder_info_len,
dhd_sdio.c:5483:		dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:5484:		dhd_rx_frame(bus->dhd, ifidx, pkt, pkt_count, chan);
dhd_sdio.c:5485:		dhd_os_sdlock(bus->dhd);
dhd_sdio.c:5487:	rxcount = maxframes - rxleft;
dhd_sdio.c:5496:	if (bus->rxskip)
dhd_sdio.c:5497:		rxseq--;
dhd_sdio.c:5498:	bus->rx_seq = rxseq;
dhd_sdio.c:5500:	if (bus->reqbussleep)
dhd_sdio.c:5503:		bus->reqbussleep = FALSE;
dhd_sdio.c:5505:	bus->readframes = FALSE;
dhd_sdio.c:5513:	sdpcmd_regs_t *regs = bus->regs;
dhd_sdio.c:5522:	R_SDREG(hmb_data, &regs->tohostmailboxdata, retries);
dhd_sdio.c:5524:		W_SDREG(SMB_INT_ACK, &regs->tosbmailbox, retries);
dhd_sdio.c:5525:	bus->f1regdata += 2;
dhd_sdio.c:5529:		DHD_INFO(("Dongle reports NAK handled, expect rtx of %d\n", bus->rx_seq));
dhd_sdio.c:5530:		if (!bus->rxskip) {
dhd_sdio.c:5533:		bus->rxskip = FALSE;
dhd_sdio.c:5541:		bus->sdpcm_ver = (hmb_data & HMB_DATA_VERSION_MASK) >> HMB_DATA_VERSION_SHIFT;
dhd_sdio.c:5542:		if (bus->sdpcm_ver != SDPCM_PROT_VERSION)
dhd_sdio.c:5544:			           bus->sdpcm_ver, SDPCM_PROT_VERSION));
dhd_sdio.c:5546:			DHD_INFO(("Dongle ready, protocol version %d\n", bus->sdpcm_ver));
dhd_sdio.c:5548:		if ((bus->sih->buscoretype == SDIOD_CORE_ID) && (bus->sdpcmrev >= 4) &&
dhd_sdio.c:5549:		    (bus->rxint_mode  == SDIO_DEVICE_RXDATAINT_MODE_1)) {
dhd_sdio.c:5552:			val = R_REG(bus->dhd->osh, &bus->regs->corecontrol);
dhd_sdio.c:5555:			W_REG(bus->dhd->osh, &bus->regs->corecontrol, val);
dhd_sdio.c:5557:			val = R_REG(bus->dhd->osh, &bus->regs->corecontrol);
dhd_sdio.c:5565:				bus->console_addr = shared.console_addr;
dhd_sdio.c:5578:		if (fcbits & ~bus->flowcontrol)
dhd_sdio.c:5579:			bus->fc_xoff++;
dhd_sdio.c:5580:		if (bus->flowcontrol & ~fcbits)
dhd_sdio.c:5581:			bus->fc_xon++;
dhd_sdio.c:5583:		bus->fc_rcvd++;
dhd_sdio.c:5584:		bus->flowcontrol = fcbits;
dhd_sdio.c:5592:		bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:5613:	bcmsdh_info_t *sdh = bus->sdh;
dhd_sdio.c:5614:	sdpcmd_regs_t *regs = bus->regs;
dhd_sdio.c:5625:	if (bus->dhd->busstate == DHD_BUS_DOWN) {
dhd_sdio.c:5627:		bus->intstatus = 0;
dhd_sdio.c:5632:	intstatus = bus->intstatus;
dhd_sdio.c:5634:	dhd_os_sdlock(bus->dhd);
dhd_sdio.c:5642:	if (!SLPAUTO_ENAB(bus) && (bus->clkstate == CLK_PENDING)) {
dhd_sdio.c:5651:			bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:5661:			bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:5671:				bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:5678:				bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:5680:			bus->clkstate = CLK_AVAIL;
dhd_sdio.c:5690:	if (bus->clkstate != CLK_AVAIL)
dhd_sdio.c:5694:	if (bus->ipend) {
dhd_sdio.c:5695:		bus->ipend = FALSE;
dhd_sdio.c:5696:		R_SDREG(newstatus, &regs->intstatus, retries);
dhd_sdio.c:5697:		bus->f1regdata++;
dhd_sdio.c:5698:		if (bcmsdh_regfail(bus->sdh))
dhd_sdio.c:5700:		newstatus &= bus->hostintmask;
dhd_sdio.c:5701:		bus->fcstate = !!(newstatus & I_HMB_FC_STATE);
dhd_sdio.c:5703:			bus->f1regdata++;
dhd_sdio.c:5704:			if ((bus->rxint_mode == SDIO_DEVICE_RXDATAINT_MODE_0) &&
dhd_sdio.c:5708:				W_SDREG(newstatus, &regs->intstatus, retries);
dhd_sdio.c:5714:	bus->intstatus = 0;
dhd_sdio.c:5716:	/* Handle flow-control change: read new state in case our ack
dhd_sdio.c:5722:		W_SDREG(I_HMB_FC_CHANGE, &regs->intstatus, retries);
dhd_sdio.c:5723:		R_SDREG(newstatus, &regs->intstatus, retries);
dhd_sdio.c:5724:		bus->f1regdata += 2;
dhd_sdio.c:5725:		bus->fcstate = !!(newstatus & (I_HMB_FC_STATE | I_HMB_FC_CHANGE));
dhd_sdio.c:5726:		intstatus |= (newstatus & bus->hostintmask);
dhd_sdio.c:5731:		/* ASSERT(bus->clkstate == CLK_AVAIL); */
dhd_sdio.c:5757:	/* Would be active due to wake-wlan in gSPI */
dhd_sdio.c:5764:	if (bus->rxskip) {
dhd_sdio.c:5771:		if (rxdone || bus->rxskip)
dhd_sdio.c:5773:		rxlimit -= MIN(framecnt, rxlimit);
dhd_sdio.c:5776:	/* Keep still-pending events for next scheduling */
dhd_sdio.c:5777:	bus->intstatus = intstatus;
dhd_sdio.c:5780:	/* Re-enable interrupts to detect new device events (mailbox, rx frame)
dhd_sdio.c:5784:	if (bus->intr && bus->intdis && !bcmsdh_regfail(sdh)) {
dhd_sdio.c:5787:		bus->intdis = FALSE;
dhd_sdio.c:5795:	/* In case of SW-OOB(using edge trigger),
dhd_sdio.c:5799:	 * No need to do this with HW-OOB(level trigger)
dhd_sdio.c:5801:	R_SDREG(newstatus, &regs->intstatus, retries);
dhd_sdio.c:5802:	if (bcmsdh_regfail(bus->sdh))
dhd_sdio.c:5804:	if (newstatus & bus->hostintmask) {
dhd_sdio.c:5805:		bus->ipend = TRUE;
dhd_sdio.c:5810:	dhd_wlfc_trigger_pktcommit(bus->dhd);
dhd_sdio.c:5812:	if (TXCTLOK(bus) && bus->ctrl_frame_stat && (bus->clkstate == CLK_AVAIL))  {
dhd_sdio.c:5815:		uint8* frame_seq = bus->ctrl_frame_buf + SDPCM_FRAMETAG_LEN;
dhd_sdio.c:5817:		if (*frame_seq != bus->tx_seq) {
dhd_sdio.c:5819:				" frm_seq:%d != bus->tx_seq:%d, corrected\n",
dhd_sdio.c:5820:				__FUNCTION__, *frame_seq, bus->tx_seq));
dhd_sdio.c:5821:			*frame_seq = bus->tx_seq;
dhd_sdio.c:5825:		                      (uint8 *)bus->ctrl_frame_buf, (uint32)bus->ctrl_frame_len,
dhd_sdio.c:5834:			bus->tx_sderrs++;
dhd_sdio.c:5840:			bus->f1regdata++;
dhd_sdio.c:5848:				bus->f1regdata += 2;
dhd_sdio.c:5854:			bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
dhd_sdio.c:5857:		bus->ctrl_frame_stat = FALSE;
dhd_sdio.c:5858:		dhd_wait_event_wakeup(bus->dhd);
dhd_sdio.c:5861:	else if ((bus->clkstate == CLK_AVAIL) && !bus->fcstate &&
dhd_sdio.c:5862:	    pktq_mlen(&bus->txq, ~bus->flowcontrol) && txlimit && DATAOK(bus)) {
dhd_sdio.c:5865:		txlimit -= framecnt;
dhd_sdio.c:5868:	if (bus->ctrl_frame_stat)
dhd_sdio.c:5873:	if ((bus->dhd->busstate == DHD_BUS_DOWN) || bcmsdh_regfail(sdh)) {
dhd_sdio.c:5874:		if ((bus->sih && bus->sih->buscorerev >= 12) && !(dhdsdio_sleepcsr_get(bus) &
dhd_sdio.c:5878:			bus->kso = FALSE;
dhd_sdio.c:5882:			bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:5883:			bus->intstatus = 0;
dhd_sdio.c:5885:	} else if (bus->clkstate == CLK_PENDING) {
dhd_sdio.c:5887:	} else if (bus->intstatus || bus->ipend ||
dhd_sdio.c:5888:	           (!bus->fcstate && pktq_mlen(&bus->txq, ~bus->flowcontrol) && DATAOK(bus)) ||
dhd_sdio.c:5889:			PKT_AVAILABLE(bus, bus->intstatus)) {  /* Read multiple frames */
dhd_sdio.c:5893:	bus->dpc_sched = resched;
dhd_sdio.c:5896:	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && (bus->clkstate != CLK_PENDING)) {
dhd_sdio.c:5897:		bus->activity = FALSE;
dhd_sdio.c:5902:	dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:5930:	sdh = bus->sdh;
dhd_sdio.c:5932:	if (bus->dhd->busstate == DHD_BUS_DOWN) {
dhd_sdio.c:5940:	bus->intrcount++;
dhd_sdio.c:5941:	bus->ipend = TRUE;
dhd_sdio.c:5945:		if (bus->sleeping) {
dhd_sdio.c:5954:	if (bus->intr) {
dhd_sdio.c:5961:	bus->intdis = TRUE;
dhd_sdio.c:5965:	DHD_OS_WAKE_LOCK(bus->dhd);
dhd_sdio.c:5967:	DHD_OS_WAKE_UNLOCK(bus->dhd);
dhd_sdio.c:5969:	bus->dpc_sched = TRUE;
dhd_sdio.c:5970:	dhd_sched_dpc(bus->dhd);
dhd_sdio.c:5981:		bus->pktgen_maxlen = MIN(dhd_pktgen_len, MAX_PKTGEN_LEN);
dhd_sdio.c:5982:		bus->pktgen_minlen = bus->pktgen_maxlen;
dhd_sdio.c:5984:		bus->pktgen_maxlen = MAX_PKTGEN_LEN;
dhd_sdio.c:5985:		bus->pktgen_minlen = 0;
dhd_sdio.c:5987:	bus->pktgen_len = (uint16)bus->pktgen_minlen;
dhd_sdio.c:5989:	/* Default to per-watchdog burst with 10s print time */
dhd_sdio.c:5990:	bus->pktgen_freq = 1;
dhd_sdio.c:5991:	bus->pktgen_print = dhd_watchdog_ms ? (10000/dhd_watchdog_ms):0;
dhd_sdio.c:5992:	bus->pktgen_count = (dhd_pktgen * dhd_watchdog_ms + 999) / 1000;
dhd_sdio.c:5995:	bus->pktgen_mode = DHD_PKTGEN_ECHO;
dhd_sdio.c:5996:	bus->pktgen_stop = 1;
dhd_sdio.c:6006:	osl_t *osh = bus->dhd->osh;
dhd_sdio.c:6013:	if (bus->pktgen_print && (++bus->pktgen_ptick >= bus->pktgen_print)) {
dhd_sdio.c:6014:		bus->pktgen_ptick = 0;
dhd_sdio.c:6016:		       __FUNCTION__, bus->pktgen_sent, bus->pktgen_rcvd, bus->pktgen_fail);
dhd_sdio.c:6019:		if (bus->pktgen_minlen == bus->pktgen_maxlen) {
dhd_sdio.c:6020:			time_lapse = jiffies - bus->pktgen_prev_time;
dhd_sdio.c:6021:			bus->pktgen_prev_time = jiffies;
dhd_sdio.c:6022:			sent_pkts = bus->pktgen_sent - bus->pktgen_prev_sent;
dhd_sdio.c:6023:			bus->pktgen_prev_sent = bus->pktgen_sent;
dhd_sdio.c:6024:			rcvd_pkts = bus->pktgen_rcvd - bus->pktgen_prev_rcvd;
dhd_sdio.c:6025:			bus->pktgen_prev_rcvd = bus->pktgen_rcvd;
dhd_sdio.c:6029:			  (sent_pkts * bus->pktgen_len / jiffies_to_msecs(time_lapse)) * 8,
dhd_sdio.c:6030:			  (rcvd_pkts * bus->pktgen_len  / jiffies_to_msecs(time_lapse)) * 8);
dhd_sdio.c:6035:	if (bus->pktgen_mode == DHD_PKTGEN_RECV) {
dhd_sdio.c:6036:		if (bus->pktgen_rcv_state == PKTGEN_RCV_IDLE) {
dhd_sdio.c:6037:			bus->pktgen_rcv_state = PKTGEN_RCV_ONGOING;
dhd_sdio.c:6038:			dhdsdio_sdtest_set(bus, bus->pktgen_total);
dhd_sdio.c:6044:	for (pktcount = 0; pktcount < bus->pktgen_count; pktcount++) {
dhd_sdio.c:6046:		if (bus->pktgen_total && (bus->pktgen_sent >= bus->pktgen_total)) {
dhd_sdio.c:6047:			bus->pktgen_count = 0;
dhd_sdio.c:6051:		/* Allocate an appropriate-sized packet */
dhd_sdio.c:6052:		if (bus->pktgen_mode == DHD_PKTGEN_RXBURST) {
dhd_sdio.c:6055:			len = bus->pktgen_len;
dhd_sdio.c:6066:		switch (bus->pktgen_mode) {
dhd_sdio.c:6069:			*data++ = (uint8)bus->pktgen_sent;
dhd_sdio.c:6074:			*data++ = (uint8)bus->pktgen_sent;
dhd_sdio.c:6079:			*data++ = (uint8)bus->pktgen_count; /* Just for backward compatability */
dhd_sdio.c:6083:			DHD_ERROR(("Unrecognized pktgen mode %d\n", bus->pktgen_mode));
dhd_sdio.c:6085:			bus->pktgen_count = 0;
dhd_sdio.c:6090:		*data++ = (bus->pktgen_len >> 0);
dhd_sdio.c:6091:		*data++ = (bus->pktgen_len >> 8);
dhd_sdio.c:6096:		if (bus->pktgen_mode == DHD_PKTGEN_RXBURST) {
dhd_sdio.c:6097:			*data++ = (uint8)(bus->pktgen_count >> 0);
dhd_sdio.c:6098:			*data++ = (uint8)(bus->pktgen_count >> 8);
dhd_sdio.c:6099:			*data++ = (uint8)(bus->pktgen_count >> 16);
dhd_sdio.c:6100:			*data++ = (uint8)(bus->pktgen_count >> 24);
dhd_sdio.c:6103:			/* Then fill in the remainder -- N/A for burst */
dhd_sdio.c:6105:				*data++ = SDPCM_TEST_FILL(fillbyte, (uint8)bus->pktgen_sent);
dhd_sdio.c:6111:			prhex("dhdsdio_pktgen: Tx Data", data, PKTLEN(osh, pkt) - SDPCM_HDRLEN);
dhd_sdio.c:6117:			bus->pktgen_fail++;
dhd_sdio.c:6118:			if (bus->pktgen_stop && bus->pktgen_stop == bus->pktgen_fail)
dhd_sdio.c:6119:				bus->pktgen_count = 0;
dhd_sdio.c:6121:		bus->pktgen_sent++;
dhd_sdio.c:6124:		if (++bus->pktgen_len > bus->pktgen_maxlen)
dhd_sdio.c:6125:			bus->pktgen_len = (uint16)bus->pktgen_minlen;
dhd_sdio.c:6128:		if (bus->pktgen_mode == DHD_PKTGEN_RXBURST)
dhd_sdio.c:6138:	osl_t *osh = bus->dhd->osh;
dhd_sdio.c:6153:	*data++ = (bus->pktgen_maxlen >> 0);
dhd_sdio.c:6154:	*data++ = (bus->pktgen_maxlen >> 8);
dhd_sdio.c:6162:		bus->pktgen_fail++;
dhd_sdio.c:6169:	osl_t *osh = bus->dhd->osh;
dhd_sdio.c:6204:		/* Rx->Tx turnaround ok (even on NDIS w/current implementation) */
dhd_sdio.c:6207:			bus->pktgen_sent++;
dhd_sdio.c:6209:			bus->pktgen_fail++;
dhd_sdio.c:6212:		bus->pktgen_rcvd++;
dhd_sdio.c:6216:		if (bus->ext_loop) {
dhd_sdio.c:6218:			bus->pktgen_rcvd++;
dhd_sdio.c:6231:		bus->pktgen_rcvd++;
dhd_sdio.c:6242:						i, bus->pktgen_rcvd_rcvsession, testval, *prn));
dhd_sdio.c:6248:		bus->pktgen_rcvd++;
dhd_sdio.c:6261:	if (bus->pktgen_mode == DHD_PKTGEN_RECV) {
dhd_sdio.c:6262:		if (bus->pktgen_rcv_state != PKTGEN_RCV_IDLE) {
dhd_sdio.c:6263:			bus->pktgen_rcvd_rcvsession++;
dhd_sdio.c:6265:			if (bus->pktgen_total &&
dhd_sdio.c:6266:				(bus->pktgen_rcvd_rcvsession >= bus->pktgen_total)) {
dhd_sdio.c:6267:			bus->pktgen_count = 0;
dhd_sdio.c:6269:			bus->pktgen_rcv_state = PKTGEN_RCV_IDLE;
dhd_sdio.c:6271:				bus->pktgen_rcvd_rcvsession = 0;
dhd_sdio.c:6282:	bus = dhdp->bus;
dhd_sdio.c:6283:	bcmsdh_intr_disable(bus->sdh);
dhd_sdio.c:6293:	bus = dhdp->bus;
dhd_sdio.c:6295:	if (bus->dhd->dongle_reset)
dhd_sdio.c:6299:	if (!SLPAUTO_ENAB(bus) && bus->sleeping)
dhd_sdio.c:6302:	if (dhdp->busstate == DHD_BUS_DOWN)
dhd_sdio.c:6306:	if (!SLPAUTO_ENAB(bus) && (bus->poll && (++bus->polltick >= bus->pollrate))) {
dhd_sdio.c:6310:		bus->polltick = 0;
dhd_sdio.c:6313:		if (!bus->intr || (bus->intrcount == bus->lastintrs)) {
dhd_sdio.c:6315:			if (!bus->dpc_sched) {
dhd_sdio.c:6317:				devpend = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0,
dhd_sdio.c:6324:				bus->pollcnt++;
dhd_sdio.c:6325:				bus->ipend = TRUE;
dhd_sdio.c:6326:				if (bus->intr) {
dhd_sdio.c:6327:					bcmsdh_intr_disable(bus->sdh);
dhd_sdio.c:6329:				bus->dpc_sched = TRUE;
dhd_sdio.c:6330:				dhd_sched_dpc(bus->dhd);
dhd_sdio.c:6336:		bus->lastintrs = bus->intrcount;
dhd_sdio.c:6341:	if (dhdp->busstate == DHD_BUS_DATA && dhd_console_ms != 0) {
dhd_sdio.c:6342:		bus->console.count += dhd_watchdog_ms;
dhd_sdio.c:6343:		if (bus->console.count >= dhd_console_ms) {
dhd_sdio.c:6344:			bus->console.count -= dhd_console_ms;
dhd_sdio.c:6358:	if (bus->pktgen_count && (++bus->pktgen_tick >= bus->pktgen_freq)) {
dhd_sdio.c:6364:		bus->pktgen_tick = 0;
dhd_sdio.c:6371:	if (bus->activity)
dhd_sdio.c:6372:		bus->activity = FALSE;
dhd_sdio.c:6374:		bus->idlecount++;
dhd_sdio.c:6376:		if (bus->idlecount >= bus->idletime) {
dhd_sdio.c:6381:					dhd_os_wd_timer(bus->dhd, 0);
dhd_sdio.c:6385:			bus->idlecount = 0;
dhd_sdio.c:6389:	if ((bus->idletime > 0) && (bus->clkstate == CLK_AVAIL)) {
dhd_sdio.c:6390:		if (++bus->idlecount > bus->idletime) {
dhd_sdio.c:6391:			bus->idlecount = 0;
dhd_sdio.c:6392:			if (bus->activity) {
dhd_sdio.c:6393:				bus->activity = FALSE;
dhd_sdio.c:6395:					if (!bus->readframes)
dhd_sdio.c:6398:						bus->reqbussleep = TRUE;
dhd_sdio.c:6407:	return bus->ipend;
dhd_sdio.c:6414:	dhd_bus_t *bus = dhdp->bus;
dhd_sdio.c:6420:	if (bus->console_addr == 0)
dhd_sdio.c:6424:	dhd_os_sdlock(bus->dhd);
dhd_sdio.c:6427:	if (bus->dhd->dongle_reset) {
dhd_sdio.c:6428:		dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:6438:	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, cbuf_idx);
dhd_sdio.c:6444:	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, cbuf);
dhd_sdio.c:6449:	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, vcons_in);
dhd_sdio.c:6457:	if ((pkt = PKTGET(bus->dhd->osh, 4 + SDPCM_RESERVE, TRUE)) != NULL)
dhd_sdio.c:6461:	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
dhd_sdio.c:6462:		bus->activity = FALSE;
dhd_sdio.c:6466:	dhd_os_sdunlock(bus->dhd);
dhd_sdio.c:6485:		if (!tdata--) {
dhd_sdio.c:6557:	/* Init global variables at run-time, not as part of the declaration.
dhd_sdio.c:6558:	 * This is required to support init/de-init of the driver. Initialization
dhd_sdio.c:6559:	 * of globals as part of the declaration results in non-deterministic
dhd_sdio.c:6581:	/* BCMSDH passes venid and devid based on CIS parsing -- but low-power start
dhd_sdio.c:6583:	 * we recognize OR (-1) indicating we must request power first.
dhd_sdio.c:6644:	bus->sdh = sdh;
dhd_sdio.c:6645:	bus->cl_devid = (uint16)devid;
dhd_sdio.c:6646:	bus->bus = DHD_BUS;
dhd_sdio.c:6647:	bus->tx_seq = SDPCM_SEQUENCE_WRAP - 1;
dhd_sdio.c:6648:	bus->usebufpool = FALSE; /* Use bufpool if allocated, else use locally malloced rxbuf */
dhd_sdio.c:6660:	if (!(bus->dhd = dhd_attach(osh, bus, SDPCM_RESERVE))) {
dhd_sdio.c:6676:	if (bus->intr) {
dhd_sdio.c:6698:		memcpy(bus->dhd->mac.octet, (void *)&ea_addr, ETHER_ADDR_LEN);
dhd_sdio.c:6704:		if ((ret = dhd_bus_start(bus->dhd)) != 0) {
dhd_sdio.c:6709:	/* Ok, have the per-port tell the stack we're open for business */
dhd_sdio.c:6710:	if (dhd_net_attach(bus->dhd, 0) != 0) {
dhd_sdio.c:6741:	bus->alp_only = TRUE;
dhd_sdio.c:6742:	bus->sih = NULL;
dhd_sdio.c:6751:	       bcmsdh_reg_read(bus->sdh, SI_ENUM_BASE, 4)));
dhd_sdio.c:6804:		while (fn-- > 0) {
dhd_sdio.c:6817:	if (!(bus->sih = si_attach((uint)devid, osh, regsva, DHD_BUS, sdh,
dhd_sdio.c:6818:	                           &bus->vars, &bus->varsz))) {
dhd_sdio.c:6823:	bcmsdh_chipinfo(sdh, bus->sih->chip, bus->sih->chiprev);
dhd_sdio.c:6825:	if (!dhdsdio_chipmatch((uint16)bus->sih->chip)) {
dhd_sdio.c:6827:		           __FUNCTION__, bus->sih->chip));
dhd_sdio.c:6831:	if (bus->sih->buscorerev >= 12)
dhd_sdio.c:6834:		bus->kso = TRUE;
dhd_sdio.c:6836:	if (CST4330_CHIPMODE_SDIOD(bus->sih->chipst)) {
dhd_sdio.c:6839:	si_sdiod_drive_strength_init(bus->sih, osh, dhd_sdiod_drive_strength);
dhd_sdio.c:6844:		if ((si_setcore(bus->sih, ARM7S_CORE_ID, 0)) ||
dhd_sdio.c:6845:		    (si_setcore(bus->sih, ARMCM3_CORE_ID, 0)) ||
dhd_sdio.c:6846:		    (si_setcore(bus->sih, ARMCR4_CORE_ID, 0))) {
dhd_sdio.c:6847:			bus->armrev = si_corerev(bus->sih);
dhd_sdio.c:6853:		if (!si_setcore(bus->sih, ARMCR4_CORE_ID, 0)) {
dhd_sdio.c:6854:		if (!(bus->orig_ramsize = si_socram_size(bus->sih))) {
dhd_sdio.c:6860:			if (!(bus->orig_ramsize = si_tcm_size(bus->sih))) {
dhd_sdio.c:6861:				DHD_ERROR(("%s: failed to find CR4-TCM memory!\n", __FUNCTION__));
dhd_sdio.c:6865:			bus->dongle_ram_base = CR4_RAM_BASE;
dhd_sdio.c:6867:		bus->ramsize = bus->orig_ramsize;
dhd_sdio.c:6872:			bus->ramsize, bus->orig_ramsize));
dhd_sdio.c:6874:		bus->srmemsize = si_socram_srmem_size(bus->sih);
dhd_sdio.c:6878:	if (!(bus->regs = si_setcore(bus->sih, PCMCIA_CORE_ID, 0)) &&
dhd_sdio.c:6879:	    !(bus->regs = si_setcore(bus->sih, SDIOD_CORE_ID, 0))) {
dhd_sdio.c:6883:	bus->sdpcmrev = si_corerev(bus->sih);
dhd_sdio.c:6886:	OR_REG(osh, &bus->regs->corecontrol, CC_BPRESEN);
dhd_sdio.c:6887:	bus->rxint_mode = SDIO_DEVICE_HMB_RXINT;
dhd_sdio.c:6889:	if ((bus->sih->buscoretype == SDIOD_CORE_ID) && (bus->sdpcmrev >= 4) &&
dhd_sdio.c:6890:		(bus->rxint_mode  == SDIO_DEVICE_RXDATAINT_MODE_1))
dhd_sdio.c:6894:		val = R_REG(osh, &bus->regs->corecontrol);
dhd_sdio.c:6897:		W_REG(osh, &bus->regs->corecontrol, val);
dhd_sdio.c:6901:	pktq_init(&bus->txq, (PRIOMASK + 1), QLEN);
dhd_sdio.c:6903:	/* Locate an appropriately-aligned portion of hdrbuf */
dhd_sdio.c:6904:	bus->rxhdr = (uint8 *)ROUNDUP((uintptr)&bus->hdrbuf[0], DHD_SDALIGN);
dhd_sdio.c:6907:	bus->intr = (bool)dhd_intr;
dhd_sdio.c:6908:	if ((bus->poll = (bool)dhd_poll))
dhd_sdio.c:6909:		bus->pollrate = 1;
dhd_sdio.c:6913:	bus->glom_mode = SDPCM_TXGLOM_CPY;
dhd_sdio.c:6915:	bus->glomsize = SDPCM_DEFGLOM_SIZE;
dhd_sdio.c:6921:	if (bus->sih != NULL) {
dhd_sdio.c:6922:		si_detach(bus->sih);
dhd_sdio.c:6923:		bus->sih = NULL;
dhd_sdio.c:6933:	if (bus->dhd->maxctl) {
dhd_sdio.c:6934:		bus->rxblen = ROUNDUP((bus->dhd->maxctl + SDPCM_HDRLEN), ALIGNMENT) + DHD_SDALIGN;
dhd_sdio.c:6935:		if (!(bus->rxbuf = DHD_OS_PREALLOC(osh, DHD_PREALLOC_RXBUF, bus->rxblen))) {
dhd_sdio.c:6936:			DHD_ERROR(("%s: MALLOC of %d-byte rxbuf failed\n",
dhd_sdio.c:6937:			           __FUNCTION__, bus->rxblen));
dhd_sdio.c:6942:	if (!(bus->databuf = DHD_OS_PREALLOC(osh, DHD_PREALLOC_DATABUF, MAX_DATA_BUF))) {
dhd_sdio.c:6943:		DHD_ERROR(("%s: MALLOC of %d-byte databuf failed\n",
dhd_sdio.c:6946:		if (!bus->rxblen)
dhd_sdio.c:6947:			DHD_OS_PREFREE(osh, bus->rxbuf, bus->rxblen);
dhd_sdio.c:6952:	if ((uintptr)bus->databuf % DHD_SDALIGN)
dhd_sdio.c:6953:		bus->dataptr = bus->databuf + (DHD_SDALIGN - ((uintptr)bus->databuf % DHD_SDALIGN));
dhd_sdio.c:6955:		bus->dataptr = bus->databuf;
dhd_sdio.c:6977:	bus->dhd->busstate = DHD_BUS_DOWN;
dhd_sdio.c:6978:	bus->sleeping = FALSE;
dhd_sdio.c:6979:	bus->rxflow = FALSE;
dhd_sdio.c:6980:	bus->prev_rxlim_hit = 0;
dhd_sdio.c:6982:	/* Done with backplane-dependent accesses, can drop clock... */
dhd_sdio.c:6986:	bus->clkstate = CLK_SDONLY;
dhd_sdio.c:6987:	bus->idletime = (int32)dhd_idletime;
dhd_sdio.c:6988:	bus->idleclock = DHD_IDLE_ACTIVE;
dhd_sdio.c:6992:	                    &bus->sd_divisor, sizeof(int32), FALSE) != BCME_OK) {
dhd_sdio.c:6994:		bus->sd_divisor = -1;
dhd_sdio.c:6997:		          __FUNCTION__, "sd_divisor", bus->sd_divisor));
dhd_sdio.c:7002:	                    &bus->sd_mode, sizeof(int32), FALSE) != BCME_OK) {
dhd_sdio.c:7004:		bus->sd_mode = -1;
dhd_sdio.c:7007:		          __FUNCTION__, "sd_mode", bus->sd_mode));
dhd_sdio.c:7013:	                    &bus->blocksize, sizeof(int32), FALSE) != BCME_OK) {
dhd_sdio.c:7014:		bus->blocksize = 0;
dhd_sdio.c:7018:		          __FUNCTION__, "sd_blocksize", bus->blocksize));
dhd_sdio.c:7020:	bus->roundup = MIN(max_roundup, bus->blocksize);
dhd_sdio.c:7024:	                    &bus->sd_rxchain, sizeof(int32), FALSE) != BCME_OK) {
dhd_sdio.c:7025:		bus->sd_rxchain = FALSE;
dhd_sdio.c:7028:		          __FUNCTION__, (bus->sd_rxchain ? "supports" : "does not support")));
dhd_sdio.c:7030:	bus->use_rxchain = (bool)bus->sd_rxchain;
dhd_sdio.c:7053:		i--;
dhd_sdio.c:7066:		chip = bus->sih->chip;
dhd_sdio.c:7067:		chiprev = bus->sih->chiprev;
dhd_sdio.c:7103:	*chip = bus->sih->chip;
dhd_sdio.c:7104:	*chiprev = bus->sih->chiprev;
dhd_sdio.c:7113:	bus->fw_path = pfw_path;
dhd_sdio.c:7114:	bus->nv_path = pnv_path;
dhd_sdio.c:7116:	ret = dhdsdio_download_firmware(bus, osh, bus->sdh);
dhd_sdio.c:7127:	DHD_OS_WAKE_LOCK(bus->dhd);
dhd_sdio.c:7136:	DHD_OS_WAKE_UNLOCK(bus->dhd);
dhd_sdio.c:7150:		if (bus->dhd) {
dhd_sdio.c:7151:			dongle_isolation = bus->dhd->dongle_isolation;
dhd_sdio.c:7152:			dhd_detach(bus->dhd);
dhd_sdio.c:7155:		/* De-register interrupt handler */
dhd_sdio.c:7156:		bcmsdh_intr_disable(bus->sdh);
dhd_sdio.c:7157:		bcmsdh_intr_dereg(bus->sdh);
dhd_sdio.c:7159:		if (bus->dhd) {
dhd_sdio.c:7161:			dhd_free(bus->dhd);
dhd_sdio.c:7162:			bus->dhd = NULL;
dhd_sdio.c:7168:		if (bus->console.buf != NULL)
dhd_sdio.c:7169:			MFREE(osh, bus->console.buf, bus->console.bufsize);
dhd_sdio.c:7186:	if (bus->dhd && bus->dhd->dongle_reset)
dhd_sdio.c:7189:	if (bus->rxbuf) {
dhd_sdio.c:7191:		MFREE(osh, bus->rxbuf, bus->rxblen);
dhd_sdio.c:7193:		bus->rxctl = bus->rxbuf = NULL;
dhd_sdio.c:7194:		bus->rxlen = 0;
dhd_sdio.c:7197:	if (bus->databuf) {
dhd_sdio.c:7199:		MFREE(osh, bus->databuf, MAX_DATA_BUF);
dhd_sdio.c:7201:		bus->databuf = NULL;
dhd_sdio.c:7204:	if (bus->vars && bus->varsz) {
dhd_sdio.c:7205:		MFREE(osh, bus->vars, bus->varsz);
dhd_sdio.c:7206:		bus->vars = NULL;
dhd_sdio.c:7215:	DHD_TRACE(("%s: Enter bus->dhd %p bus->dhd->dongle_reset %d \n", __FUNCTION__,
dhd_sdio.c:7216:		bus->dhd, bus->dhd->dongle_reset));
dhd_sdio.c:7218:	if ((bus->dhd && bus->dhd->dongle_reset) && reset_flag)
dhd_sdio.c:7221:	if (bus->sih) {
dhd_sdio.c:7223:		if (bus->dhd) {
dhd_sdio.c:7227:			si_watchdog(bus->sih, 4);
dhd_sdio.c:7229:		if (bus->dhd) {
dhd_sdio.c:7232:		si_detach(bus->sih);
dhd_sdio.c:7233:		bus->sih = NULL;
dhd_sdio.c:7234:		if (bus->vars && bus->varsz)
dhd_sdio.c:7235:			MFREE(osh, bus->vars, bus->varsz);
dhd_sdio.c:7236:		bus->vars = NULL;
dhd_sdio.c:7261:		ASSERT(bus->dhd);
dhd_sdio.c:7262:		dhdsdio_release(bus, bus->dhd->osh);
dhd_sdio.c:7317:	int bcmerror = -1;
dhd_sdio.c:7338:			(uint8 *) (dlarray + offset), sizeof(dlarray) - offset);
dhd_sdio.c:7341:			        __FUNCTION__, bcmerror, sizeof(dlarray) - offset, offset));
dhd_sdio.c:7349:		ularray = MALLOC(bus->dhd->osh, bus->ramsize);
dhd_sdio.c:7352:		memset(ularray, 0xaa, bus->ramsize);
dhd_sdio.c:7366:				ularray + offset, sizeof(dlarray) - offset);
dhd_sdio.c:7369:					__FUNCTION__, bcmerror, sizeof(dlarray) - offset, offset));
dhd_sdio.c:7387:		MFREE(bus->dhd->osh, ularray, bus->ramsize);
dhd_sdio.c:7395:	int bcmerror = -1;
dhd_sdio.c:7408:	memptr = memblock = MALLOC(bus->dhd->osh, MEMBLOCK + DHD_SDALIGN);
dhd_sdio.c:7414:		memptr_tmp = MALLOC(bus->dhd->osh, MEMBLOCK + DHD_SDALIGN);
dhd_sdio.c:7421:		memptr += (DHD_SDALIGN - ((uint32)(uintptr)memblock % DHD_SDALIGN));
dhd_sdio.c:7455:		MFREE(bus->dhd->osh, memblock, MEMBLOCK + DHD_SDALIGN);
dhd_sdio.c:7458:			MFREE(bus->dhd->osh, memptr_tmp, MEMBLOCK + DHD_SDALIGN);
dhd_sdio.c:7484:	bus->nvram_params = nvram_params;
dhd_sdio.c:7490:	int bcmerror = -1;
dhd_sdio.c:7498:	pnv_path = bus->nv_path;
dhd_sdio.c:7501:	if (!nvram_file_exists && (bus->nvram_params == NULL))
dhd_sdio.c:7510:	memblock = MALLOC(bus->dhd->osh, MAX_NVRAMBUF_SIZE);
dhd_sdio.c:7522:		len = strlen(bus->nvram_params);
dhd_sdio.c:7524:		memcpy(memblock, bus->nvram_params, len);
dhd_sdio.c:7531:			len += 4 - (len % 4);
dhd_sdio.c:7550:		MFREE(bus->dhd->osh, memblock, MAX_NVRAMBUF_SIZE);
dhd_sdio.c:7561:	int bcmerror = -1;
dhd_sdio.c:7567:	if ((bus->fw_path == NULL) || (bus->fw_path[0] == '\0')) {
dhd_sdio.c:7582:	if ((bus->fw_path != NULL) && (bus->fw_path[0] != '\0')) {
dhd_sdio.c:7583:		if (dhdsdio_download_code_file(bus, bus->fw_path)) {
dhd_sdio.c:7647:	status = bcmsdh_recv_buf(bus->sdh, addr, fn, flags, buf, nbytes, pkt, complete, handle);
dhd_sdio.c:7661:	return (bcmsdh_send_buf(bus->sdh, addr, fn, flags, buf, nbytes, pkt, complete, handle));
dhd_sdio.c:7668:	bcmsdh_glom_post(bus->sdh, frame, len);
dhd_sdio.c:7674:	bcmsdh_glom_clear(bus->sdh);
dhd_sdio.c:7681:	ASSERT(bus->sih != NULL);
dhd_sdio.c:7682:	return bus->sih->chip;
dhd_sdio.c:7688:	return bus->dhd;
dhd_sdio.c:7694:	return &bus->txq;
dhd_sdio.c:7709:	bus = dhdp->bus;
dhd_sdio.c:7712:		if (!bus->dhd->dongle_reset) {
dhd_sdio.c:7717:			dhd_txflowcontrol(bus->dhd, ALL_INTERFACES, ON);
dhd_sdio.c:7729:			dhdsdio_release_dongle(bus, bus->dhd->osh, TRUE, TRUE);
dhd_sdio.c:7731:			bus->dhd->dongle_reset = TRUE;
dhd_sdio.c:7732:			bus->dhd->up = FALSE;
dhd_sdio.c:7747:		if (bus->dhd->dongle_reset) {
dhd_sdio.c:7753:			bcmsdh_reset(bus->sdh);
dhd_sdio.c:7755:			/* Attempt to re-attach & download */
dhd_sdio.c:7756:			if (dhdsdio_probe_attach(bus, bus->dhd->osh, bus->sdh,
dhd_sdio.c:7758:			                        bus->cl_devid)) {
dhd_sdio.c:7761:				if (dhdsdio_probe_init(bus, bus->dhd->osh, bus->sdh) &&
dhd_sdio.c:7762:					dhdsdio_download_firmware(bus, bus->dhd->osh, bus->sdh)) {
dhd_sdio.c:7764:					/* Re-init bus, enable F2 transfer */
dhd_sdio.c:7765:					bcmerror = dhd_bus_init((dhd_pub_t *) bus->dhd, FALSE);
dhd_sdio.c:7772:						bus->dhd->dongle_reset = FALSE;
dhd_sdio.c:7773:						bus->dhd->up = TRUE;
dhd_sdio.c:7777:						dhd_txflowcontrol(bus->dhd, ALL_INTERFACES, OFF);
dhd_sdio.c:7781:						if ((dhdp->busstate == DHD_BUS_DATA) &&
dhd_sdio.c:7789:						dhdsdio_release_dongle(bus, bus->dhd->osh,
dhd_sdio.c:7806:			if (dhdsdio_probe_attach(bus, bus->dhd->osh, bus->sdh,
dhd_sdio.c:7808:			                        bus->cl_devid)) { // terence 20120615: fix for 43362 OOB initial
dhd_sdio.c:7809:				if (dhdsdio_probe_init(bus, bus->dhd->osh, bus->sdh)) {
dhd_sdio.c:7826:	dhd_bus_t *bus = dhdp->bus;
dhd_sdio.c:7828:	return bus->sih->chip;
dhd_sdio.c:7834:	dhd_bus_t *bus = dhdp->bus;
dhd_sdio.c:7836:	return bus->sih->chiprev;
dhd_sdio.c:7842:	dhd_bus_t *bus = dhdp->bus;
dhd_sdio.c:7844:	return bus->sih->chippkg;
dhd_sdio.c:7852:	bus = dhdp->bus;
dhd_wlfc.h:2:* Copyright (C) 1999-2012, Broadcom Corporation
dhd_wlfc.h:21:* $Id: dhd_wlfc.h 361006 2012-10-05 07:45:51Z $
dhd_wlfc.h:36:/* x -> TXSTATUS TAG to/from firmware */
dhd_wlfc.h:91:#define WLFC_HANGER_SIZE(n)	((sizeof(wlfc_hanger_t) - \
dhd_wlfc.h:104:#define WLFC_FLOWCONTROL_HIWATER	(2048 - 256)
dhd_wlfc.h:144:#define WLFC_DECR_SEQCOUNT(entry, prec) do { if (entry->seq[(prec)] == 0) {\
dhd_wlfc.h:145:	entry->seq[prec] = 0xff; } else entry->seq[prec]--;} while (0)
dhd_wlfc.h:147:#define WLFC_INCR_SEQCOUNT(entry, prec) entry->seq[(prec)]++
dhd_wlfc.h:148:#define WLFC_SEQCOUNT(entry, prec) entry->seq[(prec)]
dhd_wlfc.h:184:	/* all pkt2bus -> txstatus latency accumulated */
dhd_wlfc.h:200:	(ctx)->stats.fifo_credits_sent[(ac)]++;} while (0)
dhd_wlfc.h:202:	(ctx)->stats.fifo_credits_back[(ac)]++;} while (0)
dhd_wlfc.h:204:	(ctx)->stats.dropped_qfull[(ac)]++;} while (0)
dhd_wlfc.h:221:/* Mask to check for only on-going AC_BE traffic */
dhd_wlfc.h:243:	/* packet hanger and MAC->handle lookup table */
dhd_wlfc.h:265:	0 - Do not do any proptxtstatus flow control
dhd_wlfc.h:266:	1 - Use implied credit from a packet status
dhd_wlfc.h:267:	2 - Use explicit credit
dngl_stats.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
dngl_stats.h:25: * $Id: dngl_stats.h 241182 2011-02-17 21:50:03Z $
dngl_wlhdr.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
dngl_wlhdr.h:24: * $Id: dngl_wlhdr.h 241182 2011-02-17 21:50:03Z $
hndpmu.c:3: * of the SiliconBackplane-based Broadcom chips.
hndpmu.c:5: * Copyright (C) 1999-2012, Broadcom Corporation
hndpmu.c:25: * $Id: hndpmu.c 354194 2012-08-30 08:39:03Z $
hndpmu.c:50: * The last strength value in each table must be 0 (the tri-state value).
hndpmu.c:54:	uint8 sel;			/* Chip-specific select value */
hndpmu.c:130:	if (!(sih->cccaps & CC_CAP_PMU)) {
hndpmu.c:137:	switch (SDIOD_DRVSTR_KEY(sih->chip, sih->pmurev)) {
hndpmu.c:152:		if (sih->pmurev == 8) {
hndpmu.c:155:		else if (sih->pmurev == 11) {
hndpmu.c:178:		         bcm_chipname(sih->chip, chn, 8), sih->chiprev, sih->pmurev));
hndpmu.c:188:		 * requested strength.	Drive strength of 0 requests tri-state.
hndpmu.c:194:			i--;
hndpmu.c:196:		W_REG(osh, &cc->chipcontrol_addr, 1);
hndpmu.c:197:		cc_data_temp = R_REG(osh, &cc->chipcontrol_data);
hndpmu.c:200:		W_REG(osh, &cc->chipcontrol_data, cc_data_temp);
include/bcmsdpcm.h:3: * Software-specific definitions shared between device and host side
include/bcmsdpcm.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmsdpcm.h:25: * $Id: bcmsdpcm.h 362722 2012-10-12 23:55:55Z $
include/bcmsdpcm.h:87: * Software-defined protocol header
include/bcmsdpcm.h:105:/* Next Read Len: lookahead length of next frame, in 16-byte units (rounded up) */
include/bcmsdpcm.h:136:#define SDPCM_SEQUENCE_WRAP	256	/* wrap-around val for eight-bit frame seq number */
include/bcmsdpcm.h:148:/* For TEST_CHANNEL packets, define another 4-byte header */
include/bcmsdpcm.h:152:						 * including test header; sent little-endian.
include/bcmsdpcm.h:216:	 (void *)(uintptr)&((h)->regs->dma.sdiod32.dma32regs[chnl].xmt) : \
include/bcmsdpcm.h:217:	 (void *)(uintptr)&((h)->regs->dma.sdiod32.dma32regs[chnl].rcv))
include/bcmsdpcm.h:221:	 (void *)(uintptr)&((h)->regs->dma.sdiod64.dma64regs[chnl].xmt) : \
include/bcmsdpcm.h:222:	 (void *)(uintptr)&((h)->regs->dma.sdiod64.dma64regs[chnl].rcv))
include/bcmsdpcm.h:225:	(SDIODREV_LT((h)->corerev, 1) ? \
include/bcmsdpcm.h:231:	 (void *)(uintptr)&((h)->regs->dma.pcm32.dmaregs.xmt) : \
include/bcmsdpcm.h:232:	 (void *)(uintptr)&((h)->regs->dma.pcm32.dmaregs.rcv))
include/bcmsdpcm.h:241:	 ((dma32diag_t *)(uintptr)&((h)->regs->dma.sdiod32.dmafifo)) : \
include/bcmsdpcm.h:242:	 ((dma32diag_t *)(uintptr)&((h)->regs->dma.sdiod64.dmafifo)))
include/bcmsdpcm.h:245:	((dma32diag_t *)(uintptr)&((h)->regs->dma.pcm32.dmafifo))
include/sbhnddma.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
include/sbhnddma.h:25: * $Id: sbhnddma.h 309193 2012-01-19 00:03:57Z $
include/sbhnddma.h:207:/* control flags in the range [27:20] are core-specific and not defined here */
include/sbhnddma.h:216:	uint32	addrlow;		/* descriptor ring base address low 32-bits (8K aligned) */
include/sbhnddma.h:370:/* control flags in the range [27:20] are core-specific and not defined here */
include/sbhnddma.h:375:#define D64_RX_FRM_STS_DSCRCNT	0x0f000000	/* no. of descriptors used - 1, d11corerev >= 22 */
include/sbhnddma.h:376:#define D64_RX_FRM_STS_DATATYPE	0xf0000000	/* core-dependent data type */
include/bcmcdc.h:7: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmcdc.h:27: * $Id: bcmcdc.h 318308 2012-03-02 02:23:42Z $
include/bcmcdc.h:67:	((int)((((hdr)->flags) & CDCF_IOC_IF_MASK) >> CDCF_IOC_IF_SHIFT))
include/bcmcdc.h:69:	((hdr)->flags = (((hdr)->flags & ~CDCF_IOC_IF_MASK) | ((idx) << CDCF_IOC_IF_SHIFT)))
include/bcmcdc.h:82:					 * 4-byte words.  Leaves room for optional headers.
include/bcmcdc.h:89:#define BDC_FLAG_80211_PKT	0x01	/* Packet is in 802.11 format (dongle -> host) */
include/bcmcdc.h:91:#define BDC_FLAG_SUM_NEEDED	0x08	/* Dongle needs to do TX checksums: host->device */
include/bcmcdc.h:92:#define BDC_FLAG_EVENT_MSG	0x08	/* Payload contains an event msg: device->host */
include/bcmcdc.h:102:#define BDC_FLAG2_IF_MASK	0x0f	/* interface index (host <-> dongle) */
include/bcmcdc.h:113:	((int)((((hdr)->flags2) & BDC_FLAG2_IF_MASK) >> BDC_FLAG2_IF_SHIFT))
include/bcmcdc.h:115:	((hdr)->flags2 = (((hdr)->flags2 & ~BDC_FLAG2_IF_MASK) | ((idx) << BDC_FLAG2_IF_SHIFT)))
include/bcmcdc.h:124:	((int)(((((hdr)->flags2) & BDC_FLAG2_PAD_MASK) >> BDC_FLAG2_PAD_SHIFT) | \
include/bcmcdc.h:125:	((((hdr)->flags) & BDC_FLAG_PAD_MASK) >> BDC_FLAG_PAD_SHIFT)))
include/bcmcdc.h:127:	((hdr)->flags2 = (((hdr)->flags2 & ~BDC_FLAG2_PAD_MASK) | \
include/bcmcdc.h:129:	((hdr)->flags = (((hdr)->flags & ~BDC_FLAG_PAD_MASK) | \
include/sbconfig.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/sbconfig.h:24: * $Id: sbconfig.h 241182 2011-02-17 21:50:03Z $
include/bcm_cfg.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcm_cfg.h:24: * $Id: bcm_cfg.h 294399 2011-11-07 03:31:22Z $
include/bcmperf.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmperf.h:24: * $Id: bcmperf.h 241182 2011-02-17 21:50:03Z $
include/sbchipc.h:8: * $Id: sbchipc.h 347614 2012-07-27 10:24:51Z $
include/sbchipc.h:10: * Copyright (C) 1999-2012, Broadcom Corporation
include/sbchipc.h:129:	/* gpio - cleared only by power-on-reset */
include/sbchipc.h:452:#define CC_CAP_MIPSEB		0x00000004	/* MIPS is in big-endian mode */
include/sbchipc.h:468:#define CC_CAP_BKPLN64		0x08000000	/* 64-bit backplane */
include/sbchipc.h:493:/* ALP clock on pre-PMU chips */
include/sbchipc.h:623:#define	JTAGM_CREV_IRP		22	/* Able to do pause-ir */
include/sbchipc.h:624:#define	JTAGM_CREV_RTI		28	/* Able to do return-to-idle */
include/sbchipc.h:630:#define JCMD_STATE_TLR		0x00000000	/* Test-logic-reset */
include/sbchipc.h:633:#define JCMD_STATE_RTI		0x60000000	/* Run-test-idle */
include/sbchipc.h:650:#define JCMD_ACC_IRDR_I		0x00070000	/* rev 28: return to run-test-idle */
include/sbchipc.h:651:#define JCMD_ACC_DR_I		0x00080000	/* rev 28: return to run-test-idle */
include/sbchipc.h:845:#define	CC_F6_3			0x03		/* 6-bit fields like */
include/sbchipc.h:851:#define	CC_F5_BIAS		5		/* 5-bit fields get this added */
include/sbchipc.h:938:#define SFLASH_ST_DP		0x00b9		/* Deep Power-down */
include/sbchipc.h:941:#define SFLASH_ST_SSE		0x0220		/* Sub-sector Erase */
include/sbchipc.h:1009:#define UART_LSR_TDHR		0x40	/* Data-hold-register empty */
include/sbchipc.h:1010:#define UART_LSR_THRE		0x20	/* Transmit-hold-register empty */
include/sbchipc.h:1468:/* 2nd - 32-bit reg */
include/sbchipc.h:1558:/* 4325 chip-specific ChipStatus register bits */
include/sbchipc.h:1604:/* 4312 chip-specific ChipStatus register bits */
include/sbchipc.h:1639:/* 4322 chip-specific ChipStatus register bits */
include/sbchipc.h:1669:/* 43224 chip-specific ChipControl register bits */
include/sbchipc.h:1682:/* 43236 chip-specific ChipControl register bits */
include/sbchipc.h:1710:/* 43237 chip-specific ChipControl register bits */
include/sbchipc.h:1767:/* 4331 chip-specific ChipControl register bits */
include/sbchipc.h:1771:#define CCTRL4331_SPROM_GPIO13_15       (1<<3)  /* sprom/gpio13-15 mux */
include/sbchipc.h:1815:/* 4315 chip-specific ChipStatus register bits */
include/sbchipc.h:1850:/* 4319 chip-specific ChipStatus register bits */
include/sbchipc.h:1910:/* 4336 chip-specific ChipStatus register bits */
include/sbchipc.h:1959:/* 4330 chip-specific ChipStatus register bits */
include/sbchipc.h:1964:#define CST4330_CHIPMODE_USB(cs)	(((cs) & 0x7) == 6)	/* USB packet-oriented */
include/sbchipc.h:2027:/* 4334 chip-specific ChipStatus register bits */
include/sbchipc.h:2074:/* 4313 chip-specific ChipStatus register bits */
include/sbchipc.h:2115:/* 4314 chip-specific ChipStatus register bits */
include/sbchipc.h:2135:#define	CST4706_PKG_OPTION		(1<<0) /* 0: full-featured package 1: low-cost package */
include/sbchipc.h:2137:#define	CST4706_SFLASH_TYPE		(1<<2) /* 0: 8b-p/ST-s flash, 1: 16b-p/Atmal-s flash */
include/sbchipc.h:2243:/* 4335 resources--END */
include/sbchipc.h:2319:/* 4335 MUX options. each nibble belongs to a setting. Non-zero value specifies a logic
include/sbchipc.h:2366:#define SECI_UART_LCR_STOP_BITS		(1 << 0) /* 0 - 1bit, 1 - 2bits */
include/sbchipc.h:2368:#define SECI_UART_LCR_PARITY		(1 << 2) /* 0 - odd, 1 - even */
include/sbchipc.h:2389:/* WLAN channel numbers - used from wifi.h */
include/sbchipc.h:2401:/* WLAN - number of antenna */
include/sbsocram.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/sbsocram.h:24: * $Id: sbsocram.h 271781 2011-07-13 20:00:06Z $
include/usbrdl.h:12: * $Id: usbrdl.h 296577 2011-11-16 03:09:51Z $
include/proto/802.11.h:2: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/802.11.h:24: * $Id: 802.11.h 346820 2012-07-24 13:53:12Z $
include/proto/802.11.h:102:						 * Bridge-Tunnel: 0x00 0x00 0xF8
include/proto/802.11.h:164:#define	DOT11_CS_END_LEN	16		/* d11 CF-END frame length */
include/proto/802.11.h:166:/* RWL wifi protocol: The Vendor Specific Action frame is defined for vendor-specific signaling
include/proto/802.11.h:341:/* Extension Channel Offset IE: 802.11n-D1.0 spec. added sideband
include/proto/802.11.h:389:/* CSA mode - 802.11h-2003 $7.3.2.20 */
include/proto/802.11.h:470:#define TDLS_CAP_PU_BUFFER_STA	28		/* TDLS Peer U-APSD buffer STA support */
include/proto/802.11.h:637:#define WME_QI_AP_APSD_MASK         0x80        /* U-APSD Supported mask */
include/proto/802.11.h:638:#define WME_QI_AP_APSD_SHIFT        7           /* U-APSD Supported shift */
include/proto/802.11.h:668:#define EDCF_ECW2CW(exp)             ((1 << (exp)) - 1)
include/proto/802.11.h:678:/* Default BE ACI value for non-WME connection STA */
include/proto/802.11.h:830:#define FC_SUBTYPE_DEAUTH		12	/* de-authentication */
include/proto/802.11.h:832:#define FC_SUBTYPE_ACTION_NOACK		14	/* action no-ack */
include/proto/802.11.h:842:#define FC_SUBTYPE_CF_END		14	/* CF-END */
include/proto/802.11.h:843:#define FC_SUBTYPE_CF_END_ACK		15	/* CF-END ACK */
include/proto/802.11.h:847:#define FC_SUBTYPE_DATA_CF_ACK		1	/* Data + CF-ACK */
include/proto/802.11.h:848:#define FC_SUBTYPE_DATA_CF_POLL		2	/* Data + CF-Poll */
include/proto/802.11.h:849:#define FC_SUBTYPE_DATA_CF_ACK_POLL	3	/* Data + CF-Ack + CF-Poll */
include/proto/802.11.h:851:#define FC_SUBTYPE_CF_ACK		5	/* CF-Ack */
include/proto/802.11.h:852:#define FC_SUBTYPE_CF_POLL		6	/* CF-Poll */
include/proto/802.11.h:853:#define FC_SUBTYPE_CF_ACK_POLL		7	/* CF-Ack + CF-Poll */
include/proto/802.11.h:855:#define FC_SUBTYPE_QOS_DATA_CF_ACK	9	/* QoS Data + CF-Ack */
include/proto/802.11.h:856:#define FC_SUBTYPE_QOS_DATA_CF_POLL	10	/* QoS Data + CF-Poll */
include/proto/802.11.h:857:#define FC_SUBTYPE_QOS_DATA_CF_ACK_POLL	11	/* QoS Data + CF-Ack + CF-Poll */
include/proto/802.11.h:859:#define FC_SUBTYPE_QOS_CF_POLL		14	/* QoS CF-Poll */
include/proto/802.11.h:860:#define FC_SUBTYPE_QOS_CF_ACK_POLL	15	/* QoS CF-Ack + CF-Poll */
include/proto/802.11.h:887:#define FC_ACTION_NOACK	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION_NOACK)	/* action no-ack */
include/proto/802.11.h:896:#define FC_CF_END	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END)		/* CF-END */
include/proto/802.11.h:897:#define FC_CF_END_ACK	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END_ACK)	/* CF-END ACK */
include/proto/802.11.h:917:/* End of Service Period (U-APSD) */
include/proto/802.11.h:931:/* A-MSDU flag */
include/proto/802.11.h:981:/* 32-39 are QSTA specific reasons added in 11e */
include/proto/802.11.h:982:#define DOT11_RC_UNSPECIFIED_QOS	32	/* unspecified QoS-related reason */
include/proto/802.11.h:1067:						 * station not supporting the ER-PBCC
include/proto/802.11.h:1071:						 * station not supporting the DSS-OFDM
include/proto/802.11.h:1145:#define DOT11_MNG_NONERP_ID			47	/* d11 management NON-ERP id */
include/proto/802.11.h:1195:							 *ERP-OFDM frames
include/proto/802.11.h:1291:#define DOT11_FT_ACTION_FT_REQ			1	/* FBT request - for over-the-DS FBT */
include/proto/802.11.h:1292:#define DOT11_FT_ACTION_FT_RES			2	/* FBT response - for over-the-DS FBT */
include/proto/802.11.h:1293:#define DOT11_FT_ACTION_FT_CON			3	/* FBT confirm - for OTDS with RRP */
include/proto/802.11.h:1387:/* BSS Mgmt Transition Request Mode Field - 802.11v */
include/proto/802.11.h:1480:/* Over-the-DS Fast Transition Request frame header */
include/proto/802.11.h:1491:/* Over-the-DS Fast Transition Response frame header */
include/proto/802.11.h:1615:/* Sub-element IDs for Beacon Request */
include/proto/802.11.h:1627:/* Sub-element IDs for Beacon Report */
include/proto/802.11.h:1676:#define PREN_PREAMBLE_EXT	4	/* extra preamble (multiply by unique_streams-1) */
include/proto/802.11.h:1681:/* 802.11 HT PLCP format 802.11n-2009, sec 20.3.9.4.3
include/proto/802.11.h:1682: * HT-SIG is composed of two 24 bit parts, HT-SIG1 and HT-SIG2
include/proto/802.11.h:1684:/* HT-SIG1 */
include/proto/802.11.h:1689:/* HT-SIG2 */
include/proto/802.11.h:1733:/* for VHT-A1 */
include/proto/802.11.h:1734:/* SIG-A1 reserved bits */
include/proto/802.11.h:1754:/* for VHT-A2 */
include/proto/802.11.h:1770:/* dot11Counters Table - 802.11 spec., Annex D */
include/proto/802.11.h:1804:	uint16	amsdu_mtu_pref;	/* preferred A-MSDU MTU */
include/proto/802.11.h:1816:#define	BRF1_AMSDU		0x1	/* A-MSDU capable */
include/proto/802.11.h:1818:#define BRF1_PSOFIX		0x8	/* AP has fixed PS mode out-of-order packets */
include/proto/802.11.h:1838:#define MCSSET_LEN	16	/* 16-bits per 8-bit set to give 128-bits bitmap of MCS Index */
include/proto/802.11.h:1885:#define HT_CAP_LSIG_TXOP	0x8000	/* L-SIG TXOP protection support */
include/proto/802.11.h:1889:#define HT_CAP_RX_STBC_TWO_STREAM	0x2	/* rx STBC support of 1-2 spatial streams */
include/proto/802.11.h:1890:#define HT_CAP_RX_STBC_THREE_STREAM	0x3	/* rx STBC support of 1-3 spatial streams */
include/proto/802.11.h:1893:#define VHT_MPDU_MSDU_DELTA	56		/* Difference in spec - vht mpdu, amsdu len */
include/proto/802.11.h:1894:/* Max AMSDU len - per spec */
include/proto/802.11.h:1895:#define VHT_MAX_AMSDU		(VHT_MAX_MPDU - VHT_MPDU_MSDU_DELTA)
include/proto/802.11.h:1965:#define HT_OPMODE_NONGF	0x0004	/* protection mode non-GF */
include/proto/802.11.h:1967:#define DOT11N_OBSS_NONHT	0x0010	/* OBSS Non-HT STA present */
include/proto/802.11.h:1973:#define HT_LSIG_TXOP		0x0200	/* L-SIG TXOP Protection full support */
include/proto/802.11.h:1983:#define GET_HT_OPMODE(add_ie)		((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) \
include/proto/802.11.h:1985:#define HT_MIXEDMODE_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) \
include/proto/802.11.h:1987:#define HT_HT20_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) \
include/proto/802.11.h:1989:#define HT_OPTIONAL_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) \
include/proto/802.11.h:1993:#define HT_NONGF_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_NONGF) \
include/proto/802.11.h:1994:					== HT_OPMODE_NONGF)	/* non-GF present */
include/proto/802.11.h:1995:#define DOT11N_TXBURST_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & DOT11N_TXBURST) \
include/proto/802.11.h:1997:#define DOT11N_OBSS_NONHT_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & DOT11N_OBSS_NONHT) \
include/proto/802.11.h:1998:					== DOT11N_OBSS_NONHT)	/* OBSS Non-HT present */
include/proto/802.11.h:2037:#define HT_CTRL_CSI_STEER_NCOM	2		/* non-compressed beamforming */
include/proto/802.11.h:2046:#define HT_OPMODE_NONGF	0x0004	/* protection mode non-GF */
include/proto/802.11.h:2048:#define DOT11N_OBSS_NONHT	0x0010	/* OBSS Non-HT STA present */
include/proto/802.11.h:2054:	/* supported MCS set - 64 bit field */
include/proto/802.11.h:2063:/* 32bit - cap info */
include/proto/802.11.h:2091:/* 64-bit Supp MCS. */
include/proto/802.11.h:2137:/* Def for rx & tx basic mcs maps - ea ss num has 2 bits of info */
include/proto/802.11.h:2138:#define VHT_MCS_MAP_GET_SS_IDX(nss) (((nss)-1)*2)
include/proto/802.11.h:2181:#define RSN_AKM_PSK		2	/* Pre-shared Key */
include/proto/802.11.h:2183:#define RSN_AKM_FBT_PSK		4	/* Fast Bss transition using Pre-shared Key */
include/proto/802.11.h:2185:#define RSN_AKM_MFP_PSK		6	/* SHA256 key derivation, using Pre-shared Key */
include/proto/bt_amp_hci.h:2: * BT-AMP (BlueTooth Alternate Mac and Phy) HCI (Host/Controller Interface)
include/proto/bt_amp_hci.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/bt_amp_hci.h:24: * $Id: bt_amp_hci.h 294267 2011-11-04 23:41:52Z $
include/proto/bt_amp_hci.h:409:	uint16	handle;			/* 12-bit connection handle + 2-bit PB and 2-bit BC flags */
include/proto/802.1d.h:2: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/802.1d.h:24: * $Id: 802.1d.h 241182 2011-02-17 21:50:03Z $
include/proto/802.1d.h:31:#define	PRIO_8021D_NONE		2	/* None = - */
include/proto/802.1d.h:32:#define	PRIO_8021D_BK		1	/* BK - Background */
include/proto/802.1d.h:33:#define	PRIO_8021D_BE		0	/* BE - Best-effort */
include/proto/802.1d.h:34:#define	PRIO_8021D_EE		3	/* EE - Excellent-effort */
include/proto/802.1d.h:35:#define	PRIO_8021D_CL		4	/* CL - Controlled Load */
include/proto/802.1d.h:36:#define	PRIO_8021D_VI		5	/* Vi - Video */
include/proto/802.1d.h:37:#define	PRIO_8021D_VO		6	/* Vo - Voice */
include/proto/802.1d.h:38:#define	PRIO_8021D_NC		7	/* NC - Network Control */
include/proto/802.1d.h:39:#define	MAXPRIO			7	/* 0-7 */
include/proto/802.1d.h:42:#define ALLPRIO		-1	/* All prioirty */
include/proto/wpa.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/wpa.h:24: * $Id: wpa.h 261155 2011-05-23 23:51:32Z $
include/proto/wpa.h:39:/* 13 through 23 taken from IEEE Std 802.11i-2004 */
include/proto/wpa.h:42:#define DOT11_RC_4WH_TIMEOUT		15	/* 4-way handshake timeout */
include/proto/wpa.h:44:#define DOT11_RC_WPA_IE_MISMATCH	17	/* WPA IE in 4-way handshake differs from
include/proto/wpa.h:45:						 * (re-)assoc. request/probe response
include/proto/wpa.h:113:#define WPA_CIPHER_WEP_40	1	/* WEP (40-bit) */
include/proto/wpa.h:117:#define WPA_CIPHER_WEP_104	5	/* WEP (104-bit) */
include/proto/wpa.h:118:#define WPA_CIPHER_BIP		6	/* WEP (104-bit) */
include/proto/vlan.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/vlan.h:24: * $Id: vlan.h 241182 2011-02-17 21:50:03Z $
include/proto/802.11_bta.h:2: * BT-AMP (BlueTooth Alternate Mac and Phy) 802.11 PAL (Protocol Adaptation Layer)
include/proto/802.11_bta.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/802.11_bta.h:24: * $Id: 802.11_bta.h 294267 2011-11-04 23:41:52Z $
include/proto/802.11_bta.h:32:/* BT-AMP 802.11 PAL Protocols */
include/proto/802.11_bta.h:39:/* BT-AMP 802.11 PAL AMP_ASSOC Type IDs */
include/proto/802.11e.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/802.11e.h:24: * $Id: 802.11e.h 241182 2011-02-17 21:50:03Z $
include/proto/802.11e.h:73:	uint16 surplus_bw;			/* Surplus Bandwidth Allowance (range 1.0-8.0) */
include/proto/802.11e.h:77:#define WME_TSPEC_LEN	(sizeof(tspec_t))		/* not including 2-bytes of header */
include/proto/802.11e.h:80:/* 802.1D priority is duplicated - bits 13-11 AND bits 3-1 */
include/proto/802.11e.h:118:#define DOT11E_STATUS_ADDTS_REFUSED_NSBW	3	/* ADDTS refused (non-sufficient BW) */
include/proto/ethernet.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/ethernet.h:24: * $Id: ethernet.h 309193 2012-01-19 00:03:57Z $
include/proto/ethernet.h:88:#define ETHER_TYPE_89_0D	0x890d		/* 89-0d frame for TDLS */
include/proto/ethernet.h:126: * Structure of a 48-bit Ethernet address.
include/proto/ethernet.h:135: * address bit in the 48-bit Ethernet address.
include/proto/ethernet.h:146: * Takes a pointer, returns true if a 48-bit multicast address
include/proto/ethernet.h:152:/* compare two ethernet addresses - assumes the pointers can be referenced as shorts */
include/proto/ethernet.h:157:/* copy an ethernet address - assumes the pointers can be referenced as shorts */
include/proto/p2p.h:2: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/p2p.h:24: * $Id: p2p.h 356417 2012-09-12 16:41:24Z $
include/proto/p2p.h:64:#define P2P_ATTR_HDR_LEN	3 /* ID + 2-byte length field spec 1.02 */
include/proto/p2p.h:86:#define P2P_SEID_VNDR			221	/* Vendor-specific subelement */
include/proto/p2p.h:112:#define P2P_CAPSE_GRP_INTRA_BSS		0x8 /* Intra-BSS Distribution */
include/proto/p2p.h:336:	uint8	OUI[3];		/* OUI - P2P_OUI */
include/proto/p2p.h:337:	uint8	type;		/* OUI Type - P2P_VER */
include/proto/p2p.h:338:	uint8	subtype;	/* OUI Subtype - P2P_AF_* */
include/proto/p2p.h:341:				 * ACTION_FRAME_SIZE - sizeof(this structure) - 1
include/proto/p2p.h:361:	uint8	oui_type;	/* OUI type - P2P_VER */
include/proto/p2p.h:362:	uint8	subtype;	/* OUI subtype - P2P_TYPE_* */
include/proto/p2p.h:365:				 * ACTION_FRAME_SIZE - sizeof(this structure) - 1
include/proto/p2p.h:439:				/* Query Response Length Limit 7 bits plus PAME-BI 1 bit */
include/proto/p2p.h:470:	uint8	llm_pamebi;	/* Query Response Length Limit bit 0-6, set to 0 plus
include/proto/p2p.h:471:				* Pre-Associated Message Exchange BSSID Independent bit 7, set to 0
include/proto/p2p.h:479:	uint8	id;		/* IE ID: 0x6c - 108 */
include/proto/p2p.h:487:/* NQP Vendor-specific Content */
include/proto/p2p.h:511:	uint8	qreq_vsc[1]; /* Vendor-specific Content: wifi_p2psd_nqp_query_vsc_t type for NQP */
include/proto/p2p.h:539:	uint8	qresp_vsc[1]; /* Vendor-specific Content: wifi_p2psd_qresp_tlv_t type for NQP */
include/proto/p2p.h:546:	uint16	status;			/* Value defined in Table 7-23 of IEEE P802.11u */
include/proto/p2p.h:556:	uint16	status;			/* Value defined in Table 7-23 of IEEE P802.11u */
include/proto/p2p.h:565:/* Wi-Fi GAS Public Action Frame */
include/proto/bcmip.h:2: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/bcmip.h:24: * $Id: bcmip.h 290206 2011-10-17 19:13:51Z $
include/proto/bcmip.h:58:#define IPV4_PKTFLAG_OFFSET	6	/* more-frag,dont-frag flag offset */
include/proto/bcmip.h:169:#define IPV6_EXTHDR_LEN(eh)	((((struct ipv6_exthdr *)(eh))->hdrlen + 1) << 3)
include/proto/bcmip.h:189:	while (IPV6_EXTHDR(eh->nexthdr)) {
include/proto/bcmip.h:190:		if (eh->nexthdr == IPV6_EXTHDR_NONE)
include/proto/bcmip.h:191:			return -1;
include/proto/bcmip.h:192:		else if (eh->nexthdr == IPV6_EXTHDR_FRAGMENT)
include/proto/bcmip.h:194:		else if (eh->nexthdr == IPV6_EXTHDR_AUTH)
include/proto/bcmip.h:195:			hlen = (eh->hdrlen + 2) << 2;
include/proto/bcmip.h:203:	*proto = eh->nexthdr;
include/proto/bcmeth.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/bcmeth.h:24: * $Id: bcmeth.h 294352 2011-11-06 19:23:00Z $
include/proto/bcmeth.h:45: * in one of two formats: (only subtypes 32768-65535 are in use now)
include/proto/bcmeth.h:47: * subtypes 0-32767:
include/proto/bcmeth.h:48: *     8 bit subtype (0-127)
include/proto/bcmeth.h:49: *     8 bit length in bytes (0-255)
include/proto/bcmeth.h:51: * subtypes 32768-65535:
include/proto/bcmeth.h:52: *     16 bit big-endian subtype
include/proto/bcmeth.h:53: *     16 bit big-endian length in bytes (0-65535)
include/proto/bcmeth.h:59: * 5-15 reserved for iLine protocol assignments
include/proto/bcmeth.h:60: * 17-126 reserved, assignable
include/proto/bcmeth.h:63: * 32769-65534 reserved, assignable
include/proto/bcmevent.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/bcmevent.h:26: * $Id: bcmevent.h 374275 2012-12-12 11:44:18Z $
include/proto/bcmevent.h:95:#define BCM_MSG_LEN	(sizeof(bcm_event_t) - sizeof(bcmeth_hdr_t) - sizeof(struct ether_header))
include/proto/bcmevent.h:150:#define WLC_E_BTA_HCI_EVENT	53	/* BT-AMP HCI event */
include/proto/bcmevent.h:160:#define WLC_E_PRE_REASSOC_IND	62	/* re-assoc request received */
include/proto/bcmevent.h:263:#define WLC_E_PRUNE_QBSS_LOAD		16	/* QBSS LOAD - AAC is too low */
include/proto/bcmevent.h:275:#define WLC_E_SUP_NO_INSTALL_FLAG	8	/* INSTALL flag unset in 4-way msg */
include/proto/bcmevent.h:282:#define WLC_E_SUP_WPA_PSK_TMO		15	/* WPA PSK 4-way handshake timeout */
include/proto/bcmevent.h:320:#define WLC_E_IF_ROLE_BTA_CREATOR	5	/* BT-AMP Creator */
include/proto/bcmevent.h:321:#define WLC_E_IF_ROLE_BTA_ACCEPTOR	6	/* BT-AMP Acceptor */
include/proto/eapol.h:5: * IEEE Std 802.1X-2001
include/proto/eapol.h:10: * $Id: eapol.h 241182 2011-02-17 21:50:03Z $
include/proto/eapol.h:57:/* EAPOL-Key types */
include/proto/eapol.h:62:/* RC4 EAPOL-Key header field sizes */
include/proto/eapol.h:67:/* RC4 EAPOL-Key */
include/proto/eapol.h:80:/* RC4 EAPOL-Key flags */
include/proto/eapol.h:85:/* RC4 EAPOL-Key index */
include/proto/eapol.h:88:/* WPA/802.11i/WPA2 EAPOL-Key header field sizes */
include/proto/eapol.h:98:/* WPA EAPOL-Key */
include/proto/eapol.h:129:/* WPA-only KEY KEY_INFO bits */
include/proto/eapol.h:137:/* 802.11i/WPA2-only KEY KEY_INFO bits */
include/proto/sdspi.h:2: * SD-SPI Protocol Standard
include/proto/sdspi.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/proto/sdspi.h:24: * $Id: sdspi.h 241182 2011-02-17 21:50:03Z $
include/proto/sdspi.h:29:#define SPI_START_M		BITFIELD_MASK(1)	/* Bit [31] 	- Start Bit */
include/proto/sdspi.h:31:#define SPI_DIR_M		BITFIELD_MASK(1)	/* Bit [30] 	- Direction */
include/proto/sdspi.h:33:#define SPI_CMD_INDEX_M		BITFIELD_MASK(6)	/* Bits [29:24] - Command number */
include/proto/sdspi.h:35:#define SPI_RW_M		BITFIELD_MASK(1)	/* Bit [23] 	- Read=0, Write=1 */
include/proto/sdspi.h:37:#define SPI_FUNC_M		BITFIELD_MASK(3)	/* Bits [22:20]	- Function Number */
include/proto/sdspi.h:39:#define SPI_RAW_M		BITFIELD_MASK(1)	/* Bit [19] 	- Read After Wr */
include/proto/sdspi.h:41:#define SPI_STUFF_M		BITFIELD_MASK(1)	/* Bit [18] 	- Stuff bit */
include/proto/sdspi.h:43:#define SPI_BLKMODE_M		BITFIELD_MASK(1)	/* Bit [19] 	- Blockmode 1=blk */
include/proto/sdspi.h:45:#define SPI_OPCODE_M		BITFIELD_MASK(1)	/* Bit [18] 	- OP Code */
include/proto/sdspi.h:47:#define SPI_ADDR_M		BITFIELD_MASK(17)	/* Bits [17:1] 	- Address */
include/proto/sdspi.h:49:#define SPI_STUFF0_M		BITFIELD_MASK(1)	/* Bit [0] 	- Stuff bit */
include/proto/sdspi.h:52:#define SPI_RSP_START_M		BITFIELD_MASK(1)	/* Bit [7] 	- Start Bit (always 0) */
include/proto/sdspi.h:54:#define SPI_RSP_PARAM_ERR_M	BITFIELD_MASK(1)	/* Bit [6] 	- Parameter Error */
include/proto/sdspi.h:56:#define SPI_RSP_RFU5_M		BITFIELD_MASK(1)	/* Bit [5] 	- RFU (Always 0) */
include/proto/sdspi.h:58:#define SPI_RSP_FUNC_ERR_M	BITFIELD_MASK(1)	/* Bit [4] 	- Function number error */
include/proto/sdspi.h:60:#define SPI_RSP_CRC_ERR_M	BITFIELD_MASK(1)	/* Bit [3] 	- COM CRC Error */
include/proto/sdspi.h:62:#define SPI_RSP_ILL_CMD_M	BITFIELD_MASK(1)	/* Bit [2] 	- Illegal Command error */
include/proto/sdspi.h:64:#define SPI_RSP_RFU1_M		BITFIELD_MASK(1)	/* Bit [1] 	- RFU (Always 0) */
include/proto/sdspi.h:66:#define SPI_RSP_IDLE_M		BITFIELD_MASK(1)	/* Bit [0] 	- In idle state */
include/proto/sdspi.h:69:/* SD-SPI Protocol Definitions */
include/proto/sdspi.h:72:#define SDSPI_IDLE_PAD		0xFF	/* SD-SPI idle value for MOSI */
include/bcm_mpool_pub.h:10: * on a per-data-structure basis and system wide.
include/bcm_mpool_pub.h:38: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcm_mpool_pub.h:128: * bcm_mpm_init() - initialize the whole memory pool system.
include/bcm_mpool_pub.h:143: * bcm_mpm_deinit() - de-initialize the whole memory pool system.
include/bcm_mpool_pub.h:149: *    BCME_OK  Memory pool manager successfully de-initialized.
include/bcm_mpool_pub.h:150: *    other    Indicated error occured during de-initialization.
include/bcm_mpool_pub.h:155: * bcm_mpm_create_prealloc_pool() - Create a new pool for fixed size objects. The
include/bcm_mpool_pub.h:156: *                                  pool uses a contiguous block of pre-alloced
include/bcm_mpool_pub.h:188: * bcm_mpm_delete_prealloc_pool() - Delete a memory pool. This should only be called after
include/bcm_mpool_pub.h:203: * bcm_mpm_create_heap_pool() - Create a new pool for fixed size objects. The memory
include/bcm_mpool_pub.h:227: * bcm_mpm_delete_heap_pool() - Delete a memory pool. This should only be called after
include/bcm_mpool_pub.h:243: * bcm_mpm_stats() - Return stats for all pools
include/bcm_mpool_pub.h:260: * bcm_mpm_dump() - Display statistics on all pools
include/bcm_mpool_pub.h:275: * bcm_mpm_get_obj_size() - The size of memory objects may need to be padded to
include/bcm_mpool_pub.h:278: *                          pre-allocate a memory slab for a memory pool, the
include/bcm_mpool_pub.h:306: * bcm_mp_alloc() - Allocate a memory pool object.
include/bcm_mpool_pub.h:318: * bcm_mp_free() - Free a memory pool object.
include/bcm_mpool_pub.h:332: * bcm_mp_stats() - Return stats for this pool
include/bcm_mpool_pub.h:347: * bcm_mp_dump() - Dump a pool
include/bcmsdh_sdmmc.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmsdh_sdmmc.h:24: * $Id: bcmsdh_sdmmc.h 366812 2012-11-05 13:49:32Z $
include/bcmsdh_sdmmc.h:44:/* Allocate/init/free per-OS private data */
include/bcmsdh_sdmmc.h:73:	void		*sdos_info;		/* Pointer to per-OS private data */
include/bcmsdh_sdmmc.h:94: * Internal interfaces: per-port references into bcmsdh_sdmmc.c
include/bcmsdh_sdmmc.h:100:/* OS-independent interrupt handler */
include/bcmsdh_sdmmc.h:109: * Internal interfaces: bcmsdh_sdmmc.c references to per-port code
include/wlfc_proto.h:2:* Copyright (C) 1999-2012, Broadcom Corporation
include/wlfc_proto.h:21:* $Id: wlfc_proto.h 361006 2012-10-05 07:45:51Z $
include/wlfc_proto.h:28:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:30:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:32:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:34:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:36:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:38:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:39:	|  5   |   4  | see pkttag comments      | PKKTTAG [host->firmware]
include/wlfc_proto.h:40:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:42:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:44:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:45:	|  8   |   1  | (rssi)                   | RSSI - RSSI value for the packet.
include/wlfc_proto.h:46:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:48:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:50:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:53:	|      |      |                          | --------------------------------------
include/wlfc_proto.h:55:	|      |      |                          | --------------------------------------
include/wlfc_proto.h:57:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:59:	|      |      | AC[0-3] traffic bitmap   | unicast traffic for MAC-handle dstn.
include/wlfc_proto.h:60:	|      |      |                          | [host->firmware]
include/wlfc_proto.h:61:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:64:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:66:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:68:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:70:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:71:	| 255  |  N/A |  N/A                     | FILLER - This is a special type
include/wlfc_proto.h:74:	 ---------------------------------------------------------------------------
include/wlfc_proto.h:106:#define WLFC_CTL_VALUE_LEN_MAC			1	/* MAC-handle */
include/wlfc_proto.h:118:#define WLFC_CTL_VALUE_LEN_REQUEST_CREDIT	3	/* credit, MAC-handle, prec_bitmap */
include/wlfc_proto.h:119:#define WLFC_CTL_VALUE_LEN_REQUEST_PACKET	3	/* credit, MAC-handle, prec_bitmap */
include/wlfc_proto.h:163:/* b[7:5] -reuse guard, b[4:0] -value */
include/wlfc_proto.h:196:	(((txs)->status.suppr_ind != 0) ? WLFC_CTL_PKTFLAG_D11SUPPRESS : WLFC_CTL_PKTFLAG_DISCARD)
include/wlfc_proto.h:200:/* wlfc-breadcrumb */
include/wlfc_proto.h:230:/* transaction id data len byte 0: rsvd, byte 1: seqnumber, byte 2-5 will be used for timestampe */
include/osl.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/osl.h:24: * $Id: osl.h 320905 2012-03-13 15:33:25Z $
include/osl.h:52:/* --------------------------------------------------------------------------
include/miniopt.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/miniopt.h:23: * $Id: miniopt.h 241182 2011-02-17 21:50:03Z $
include/miniopt.h:34:/* ---- Include Files ---------------------------------------------------- */
include/miniopt.h:35:/* ---- Constants and Types ---------------------------------------------- */
include/miniopt.h:44:	bool opt_end;		/* at end of options (passed a "--") */
include/miniopt.h:46:	/* These are per-call to miniopt() */
include/miniopt.h:69:/* ---- Variable Externs ------------------------------------------------- */
include/miniopt.h:70:/* ---- Function Prototypes ---------------------------------------------- */
include/bcmdefs.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmdefs.h:24: * $Id: bcmdefs.h 316830 2012-02-23 20:29:22Z $
include/bcmdefs.h:35:/* Use BCM_REFERENCE to suppress warnings about intentionally-unused function
include/bcmdefs.h:40:/* Compile-time assert can be used in place of ASSERT if the expression evaluates
include/bcmdefs.h:47:	typedef char STATIC_ASSERT_FAIL[(expr) ? 1 : -1]; \
include/bcmdefs.h:95:/* Allows size optimization for single-bus image */
include/bcmdefs.h:102:/* Allows size optimization for single-backplane image */
include/bcmdefs.h:119:/* Allows size optimization for single-chip image */
include/bcmdefs.h:132:/* Defines for DMA Address Width - Shared between OSL and HNDDMA */
include/bcmdefs.h:133:#define DMADDR_MASK_32 0x0		/* Address mask for 32-bits */
include/bcmdefs.h:134:#define DMADDR_MASK_30 0xc0000000	/* Address mask for 30-bits */
include/bcmdefs.h:135:#define DMADDR_MASK_0  0xffffffff	/* Address mask for 0-bits (hi-part) */
include/bcmdefs.h:137:#define	DMADDRWIDTH_30  30 /* 30-bit addressing capability */
include/bcmdefs.h:138:#define	DMADDRWIDTH_32  32 /* 32-bit addressing capability */
include/bcmdefs.h:139:#define	DMADDRWIDTH_63  63 /* 64-bit addressing capability */
include/bcmdefs.h:140:#define	DMADDRWIDTH_64  64 /* 64-bit addressing capability */
include/bcmdefs.h:206:/* Headroom required for dongle-to-host communication.  Packets allocated
include/bcmdefs.h:208: * leave this much room in front for low-level message headers which may
include/bcmdefs.h:229: * Usage example, e.g. a three-bit field (bits 4-6):
include/bcmdefs.h:233: *    regval = R_REG(osh, &regs->regfoo);
include/bcmdefs.h:236: *    W_REG(osh, &regs->regfoo, regval);
include/bcmdefs.h:239:		(((unsigned)1 << (width)) - 1)
include/bcmdefs.h:246:/* define BCMSMALL to remove misc features for memory-constrained environments */
include/hndsoc.h:2: * Broadcom HND chip & on-chip-interconnect-related definitions.
include/hndsoc.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/hndsoc.h:24: * $Id: hndsoc.h 309193 2012-01-19 00:03:57Z $
include/hndsoc.h:54:#define	SI_FASTRAM		0x19000000	/* On-chip RAM on chips that also have DDR */
include/hndsoc.h:59:#define	SI_ARMCM3_ROM		0x1e000000	/* ARM Cortex-M3 ROM */
include/hndsoc.h:62:#define	SI_ARM7S_ROM		0x20000000	/* ARM7TDMI-S ROM */
include/hndsoc.h:63:#define	SI_ARMCR4_ROM		0x000f0000	/* ARM Cortex-R4 ROM */
include/hndsoc.h:64:#define	SI_ARMCM3_SRAM2		0x60000000	/* ARM Cortex-M3 SRAM Region 2 */
include/hndsoc.h:65:#define	SI_ARM7S_SRAM2		0x80000000	/* ARM7TDMI-S SRAM Region 2 */
include/hndsoc.h:118:#define	ARM7S_CORE_ID		0x825		/* ARM7tdmi-s core */
include/hndsoc.h:121:#define	SSNPHY_CORE_ID		0x828		/* 802.11n single-stream phy core */
include/hndsoc.h:233:#define BISZ_SIZE		7		/* descriptor size in 32-bit integers */
include/bcmspi.h:2: * Broadcom SPI Low-Level Hardware Driver API
include/bcmspi.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmspi.h:24: * $Id: bcmspi.h 241182 2011-02-17 21:50:03Z $
include/linuxver.h:2: * Linux-specific abstractions to gain some independence from linux kernel versions.
include/linuxver.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
include/linuxver.h:25: * $Id: linuxver.h 366812 2012-11-05 13:49:32Z $
include/linuxver.h:109:		strncpy(current->comm, a, MIN(sizeof(current->comm), (strlen(a)))); \
include/linuxver.h:186:#define pci_get_drvdata(dev)		(dev)->sysdata
include/linuxver.h:187:#define pci_set_drvdata(dev, value)	(dev)->sysdata = (value)
include/linuxver.h:190: * New-style (2.4.x) PCI/hot-pluggable PCI/CardBus registration
include/linuxver.h:196:	unsigned int class, class_mask;		/* (class,subclass,prog-if) triplet */
include/linuxver.h:206:	void (*remove)(struct pci_dev *dev);	/* Device removed (NULL if not a hot-plug
include/linuxver.h:251:	for (pos = (head)->next; pos != (head); pos = pos->next)
include/linuxver.h:255:#define pci_resource_start(dev, bar)	((dev)->base_address[(bar)])
include/linuxver.h:257:#define pci_resource_start(dev, bar)	((dev)->resource[(bar)].start)
include/linuxver.h:273: * See linux/Documentation/DMA-mapping.txt
include/linuxver.h:288:	size = (size-1) >> (PAGE_SHIFT-1);
include/linuxver.h:289:	order = -1;
include/linuxver.h:324:#define netif_down(dev)			do { (dev)->start = 0; } while (0)
include/linuxver.h:326:/* pcmcia-cs provides its own netdevice compatibility layer */
include/linuxver.h:332: * For pre-softnet kernels we need to tell the upper layer not to
include/linuxver.h:333: * re-enter start_xmit() while we are in there. However softnet
include/linuxver.h:342:		do { clear_bit(0, &(dev)->tbusy); mark_bh(NET_BH); } while (0)
include/linuxver.h:343:#define netif_stop_queue(dev)	set_bit(0, &(dev)->tbusy)
include/linuxver.h:347:	dev->tbusy = 0;
include/linuxver.h:348:	dev->interrupt = 0;
include/linuxver.h:349:	dev->start = 1;
include/linuxver.h:352:#define netif_queue_stopped(dev)	(dev)->tbusy
include/linuxver.h:353:#define netif_running(dev)		(dev)->start
include/linuxver.h:372:	tasklet->next = NULL;
include/linuxver.h:373:	tasklet->sync = 0;
include/linuxver.h:374:	tasklet->routine = (void (*)(void *))func;
include/linuxver.h:375:	tasklet->data = (void *)data;
include/linuxver.h:395:		(_tq)->routine = _routine;			\
include/linuxver.h:396:		(_tq)->data = _data;				\
include/linuxver.h:404:		INIT_LIST_HEAD(&(_tq)->list);			\
include/linuxver.h:405:		(_tq)->sync = 0;				\
include/linuxver.h:443:	 * This works around a problem where warm-booting from Windows
include/linuxver.h:444:	 * combined with a D3(hot)->D0 transition causes PCI config
include/linuxver.h:452:		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
include/linuxver.h:539:	sema_init(&((tsk_ctl)->sema), 0); \
include/linuxver.h:540:	init_completion(&((tsk_ctl)->completed)); \
include/linuxver.h:541:	(tsk_ctl)->parent = owner; \
include/linuxver.h:542:	(tsk_ctl)->terminated = FALSE; \
include/linuxver.h:543:	(tsk_ctl)->thr_pid = kernel_thread(thread_func, tsk_ctl, flags); \
include/linuxver.h:544:	DBG_THR(("%s thr:%lx created\n", __FUNCTION__, (tsk_ctl)->thr_pid)); \
include/linuxver.h:545:	if ((tsk_ctl)->thr_pid > 0) \
include/linuxver.h:546:		wait_for_completion(&((tsk_ctl)->completed)); \
include/linuxver.h:547:	DBG_THR(("%s thr:%lx started\n", __FUNCTION__, (tsk_ctl)->thr_pid)); \
include/linuxver.h:553:	sema_init(&((tsk_ctl)->sema), 0); \
include/linuxver.h:554:	init_completion(&((tsk_ctl)->completed)); \
include/linuxver.h:555:	(tsk_ctl)->parent = owner; \
include/linuxver.h:556:	(tsk_ctl)->terminated = FALSE; \
include/linuxver.h:557:	(tsk_ctl)->p_task  = kthread_run(thread_func, tsk_ctl, (char*)name); \
include/linuxver.h:558:	(tsk_ctl)->thr_pid = (tsk_ctl)->p_task->pid; \
include/linuxver.h:559:	DBG_THR(("%s thr:%lx created\n", __FUNCTION__, (tsk_ctl)->thr_pid)); \
include/linuxver.h:565:	(tsk_ctl)->terminated = TRUE; \
include/linuxver.h:567:	up(&((tsk_ctl)->sema));	\
include/linuxver.h:568:	wait_for_completion(&((tsk_ctl)->completed)); \
include/linuxver.h:569:	DBG_THR(("%s thr:%lx terminated OK\n", __FUNCTION__, (tsk_ctl)->thr_pid)); \
include/linuxver.h:570:	(tsk_ctl)->thr_pid = -1; \
include/linuxver.h:573:/*  ----------------------- */
include/linuxver.h:623:		ret = -ERESTARTSYS;					\
include/linuxver.h:626:	current->state = TASK_RUNNING;					\
include/linuxver.h:647:#define DEV_PRIV(dev)	(dev->priv)
include/linuxver.h:659:#define netdev_priv(dev) dev->priv
include/dhdioctl.h:8: * Copyright (C) 1999-2012, Broadcom Corporation
include/dhdioctl.h:28: * $Id: dhdioctl.h 354894 2012-09-04 12:34:07Z $
include/dhdioctl.h:59:/* per-driver magic numbers */
include/dhdioctl.h:126:#define DHD_IDLE_IMMEDIATE	(-1)
include/dhdioctl.h:130:#define DHD_IDLE_STOP   (-1)	/* Request SD clock be stopped (and use SD1 mode) */
include/siutils.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
include/siutils.h:25: * $Id: siutils.h 347614 2012-07-27 10:24:51Z $
include/siutils.h:33: *   public (read-only) portion of siutils handle returned by si_attach()/si_kattach()
include/siutils.h:115:#define PMUCTL_ENAB(sih)	((sih)->cccaps & CC_CAP_PMU)
include/siutils.h:123:#define CCCTL_ENAB(sih)		((sih)->cccaps & CC_CAP_PWR_CTL)
include/siutils.h:124:#define CCPLL_ENAB(sih)		((sih)->cccaps & CC_CAP_PLL_MASK)
include/siutils.h:238:/* Wake-on-wireless-LAN (WOWL) */
include/siutils.h:278:/* Fab-id information */
include/siutils.h:316:/* Enable BT-COEX & Ex-PA for 4313 */
include/typedefs.h:2: * Copyright (C) 1999-2012, Broadcom Corporation
include/typedefs.h:21: * $Id: typedefs.h 286783 2011-09-29 06:18:57Z $
include/typedefs.h:30: * Define SITE_TYPEDEFS in the compile to include a site-specific
include/typedefs.h:49: * Override type definitions as needed, and include configuration-dependent
include/typedefs.h:90: * If this is either a Linux hybrid build or the per-port code of a hybrid build
include/typedefs.h:94: * We know when it's per-port code because each file defines LINUX_PORT at the top.
include/typedefs.h:107:/* special detection for 2.6.18-128.7.1.0.1.el5 */
include/typedefs.h:245: * single or double precision arithmetic.  Compiling with -DFLOAT32
include/typedefs.h:281:#define	AUTO	(-1) /* Auto = -1 */
include/typedefs.h:335:/* Avoid warning for discarded const or volatile qualifier in special cases (-Wcast-qual) */
include/msgtrace.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/msgtrace.h:24: * $Id: msgtrace.h 281527 2011-09-02 17:12:53Z $
include/bcmsdspi.h:2: * SD-SPI Protocol Conversion - BCMSDH->SPI Translation Layer
include/bcmsdspi.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmsdspi.h:24: * $Id: bcmsdspi.h 294363 2011-11-06 23:02:20Z $
include/bcmsdspi.h:29:/* global msglevel for debug messages - bitvals come from sdiovar.h */
include/bcmsdspi.h:74:	void		*sdos_info;		/* Pointer to per-OS private data */
include/bcmsdspi.h:109: * Internal interfaces: per-port references into bcmsdspi.c
include/bcmsdspi.h:116: * Internal interfaces: bcmsdspi.c references to per-port code
include/bcmsdspi.h:127:/* OS-specific interrupt wrappers (atomic interrupt enable/disable) */
include/bcmsdspi.h:131:/* Allocate/init/free per-OS private data */
include/sdio.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
include/sdio.h:25: * $Id: sdio.h 308973 2012-01-18 04:19:34Z $
include/sdio.h:127:#define BUS_SD_DATA_WIDTH_4BIT	0x02	/* bus width 4-bit mode */
include/sdio.h:128:#define BUS_SD_DATA_WIDTH_1BIT	0x00	/* bus width 1-bit mode */
include/sdio.h:131:#define SDIO_CAP_4BLS		0x80	/* 4-bit support for low speed card */
include/sdio.h:133:#define SDIO_CAP_E4MI		0x20	/* enable interrupt between block of data in 4-bit mode */
include/sdio.h:134:#define SDIO_CAP_S4MI		0x10	/* support interrupt between block of data in 4-bit mode */
include/sdio.h:137:#define SDIO_CAP_SMB		0x02	/* support multi-block transfer */
include/sdio.h:138:#define SDIO_CAP_SDC		0x01	/* Support Direct commands during multi-byte transfer */
include/sdio.h:144:/* speed_control (control device entry into high-speed clocking mode) */
include/sdio.h:145:#define SDIO_SPEED_SHS		0x01	/* supports high-speed [clocking] mode (RO) */
include/sdio.h:146:#define SDIO_SPEED_EHS		0x02	/* enable high-speed [clocking] mode (RW) */
include/sdio.h:173:#define SDIO_SEPINT_MASK	0x01	/* route sdpcmdev intr onto separate pad (chip-specific) */
include/sdio.h:177:/* FBR structure for function 1-7, FBR addresses and register offsets */
include/sdio.h:245:#define SDIOD_PWR_SEL_EPS	0x02	/* enable power selection (low-current mode) */
include/sdio.h:371:/* ------------------------------------------------
include/sdio.h:376: * ------------------------------------------------
include/sdio.h:406:/* ------------------------------------------------
include/sdio.h:410: * ------------------------------------------------
include/sdio.h:430:#define CMD52_DATA_M		BITFIELD_MASK(8)  /* Bits [7:0]    - Write Data/Stuff bits of CMD52
include/sdio.h:433:#define CMD52_REG_ADDR_M	BITFIELD_MASK(17) /* Bits [25:9]   - register address */
include/sdio.h:435:#define CMD52_RAW_M		BITFIELD_MASK(1)  /* Bit  27       - Read after Write flag */
include/sdio.h:437:#define CMD52_FUNCTION_M	BITFIELD_MASK(3)  /* Bits [30:28]  - Function number */
include/sdio.h:439:#define CMD52_RW_FLAG_M		BITFIELD_MASK(1)  /* Bit  31       - R/W flag */
include/sdio.h:443:#define CMD53_BYTE_BLK_CNT_M	BITFIELD_MASK(9) /* Bits [8:0]     - Byte/Block Count of CMD53 */
include/sdio.h:445:#define CMD53_REG_ADDR_M	BITFIELD_MASK(17) /* Bits [25:9]   - register address */
include/sdio.h:447:#define CMD53_OP_CODE_M		BITFIELD_MASK(1)  /* Bit  26       - R/W Operation Code */
include/sdio.h:449:#define CMD53_BLK_MODE_M	BITFIELD_MASK(1)  /* Bit  27       - Block Mode */
include/sdio.h:451:#define CMD53_FUNCTION_M	BITFIELD_MASK(3)  /* Bits [30:28]  - Function number */
include/sdio.h:453:#define CMD53_RW_FLAG_M		BITFIELD_MASK(1)  /* Bit  31       - R/W flag */
include/sdio.h:456:/* ------------------------------------------------------
include/sdio.h:458: *  -----------------------------------------------------
include/sdio.h:460:#define RSP4_IO_OCR_M		BITFIELD_MASK(24) /* Bits [23:0]  - Card's OCR Bits [23:0] */
include/sdio.h:463:#define RSP4_S18A_M			BITFIELD_MASK(1) /* Bits [23:0]  - Card's OCR Bits [23:0] */
include/sdio.h:466:#define RSP4_STUFF_M		BITFIELD_MASK(3)  /* Bits [26:24] - Stuff bits */
include/sdio.h:468:#define RSP4_MEM_PRESENT_M	BITFIELD_MASK(1)  /* Bit  27      - Memory present */
include/sdio.h:470:#define RSP4_NUM_FUNCS_M	BITFIELD_MASK(3)  /* Bits [30:28] - Number of I/O funcs */
include/sdio.h:472:#define RSP4_CARD_READY_M	BITFIELD_MASK(1)  /* Bit  31      - SDIO card ready */
include/sdio.h:475:#define RSP6_STATUS_M		BITFIELD_MASK(16) /* Bits [15:0]  - Card status bits [19,22,23,12:0]
include/sdio.h:478:#define RSP6_IO_RCA_M		BITFIELD_MASK(16) /* Bits [31:16] - RCA bits[31-16] */
include/sdio.h:481:#define RSP1_AKE_SEQ_ERROR_M	BITFIELD_MASK(1)  /* Bit 3       - Authentication seq error */
include/sdio.h:483:#define RSP1_APP_CMD_M		BITFIELD_MASK(1)  /* Bit 5       - Card expects ACMD */
include/sdio.h:485:#define RSP1_READY_FOR_DATA_M	BITFIELD_MASK(1)  /* Bit 8       - Ready for data (buff empty) */
include/sdio.h:487:#define RSP1_CURR_STATE_M	BITFIELD_MASK(4)  /* Bits [12:9] - State of card
include/sdio.h:491:#define RSP1_EARSE_RESET_M	BITFIELD_MASK(1)  /* Bit 13   - Erase seq cleared */
include/sdio.h:493:#define RSP1_CARD_ECC_DISABLE_M	BITFIELD_MASK(1)  /* Bit 14   - Card ECC disabled */
include/sdio.h:495:#define RSP1_WP_ERASE_SKIP_M	BITFIELD_MASK(1)  /* Bit 15   - Partial blocks erased due to W/P */
include/sdio.h:497:#define RSP1_CID_CSD_OVERW_M	BITFIELD_MASK(1)  /* Bit 16   - Illegal write to CID or R/O bits
include/sdio.h:501:#define RSP1_ERROR_M		BITFIELD_MASK(1)  /* Bit 19   - General/Unknown error */
include/sdio.h:503:#define RSP1_CC_ERROR_M		BITFIELD_MASK(1)  /* Bit 20   - Internal Card Control error */
include/sdio.h:505:#define RSP1_CARD_ECC_FAILED_M	BITFIELD_MASK(1)  /* Bit 21   - Card internal ECC failed
include/sdio.h:509:#define RSP1_ILLEGAL_CMD_M	BITFIELD_MASK(1)  /* Bit 22   - Cmd not legal for the card state */
include/sdio.h:511:#define RSP1_COM_CRC_ERROR_M	BITFIELD_MASK(1)  /* Bit 23   - CRC check of previous command failed
include/sdio.h:514:#define RSP1_LOCK_UNLOCK_FAIL_M	BITFIELD_MASK(1)  /* Bit 24   - Card lock-unlock Cmd Seq error */
include/sdio.h:516:#define RSP1_CARD_LOCKED_M	BITFIELD_MASK(1)  /* Bit 25   - Card locked by the host */
include/sdio.h:518:#define RSP1_WP_VIOLATION_M	BITFIELD_MASK(1)  /* Bit 26   - Attempt to program
include/sdio.h:519:						   * write-protected blocks
include/sdio.h:522:#define RSP1_ERASE_PARAM_M	BITFIELD_MASK(1)  /* Bit 27   - Invalid erase blocks */
include/sdio.h:524:#define RSP1_ERASE_SEQ_ERR_M	BITFIELD_MASK(1)  /* Bit 28   - Erase Cmd seq error */
include/sdio.h:526:#define RSP1_BLK_LEN_ERR_M	BITFIELD_MASK(1)  /* Bit 29   - Block length error */
include/sdio.h:528:#define RSP1_ADDR_ERR_M		BITFIELD_MASK(1)  /* Bit 30   - Misaligned address */
include/sdio.h:530:#define RSP1_OUT_OF_RANGE_M	BITFIELD_MASK(1)  /* Bit 31   - Cmd arg was out of range */
include/sdio.h:534:#define RSP5_DATA_M		BITFIELD_MASK(8)  /* Bits [0:7]   - data */
include/sdio.h:536:#define RSP5_FLAGS_M		BITFIELD_MASK(8)  /* Bit  [15:8]  - Rsp flags */
include/sdio.h:538:#define RSP5_STUFF_M		BITFIELD_MASK(16) /* Bits [31:16] - Stuff bits */
include/sdio.h:541:/* ----------------------------------------------
include/sdio.h:543: * ----------------------------------------------
include/sdio.h:545:#define SPIRSP4_IO_OCR_M	BITFIELD_MASK(16) /* Bits [15:0]    - Card's OCR Bits [23:8] */
include/sdio.h:547:#define SPIRSP4_STUFF_M		BITFIELD_MASK(3)  /* Bits [18:16]   - Stuff bits */
include/sdio.h:549:#define SPIRSP4_MEM_PRESENT_M	BITFIELD_MASK(1)  /* Bit  19        - Memory present */
include/sdio.h:551:#define SPIRSP4_NUM_FUNCS_M	BITFIELD_MASK(3)  /* Bits [22:20]   - Number of I/O funcs */
include/sdio.h:553:#define SPIRSP4_CARD_READY_M	BITFIELD_MASK(1)  /* Bit  23        - SDIO card ready */
include/sdio.h:555:#define SPIRSP4_IDLE_STATE_M	BITFIELD_MASK(1)  /* Bit  24        - idle state */
include/sdio.h:557:#define SPIRSP4_ILLEGAL_CMD_M	BITFIELD_MASK(1)  /* Bit  26        - Illegal Cmd error */
include/sdio.h:559:#define SPIRSP4_COM_CRC_ERROR_M	BITFIELD_MASK(1)  /* Bit  27        - COM CRC error */
include/sdio.h:561:#define SPIRSP4_FUNC_NUM_ERROR_M	BITFIELD_MASK(1)  /* Bit  28        - Function number error
include/sdio.h:564:#define SPIRSP4_PARAM_ERROR_M	BITFIELD_MASK(1)  /* Bit  30        - Parameter Error Bit */
include/sdio.h:566:#define SPIRSP4_START_BIT_M	BITFIELD_MASK(1)  /* Bit  31        - Start Bit */
include/sdio.h:569:#define SPIRSP5_DATA_M			BITFIELD_MASK(8)  /* Bits [23:16]   - R/W Data */
include/sdio.h:571:#define SPIRSP5_IDLE_STATE_M		BITFIELD_MASK(1)  /* Bit  24        - Idle state */
include/sdio.h:573:#define SPIRSP5_ILLEGAL_CMD_M		BITFIELD_MASK(1)  /* Bit  26        - Illegal Cmd error */
include/sdio.h:575:#define SPIRSP5_COM_CRC_ERROR_M		BITFIELD_MASK(1)  /* Bit  27        - COM CRC error */
include/sdio.h:577:#define SPIRSP5_FUNC_NUM_ERROR_M	BITFIELD_MASK(1)  /* Bit  28        - Function number error
include/sdio.h:580:#define SPIRSP5_PARAM_ERROR_M		BITFIELD_MASK(1)  /* Bit  30        - Parameter Error Bit */
include/sdio.h:582:#define SPIRSP5_START_BIT_M		BITFIELD_MASK(1)  /* Bit  31        - Start Bit */
include/sdio.h:586:#define RSP6STAT_AKE_SEQ_ERROR_M	BITFIELD_MASK(1)  /* Bit 3	- Authentication seq error
include/sdio.h:589:#define RSP6STAT_APP_CMD_M		BITFIELD_MASK(1)  /* Bit 5	- Card expects ACMD */
include/sdio.h:591:#define RSP6STAT_READY_FOR_DATA_M	BITFIELD_MASK(1)  /* Bit 8	- Ready for data
include/sdio.h:595:#define RSP6STAT_CURR_STATE_M		BITFIELD_MASK(4)  /* Bits [12:9] - Card state at
include/sdio.h:599:#define RSP6STAT_ERROR_M		BITFIELD_MASK(1)  /* Bit 13  - General/Unknown error Bit 19
include/sdio.h:602:#define RSP6STAT_ILLEGAL_CMD_M		BITFIELD_MASK(1)  /* Bit 14  - Illegal cmd for
include/sdio.h:606:#define RSP6STAT_COM_CRC_ERROR_M	BITFIELD_MASK(1)  /* Bit 15  - CRC previous command
include/hndrte_armtrap.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/hndrte_armtrap.h:24: * $Id: hndrte_armtrap.h 261365 2011-05-24 20:42:23Z $
include/bcmsdbus.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmsdbus.h:25: * $Id: bcmsdbus.h 347614 2012-07-27 10:24:51Z $
include/bcmsdbus.h:44:#define SDIOH_CMD_TYPE_CUTTHRU  2       /* Cut-through command */
include/bcmsdbus.h:55:#define SDPCM_TXGLOM_MDESC	1		/* SDIO 3.0 should use multi-desc mode */
include/bcmsdbus.h:126:/* Start and Stop SDIO without re-enumerating the SD card. */
include/bcmsdbus.h:133:/* Reset and re-initialize the device */
include/bcmwifi_channels.h:6: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmwifi_channels.h:26: * $Id: bcmwifi_channels.h 309193 2012-01-19 00:03:57Z $
include/bcmwifi_channels.h:50:#define CHSPEC_CTLOVLP(sp1, sp2, sep)	ABS(wf_chspec_ctlchan(sp1) - wf_chspec_ctlchan(sp2)) < (sep)
include/bcmwifi_channels.h:86:#define LOWER_20_SB(channel)	(((channel) > CH_10MHZ_APART) ? ((channel) - CH_10MHZ_APART) : 0)
include/bcmwifi_channels.h:87:#define UPPER_20_SB(channel)	(((channel) < (MAXCHANNEL - CH_10MHZ_APART)) ? \
include/bcmwifi_channels.h:93:#define NEXT_20MHZ_CHAN(channel)	(((channel) < (MAXCHANNEL - CH_20MHZ_APART)) ? \
include/bcmwifi_channels.h:184:					((channel) - CH_10MHZ_APART) : 0)
include/bcmwifi_channels.h:185:#define UPPER_20_SB(channel)		(((channel) < (MAXCHANNEL - CH_10MHZ_APART)) ? \
include/bcmwifi_channels.h:187:#define LOWER_40_SB(channel)		((channel) - CH_20MHZ_APART)
include/bcmwifi_channels.h:193:#define NEXT_20MHZ_CHAN(channel)	(((channel) < (MAXCHANNEL - CH_20MHZ_APART)) ? \
include/bcmwifi_channels.h:426: * frequencies from 5 - 6 GHz, and 2.407 GHz is assumed for 2.4 - 2.5 GHz.
include/bcmwifi_channels.h:435: * -1 is returned if the start_factor is WF_CHAN_FACTOR_2_4_G and the
include/bcmwifi_channels.h:465: * -1 is returned for an out of range channel.
include/bcmsdstd.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmsdstd.h:24: * $Id: bcmsdstd.h 347614 2012-07-27 10:24:51Z $
include/bcmsdstd.h:29:/* global msglevel for debug messages - bitvals come from sdiovar.h */
include/bcmsdstd.h:42:/* Allocate/init/free per-OS private data */
include/bcmsdstd.h:88:#define USE_FIFO		0x8	/* Fifo vs non-fifo */
include/bcmsdstd.h:122:	void		*sdos_info;		/* Pointer to per-OS private data */
include/bcmsdstd.h:178:	uint	txglom_mode;		/* Txglom mode: 0 - copy, 1 - multi-descriptor */
include/bcmsdstd.h:187:#define DMA_MODE_AUTO	-1
include/bcmsdstd.h:189:#define USE_DMA(sd)		((bool)((sd->sd_dma_mode > 0) ? TRUE : FALSE))
include/bcmsdstd.h:204: * Internal interfaces: per-port references into bcmsdstd.c
include/bcmsdstd.h:210:/* OS-independent interrupt handler */
include/bcmsdstd.h:226: * Internal interfaces: bcmsdstd.c references to per-port code
include/bcmsdstd.h:237:/* OS-specific interrupt wrappers (atomic interrupt enable/disable) */
include/bcmsdstd.h:242:/* OS-specific wait-for-interrupt-or-status */
include/bcmutils.h:2: * Misc useful os-independent macros and functions.
include/bcmutils.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmutils.h:24: * $Id: bcmutils.h 354837 2012-09-04 06:58:44Z $
include/bcmutils.h:66:#define bcm_tolower(c)	(bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
include/bcmutils.h:67:#define bcm_toupper(c)	(bcm_islower((c)) ? ((c) + 'A' - 'a') : (c))
include/bcmutils.h:69:/* Buffer structure for collecting string-formatted data
include/bcmutils.h:81:/* ** driver-only section ** */
include/bcmutils.h:96:		countdown -= 10; \
include/bcmutils.h:100:/* osl multi-precedence packet queue */
include/bcmutils.h:133:	uint32 retry;        /* packets re-sent because they were not received */
include/bcmutils.h:136:	uint32 max_avail;    /* the high-water mark of the queue capacity for packets -
include/bcmutils.h:139:	uint32 max_used;     /* the high-water mark of the queue utilisation for packets -
include/bcmutils.h:149:	uint16 hi_prec;         /* rapid dequeue hint (>= highest non-empty prec) */	\
include/bcmutils.h:153:/* multi-priority pkt queue */
include/bcmutils.h:163:/* simple, non-priority pkt queue */
include/bcmutils.h:170:#define PKTQ_PREC_ITER(pq, prec)        for (prec = (pq)->num_prec - 1; prec >= 0; prec--)
include/bcmutils.h:176:#define POOL_ENAB(pool)		((pool) && (pool)->inited)
include/bcmutils.h:268:#define pktpool_len(pp)			(POOLPTR(pp)->len - 1)
include/bcmutils.h:269:#define pktpool_plen(pp)		(POOLPTR(pp)->plen)
include/bcmutils.h:270:#define pktpool_maxlen(pp)		(POOLPTR(pp)->maxlen)
include/bcmutils.h:289:#define pktq_psetmax(pq, prec, _max)	((pq)->q[prec].max = (_max))
include/bcmutils.h:290:#define pktq_pmax(pq, prec)		((pq)->q[prec].max)
include/bcmutils.h:291:#define pktq_plen(pq, prec)		((pq)->q[prec].len)
include/bcmutils.h:292:#define pktq_pavail(pq, prec)		((pq)->q[prec].max - (pq)->q[prec].len)
include/bcmutils.h:293:#define pktq_pfull(pq, prec)		((pq)->q[prec].len >= (pq)->q[prec].max)
include/bcmutils.h:294:#define pktq_pempty(pq, prec)		((pq)->q[prec].len == 0)
include/bcmutils.h:296:#define pktq_ppeek(pq, prec)		((pq)->q[prec].head)
include/bcmutils.h:297:#define pktq_ppeek_tail(pq, prec)	((pq)->q[prec].tail)
include/bcmutils.h:318:#define pktq_len(pq)		((int)(pq)->len)
include/bcmutils.h:319:#define pktq_max(pq)		((int)(pq)->max)
include/bcmutils.h:320:#define pktq_avail(pq)		((int)((pq)->max - (pq)->len))
include/bcmutils.h:321:#define pktq_full(pq)		((pq)->len >= (pq)->max)
include/bcmutils.h:322:#define pktq_empty(pq)		((pq)->len == 0)
include/bcmutils.h:393:#define	bcmdumplogent(buf, idx)	-1
include/bcmutils.h:403:/* Support for sharing code across in-driver iovar implementations.
include/bcmutils.h:414:	uint16 flags;		/* driver-specific flag bits */
include/bcmutils.h:419:/* varid definitions are per-driver, may use these get/set bits */
include/bcmutils.h:431:/* flags are per-driver based on driver attributes */
include/bcmutils.h:444:#define IOVT_INT8	2	/* integer values are range-checked */
include/bcmutils.h:450:#define IOVT_BUFFER	8	/* buffer is size-checked as per minlen */
include/bcmutils.h:475:/* ** driver/apps-shared section ** */
include/bcmutils.h:490:#define BCME_ERROR			-1	/* Error generic */
include/bcmutils.h:491:#define BCME_BADARG			-2	/* Bad Argument */
include/bcmutils.h:492:#define BCME_BADOPTION			-3	/* Bad option */
include/bcmutils.h:493:#define BCME_NOTUP			-4	/* Not up */
include/bcmutils.h:494:#define BCME_NOTDOWN			-5	/* Not down */
include/bcmutils.h:495:#define BCME_NOTAP			-6	/* Not AP */
include/bcmutils.h:496:#define BCME_NOTSTA			-7	/* Not STA  */
include/bcmutils.h:497:#define BCME_BADKEYIDX			-8	/* BAD Key Index */
include/bcmutils.h:498:#define BCME_RADIOOFF 			-9	/* Radio Off */
include/bcmutils.h:499:#define BCME_NOTBANDLOCKED		-10	/* Not  band locked */
include/bcmutils.h:500:#define BCME_NOCLK			-11	/* No Clock */
include/bcmutils.h:501:#define BCME_BADRATESET			-12	/* BAD Rate valueset */
include/bcmutils.h:502:#define BCME_BADBAND			-13	/* BAD Band */
include/bcmutils.h:503:#define BCME_BUFTOOSHORT		-14	/* Buffer too short */
include/bcmutils.h:504:#define BCME_BUFTOOLONG			-15	/* Buffer too long */
include/bcmutils.h:505:#define BCME_BUSY			-16	/* Busy */
include/bcmutils.h:506:#define BCME_NOTASSOCIATED		-17	/* Not Associated */
include/bcmutils.h:507:#define BCME_BADSSIDLEN			-18	/* Bad SSID len */
include/bcmutils.h:508:#define BCME_OUTOFRANGECHAN		-19	/* Out of Range Channel */
include/bcmutils.h:509:#define BCME_BADCHAN			-20	/* Bad Channel */
include/bcmutils.h:510:#define BCME_BADADDR			-21	/* Bad Address */
include/bcmutils.h:511:#define BCME_NORESOURCE			-22	/* Not Enough Resources */
include/bcmutils.h:512:#define BCME_UNSUPPORTED		-23	/* Unsupported */
include/bcmutils.h:513:#define BCME_BADLEN			-24	/* Bad length */
include/bcmutils.h:514:#define BCME_NOTREADY			-25	/* Not Ready */
include/bcmutils.h:515:#define BCME_EPERM			-26	/* Not Permitted */
include/bcmutils.h:516:#define BCME_NOMEM			-27	/* No Memory */
include/bcmutils.h:517:#define BCME_ASSOCIATED			-28	/* Associated */
include/bcmutils.h:518:#define BCME_RANGE			-29	/* Not In Range */
include/bcmutils.h:519:#define BCME_NOTFOUND			-30	/* Not Found */
include/bcmutils.h:520:#define BCME_WME_NOT_ENABLED		-31	/* WME Not Enabled */
include/bcmutils.h:521:#define BCME_TSPEC_NOTFOUND		-32	/* TSPEC Not Found */
include/bcmutils.h:522:#define BCME_ACM_NOTSUPPORTED		-33	/* ACM Not Supported */
include/bcmutils.h:523:#define BCME_NOT_WME_ASSOCIATION	-34	/* Not WME Association */
include/bcmutils.h:524:#define BCME_SDIO_ERROR			-35	/* SDIO Bus Error */
include/bcmutils.h:525:#define BCME_DONGLE_DOWN		-36	/* Dongle Not Accessible */
include/bcmutils.h:526:#define BCME_VERSION			-37 	/* Incorrect version */
include/bcmutils.h:527:#define BCME_TXFAIL			-38 	/* TX failure */
include/bcmutils.h:528:#define BCME_RXFAIL			-39	/* RX failure */
include/bcmutils.h:529:#define BCME_NODEVICE			-40 	/* Device not present */
include/bcmutils.h:530:#define BCME_NMODE_DISABLED		-41 	/* NMODE disabled */
include/bcmutils.h:531:#define BCME_NONRESIDENT		-42 /* access to nonresident overlay */
include/bcmutils.h:582:#define	ABS(a)			(((a) < 0) ? -(a) : (a))
include/bcmutils.h:593:#define CEIL(x, y)		(((x) + ((y) - 1)) / (y))
include/bcmutils.h:594:#define	ROUNDUP(x, y)		((((x) + ((y) - 1)) / (y)) * (y))
include/bcmutils.h:595:#define	ISALIGNED(a, x)		(((uintptr)(a) & ((x) - 1)) == 0)
include/bcmutils.h:596:#define ALIGN_ADDR(addr, boundary) (void *)(((uintptr)(addr) + (boundary) - 1) \
include/bcmutils.h:597:	                                         & ~((boundary) - 1))
include/bcmutils.h:598:#define ALIGN_SIZE(size, boundary) (((size) + (boundary) - 1) \
include/bcmutils.h:599:	                                         & ~((boundary) - 1))
include/bcmutils.h:600:#define	ISPOWEROF2(x)		((((x) - 1) & (x)) == 0)
include/bcmutils.h:613:#define	OFFSETOF(type, member)	((uint)(uintptr)&((type *)0)->member)
include/bcmutils.h:638:#define MAXBITVAL(nbits)	((1 << (nbits)) - 1)
include/bcmutils.h:642:/* basic mux operation - can be optimized on several architectures */
include/bcmutils.h:645:/* modulo inc/dec - assumes x E [0, bound - 1] */
include/bcmutils.h:646:#define MODDEC(x, bound) MUX((x) == 0, (bound) - 1, (x) - 1)
include/bcmutils.h:647:#define MODINC(x, bound) MUX((x) == (bound) - 1, 0, (x) + 1)
include/bcmutils.h:650:#define MODDEC_POW2(x, bound) (((x) - 1) & ((bound) - 1))
include/bcmutils.h:651:#define MODINC_POW2(x, bound) (((x) + 1) & ((bound) - 1))
include/bcmutils.h:653:/* modulo add/sub - assumes x, y E [0, bound - 1] */
include/bcmutils.h:655:    MUX((x) + (y) >= (bound), (x) + (y) - (bound), (x) + (y))
include/bcmutils.h:657:    MUX(((int)(x)) - ((int)(y)) < 0, (x) - (y) + (bound), (x) - (y))
include/bcmutils.h:660:#define MODADD_POW2(x, y, bound) (((x) + (y)) & ((bound) - 1))
include/bcmutils.h:661:#define MODSUB_POW2(x, y, bound) (((x) - (y)) & ((bound) - 1))
include/bcmutils.h:673:#define ETHERP_TO_MACF(ea)	((struct ether_addr *) (ea))->octet[0], \
include/bcmutils.h:674:							((struct ether_addr *) (ea))->octet[1], \
include/bcmutils.h:675:							((struct ether_addr *) (ea))->octet[2], \
include/bcmutils.h:676:							((struct ether_addr *) (ea))->octet[3], \
include/bcmutils.h:677:							((struct ether_addr *) (ea))->octet[4], \
include/bcmutils.h:678:							((struct ether_addr *) (ea))->octet[5]
include/bcmutils.h:708:#define bcm_valid_tlv(elt, buflen) ((buflen) >= 2 && (int)(buflen) >= (int)(2 + (elt)->len))
include/bcmutils.h:711:#define ETHER_ADDR_STR_LEN	18	/* 18-bytes of Ethernet address buffer length */
include/bcmutils.h:714:/* 128-bit xor: *dst = *src1 xor *src2. dst1, src1 and src2 may have any alignment */
include/bcmutils.h:724:		/* x86 supports unaligned.  This version runs 6x-9x faster on x86. */
include/bcmutils.h:769:/* multi-bool data type: set of bools, mbool is true if any is set */
include/Makefile:13:# $Id: Makefile 241686 2011-02-19 00:22:45Z prakashd $
include/Makefile:32:	@if [ -s "compvers.sh" ]; then \
include/Makefile:41:	@if [ -s "compvers.sh" ]; then \
include/Makefile:49:	rm -f $(TARGETS) *.prev
include/bcmendian.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmendian.h:24: *  $Id: bcmendian.h 241182 2011-02-17 21:50:03Z $
include/bcmendian.h:26: * This file by default provides proper behavior on little-endian architectures.
include/bcmendian.h:27: * On big-endian architectures, IL_BIGENDIAN should be defined.
include/bcmendian.h:35:/* Reverse the bytes in a 16-bit value */
include/bcmendian.h:40:/* Reverse the bytes in a 32-bit value */
include/bcmendian.h:47:/* Reverse the two 16-bit halves of a 32-bit value */
include/bcmendian.h:53: *    Host <=> Network (Big Endian) for 16- and 32-bit values
include/bcmendian.h:54: *    Host <=> Little-Endian for 16- and 32-bit values
include/bcmendian.h:104: * avoiding the -fno-inline used in ROM builds.
include/bcmendian.h:125:	while (_wds--) { \
include/bcmendian.h:204:/* Reverse pairs of bytes in a buffer (not for high-performance use) */
include/bcmendian.h:205:/* buf	- start of buffer of shorts to swap */
include/bcmendian.h:206:/* len  - byte length of buffer */
include/bcmendian.h:212:	while (len--) {
include/bcmendian.h:219: * Store 16-bit value to unaligned little-endian byte array.
include/bcmendian.h:229: * Store 32-bit value to unaligned little-endian byte array.
include/bcmendian.h:241: * Store 16-bit value to unaligned network-(big-)endian byte array.
include/bcmendian.h:251: * Store 32-bit value to unaligned network-(big-)endian byte array.
include/bcmendian.h:263: * Load 16-bit value from unaligned little-endian byte array.
include/bcmendian.h:272: * Load 32-bit value from unaligned little-endian byte array.
include/bcmendian.h:281: * Load 16-bit value from unaligned big-(network-)endian byte array.
include/bcmendian.h:290: * Load 32-bit value from unaligned big-(network-)endian byte array.
include/linux_osl.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/linux_osl.h:24: * $Id: linux_osl.h 354452 2012-08-31 04:59:17Z $
include/linux_osl.h:96:	bool mmbus;		/* Bus supports memory-mapped register accesses */
include/linux_osl.h:104:	   ((osl_pubinfo_t*)osh)->tx_fn = _tx_fn;	\
include/linux_osl.h:105:	   ((osl_pubinfo_t*)osh)->tx_ctx = _tx_ctx;	\
include/linux_osl.h:109:/* host/bus architecture-specific byte swap */
include/linux_osl.h:125:/* allocate/free shared (dma-able) consistent memory */
include/linux_osl.h:139:/* map/unmap shared (dma-able) memory */
include/linux_osl.h:153:	#define SELECT_BUS_WRITE(osh, mmap_op, bus_op) if (((osl_pubinfo_t*)(osh))->mmbus) \
include/linux_osl.h:155:	#define SELECT_BUS_READ(osh, mmap_op, bus_op) (((osl_pubinfo_t*)(osh))->mmbus) ? \
include/linux_osl.h:165: * BINOSL selects the slightly slower function-call-based binary compatible osl.
include/linux_osl.h:248:/* shared (dma-able) memory access macros */
include/linux_osl.h:268:#define	PKTDATA(osh, skb)		(((struct sk_buff*)(skb))->data)
include/linux_osl.h:269:#define	PKTLEN(osh, skb)		(((struct sk_buff*)(skb))->len)
include/linux_osl.h:270:#define PKTHEADROOM(osh, skb)		(PKTDATA(osh, skb)-(((struct sk_buff*)(skb))->head))
include/linux_osl.h:271:#define PKTTAILROOM(osh, skb) ((((struct sk_buff*)(skb))->end)-(((struct sk_buff*)(skb))->tail))
include/linux_osl.h:272:#define	PKTNEXT(osh, skb)		(((struct sk_buff*)(skb))->next)
include/linux_osl.h:273:#define	PKTSETNEXT(osh, skb, x)		(((struct sk_buff*)(skb))->next = (struct sk_buff*)(x))
include/linux_osl.h:277:#define	PKTTAG(skb)			((void*)(((struct sk_buff*)(skb))->cb))
include/linux_osl.h:278:#define PKTALLOCED(osh)			((osl_pubinfo_t *)(osh))->pktalloced
include/linux_osl.h:299:#define	PKTSETFAST(osh, skb)	((((struct sk_buff*)(skb))->mac_len) |= FASTBUF)
include/linux_osl.h:300:#define	PKTCLRFAST(osh, skb)	((((struct sk_buff*)(skb))->mac_len) &= (~FASTBUF))
include/linux_osl.h:301:#define	PKTSETCTF(osh, skb)	((((struct sk_buff*)(skb))->mac_len) |= CTFBUF)
include/linux_osl.h:302:#define	PKTCLRCTF(osh, skb)	((((struct sk_buff*)(skb))->mac_len) &= (~CTFBUF))
include/linux_osl.h:303:#define	PKTISFAST(osh, skb)	((((struct sk_buff*)(skb))->mac_len) & FASTBUF)
include/linux_osl.h:304:#define	PKTISCTF(osh, skb)	((((struct sk_buff*)(skb))->mac_len) & CTFBUF)
include/linux_osl.h:305:#define	PKTFAST(osh, skb)	(((struct sk_buff*)(skb))->mac_len)
include/linux_osl.h:309:#define	PKTSETFAST(osh, skb)	((((struct sk_buff*)(skb))->__unused) |= FASTBUF)
include/linux_osl.h:310:#define	PKTCLRFAST(osh, skb)	((((struct sk_buff*)(skb))->__unused) &= (~FASTBUF))
include/linux_osl.h:311:#define	PKTSETCTF(osh, skb)	((((struct sk_buff*)(skb))->__unused) |= CTFBUF)
include/linux_osl.h:312:#define	PKTCLRCTF(osh, skb)	((((struct sk_buff*)(skb))->__unused) &= (~CTFBUF))
include/linux_osl.h:313:#define	PKTISFAST(osh, skb)	((((struct sk_buff*)(skb))->__unused) & FASTBUF)
include/linux_osl.h:314:#define	PKTISCTF(osh, skb)	((((struct sk_buff*)(skb))->__unused) & CTFBUF)
include/linux_osl.h:315:#define	PKTFAST(osh, skb)	(((struct sk_buff*)(skb))->__unused)
include/linux_osl.h:318:#define	CTFPOOLPTR(osh, skb)	(((struct sk_buff*)(skb))->sk)
include/linux_osl.h:319:#define	CTFPOOLHEAD(osh, skb)	(((ctfpool_t *)((struct sk_buff*)(skb))->sk)->head)
include/linux_osl.h:332:#define	PKTSETSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->mac_len |= SKIPCT)
include/linux_osl.h:333:#define	PKTCLRSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->mac_len &= (~SKIPCT))
include/linux_osl.h:334:#define	PKTSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->mac_len & SKIPCT)
include/linux_osl.h:337:#define	PKTSETSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->__unused |= SKIPCT)
include/linux_osl.h:338:#define	PKTCLRSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->__unused &= (~SKIPCT))
include/linux_osl.h:339:#define	PKTSKIPCT(osh, skb)	(((struct sk_buff*)(skb))->__unused & SKIPCT)
include/linux_osl.h:358:#define	PKTLINK(skb)			(((struct sk_buff*)(skb))->prev)
include/linux_osl.h:359:#define	PKTSETLINK(skb, x)		(((struct sk_buff*)(skb))->prev = (struct sk_buff*)(x))
include/linux_osl.h:360:#define	PKTPRIO(skb)			(((struct sk_buff*)(skb))->priority)
include/linux_osl.h:361:#define	PKTSETPRIO(skb, x)		(((struct sk_buff*)(skb))->priority = (x))
include/linux_osl.h:362:#define PKTSUMNEEDED(skb)		(((struct sk_buff*)(skb))->ip_summed == CHECKSUM_HW)
include/linux_osl.h:363:#define PKTSETSUMGOOD(skb, x)		(((struct sk_buff*)(skb))->ip_summed = \
include/linux_osl.h:365:/* PKTSETSUMNEEDED and PKTSUMGOOD are not possible because skb->ip_summed is overloaded */
include/linux_osl.h:366:#define PKTSHARED(skb)                  (((struct sk_buff*)(skb))->cloned)
include/linux_osl.h:379:#define CHAIN_NODE(skb)		((struct chain_node*)&(((struct sk_buff*)skb)->tstamp))
include/linux_osl.h:381:#define CHAIN_NODE(skb)		((struct chain_node*)&(((struct sk_buff*)skb)->stamp))
include/linux_osl.h:384:#define	PKTCCNT(skb)		(CHAIN_NODE(skb)->pkts)
include/linux_osl.h:385:#define	PKTCLEN(skb)		(CHAIN_NODE(skb)->bytes)
include/linux_osl.h:386:#define	PKTCFLAGS(skb)		(CHAIN_NODE(skb)->flags)
include/linux_osl.h:387:#define	PKTCSETCNT(skb, c)	(CHAIN_NODE(skb)->pkts = (c) & ((1 << 9) - 1))
include/linux_osl.h:388:#define	PKTCSETLEN(skb, l)	(CHAIN_NODE(skb)->bytes = (l) & ((1 << 20) - 1))
include/linux_osl.h:389:#define	PKTCSETFLAG(skb, fb)	(CHAIN_NODE(skb)->flags |= (fb))
include/linux_osl.h:390:#define	PKTCCLRFLAG(skb, fb)	(CHAIN_NODE(skb)->flags &= ~(fb))
include/linux_osl.h:391:#define	PKTCLINK(skb)		(CHAIN_NODE(skb)->link)
include/linux_osl.h:392:#define	PKTSETCLINK(skb, x)	(CHAIN_NODE(skb)->link = (struct sk_buff*)(x))
include/bcmsdh.h:6: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmsdh.h:26: * $Id: bcmsdh.h 347614 2012-07-27 10:24:51Z $
include/bcmsdh.h:52: *  - Allocates resources (structs, arrays, mem, OS handles, etc) needed by bcmsdh.
include/bcmsdh.h:53: *  - Returns the bcmsdh handle and virtual address base for register access.
include/bcmsdh.h:56: *    most recent one) to enable single-instance implementations to pass NULL.
include/bcmsdh.h:66:/* Detach - freeup resources allocated in attach */
include/bcmsdh.h:88: * device removal. No-op in the case of non-removable/hardwired devices.
include/bcmsdh.h:92:/* Access SDIO address space (e.g. CCCR) using CMD52 (single-byte interface).
include/bcmsdh.h:94: *   addr: unmodified SDIO-space address
include/bcmsdh.h:109: * Internally, this routine uses the values from the cis base regs (0x9-0xB)
include/bcmsdh.h:110: * to form an SDIO-space address to read the data from.
include/bcmsdh.h:153:#define SDIO_REQ_4BYTE	0x1	/* Four-byte target (backplane) width (vs. two-byte) */
include/bcmsdh.h:156:#define SDIO_BYTE_MODE	0x8	/* Byte mode request(non-block mode) */
include/bcmsdh.h:158:/* Pending (non-error) return code */
include/bcmsdh.h:226:/* Function to pass device-status bits to DHD. */
include/sdiovar.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
include/sdiovar.h:25: * $Id: sdiovar.h 241182 2011-02-17 21:50:03Z $
include/sdioh.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
include/sdioh.h:25: * $Id: sdioh.h 347633 2012-07-27 11:02:02Z $
include/sdioh.h:83:/* preset-indiv regs */
include/sdioh.h:112:/* Note: for sdio-2.0 case, this mask has to be 6 bits, but msb 2
include/sdioh.h:153:#define CAP3_SDR50_SUP_S		(32 - CAP3_MSBits_OFFSET)
include/sdioh.h:156:#define CAP3_SDR104_SUP_S	(33 - CAP3_MSBits_OFFSET)
include/sdioh.h:159:#define CAP3_DDR50_SUP_S	(34 - CAP3_MSBits_OFFSET)
include/sdioh.h:163:#define CAP3_30CLKCAP_S		(32 - CAP3_MSBits_OFFSET)
include/sdioh.h:166:#define CAP3_DRIVTYPE_A_S	(36 - CAP3_MSBits_OFFSET)
include/sdioh.h:169:#define CAP3_DRIVTYPE_C_S	(37 - CAP3_MSBits_OFFSET)
include/sdioh.h:172:#define CAP3_DRIVTYPE_D_S	(38 - CAP3_MSBits_OFFSET)
include/sdioh.h:175:#define CAP3_RETUNING_TC_S	(40 - CAP3_MSBits_OFFSET)
include/sdioh.h:178:#define CAP3_TUNING_SDR50_S	(45 - CAP3_MSBits_OFFSET)
include/sdioh.h:181:#define CAP3_RETUNING_MODES_S	(46 - CAP3_MSBits_OFFSET)
include/sdioh.h:184:#define CAP3_CLK_MULT_S		(48 - CAP3_MSBits_OFFSET)
include/sdioh.h:235:#define CMD_RESP_TYPE_M		BITFIELD_MASK(2)	/* Bits [0-1] 	- Response type */
include/sdioh.h:237:#define CMD_CRC_EN_M		BITFIELD_MASK(1)	/* Bit 3 	- CRC enable */
include/sdioh.h:239:#define CMD_INDEX_EN_M		BITFIELD_MASK(1)	/* Bit 4 	- Enable index checking */
include/sdioh.h:241:#define CMD_DATA_EN_M		BITFIELD_MASK(1)	/* Bit 5 	- Using DAT line */
include/sdioh.h:243:#define CMD_TYPE_M		BITFIELD_MASK(2)	/* Bit [6-7] 	- Normal, abort, resume, etc
include/sdioh.h:246:#define CMD_INDEX_M		BITFIELD_MASK(6)	/* Bits [8-13] 	- Command number */
include/sdioh.h:258:#define PRES_PRESENT_RSVD_M	BITFIELD_MASK(5)	/* Bit [3-7]	rsvd */
include/sdioh.h:268:#define PRES_CARD_PRESENT_M	BITFIELD_MASK(1)	/* Bit 16	Card present - debounced */
include/sdioh.h:276:#define PRES_DAT_SIGNAL_M	BITFIELD_MASK(4)	/* Bit [20-23]	Debugging */
include/sdioh.h:323:#define PWR_VOLTS_M		BITFIELD_MASK(3)	/* Bit [1-3]	Voltage Select */
include/sdioh.h:430:#define ADMA1_ATTRIBUTE_ACT_SET		(1 << 4)	/* ADMA1 Only - set transfer length */
include/sdioh.h:434:/* ADMA2 Descriptor Table Entry for 32-bit Address */
include/hndrte_cons.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/hndrte_cons.h:24: * $Id: hndrte_cons.h 300516 2011-12-04 17:39:44Z $
include/hndrte_cons.h:36:	uint32		buf;		/* Can't be pointer on (64-bit) hosts */
include/trxhdr.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/trxhdr.h:24: * $Id: trxhdr.h 260898 2011-05-20 23:11:12Z $
include/trxhdr.h:45:	uint32 crc32;		/* 32-bit CRC from flag_version to end of file */
include/wlioctl.h:7: * Copyright (C) 1999-2012, Broadcom Corporation
include/wlioctl.h:27: * $Id: wlioctl.h 366141 2012-11-01 01:55:06Z $
include/wlioctl.h:47: *  a no-op for most cases. For hybrid and other open source releases,
include/wlioctl.h:137: * Per-BSS information structure.
include/wlioctl.h:351:#define WL_EXTDSCAN_PARAMS_FIXED_SIZE 	(sizeof(wl_extdscan_params_t) - sizeof(chan_scandata_t))
include/wlioctl.h:371:	int32 nprobes;			/* -1 use default, number of probes per channel */
include/wlioctl.h:372:	int32 active_time;		/* -1 use default, dwell time per channel for
include/wlioctl.h:375:	int32 passive_time;		/* -1 use default, dwell time per channel
include/wlioctl.h:378:	int32 home_time;		/* -1 use default, dwell time for the home channel
include/wlioctl.h:388:					 * meaning an odd channel count implies a 2-byte pad
include/wlioctl.h:432:#define WL_SCAN_RESULTS_FIXED_SIZE (sizeof(wl_scan_results_t) - sizeof(wl_bss_info_t))
include/wlioctl.h:464:#define WL_ESCAN_RESULTS_FIXED_SIZE (sizeof(wl_escan_result_t) - sizeof(wl_bss_info_t))
include/wlioctl.h:497:	/* in - # of elements, out - # of entries */
include/wlioctl.h:539:	int32 nprobes;			/* -1 use default, number of probes per channel */
include/wlioctl.h:540:	int32 active_time;		/* -1 use default, dwell time per channel for
include/wlioctl.h:543:	int32 passive_time;		/* -1 use default, dwell time per channel
include/wlioctl.h:546:	int32 home_time;		/* -1 use default, dwell time for the home channel
include/wlioctl.h:570:#define NRATE_MCS_INUSE	0x00000080	/* MSC in use,indicates b0-6 holds an mcs */
include/wlioctl.h:617:#define OLD_NRATE_MCS_INUSE         0x00000080 /* MSC in use,indicates b0-6 holds an mcs */
include/wlioctl.h:658:#define IBSS_MED        15	/* Mediom in-bss congestion percentage */
include/wlioctl.h:659:#define IBSS_HI         25	/* Hi in-bss congestion percentage */
include/wlioctl.h:730:	char country_abbrev[WLC_CNTRY_BUF_SZ];	/* nul-terminated country code used in
include/wlioctl.h:734:						 * on set, -1 indicates unspecified.
include/wlioctl.h:737:	char ccode[WLC_CNTRY_BUF_SZ];		/* nul-terminated built-in country code.
include/wlioctl.h:776:	uint32	tsf_h;		/* TSF high 32-bits of Measurement start time */
include/wlioctl.h:777:	uint32	tsf_l;		/* TSF low 32-bits */
include/wlioctl.h:795:	uint32	tsf_h;		/* TSF high 32-bits of Measurement start time */
include/wlioctl.h:796:	uint32	tsf_l;		/* TSF low 32-bits */
include/wlioctl.h:858:#define CRYPTO_ALGO_PMK			12	/* for 802.1x supp to set PMK before 4-way */
include/wlioctl.h:933:#define WPA_AUTH_DISABLED	0x0000	/* Legacy (i.e., non-WPA) */
include/wlioctl.h:936:#define WPA_AUTH_PSK		0x0004	/* Pre-shared key */
include/wlioctl.h:943:#define WPA2_AUTH_PSK		0x0080	/* Pre-shared key */
include/wlioctl.h:1009:#define WLC_CIS_DEFAULT	0	/* built-in default */
include/wlioctl.h:1021:/* Structure used by GET/SET_ATTEN ioctls - it controls power in b/g-band */
include/wlioctl.h:1022:/* PCL - Power Control Loop */
include/wlioctl.h:1036:/* Per-AC retry parameters */
include/wlioctl.h:1049:/* defines used by poweridx iovar - it controls power in a-band */
include/wlioctl.h:1051:#define WL_PWRIDX_PCL_OFF	-2	/* turn off PCL.  */
include/wlioctl.h:1052:#define WL_PWRIDX_PCL_ON	-1	/* turn on PCL */
include/wlioctl.h:1053:#define WL_PWRIDX_LOWER_LIMIT	-2	/* lower limit */
include/wlioctl.h:1056: *	- input to be set to that value
include/wlioctl.h:1057: *	- PCL to be off
include/wlioctl.h:1241:	uint		boardid;	/* board identifier (usu. PCI sub-device id) */
include/wlioctl.h:1242:	uint		boardvendor;	/* board vendor (usu. PCI sub-vendor id) */
include/wlioctl.h:1394:/* #define WLC_GET_D11CNTS			89 */ /* -> "counters" iovar */
include/wlioctl.h:1409:/* #define WLC_RESET_D11CNTS			104 */ /* -> "reset_d11cnts" iovar */
include/wlioctl.h:1627:/* #define WLC_LAST				310 */	/* Never used - can be reused */
include/wlioctl.h:1647: * 0xFF - implementation specific OID
include/wlioctl.h:1648: * 0xE4 - first byte of Broadcom PCI vendor ID
include/wlioctl.h:1649: * 0x14 - second byte of Broadcom PCI vendor ID
include/wlioctl.h:1650: * 0xXX - the custom OID number
include/wlioctl.h:1690:/* allows user-mode app to poll the status of USB image upgrade */
include/wlioctl.h:1714:/* Bit masks for radio disabled status - returned by WL_GET_RADIO */
include/wlioctl.h:1772:#define	WLC_BAND_AUTO		0	/* auto-select */
include/wlioctl.h:1851:#define WLC_PLCP_AUTO	-1
include/wlioctl.h:1856:#define WLC_PROTECTION_AUTO		-1
include/wlioctl.h:1911:#define	INTERFERE_OVRRIDE_OFF	-1	/* interference override off */
include/wlioctl.h:1916:#define	WLAN_AUTO_W_NOISE	4	/* ACI: auto - detect and non 802.11 interference */
include/wlioctl.h:2025:	int npulses_stg2;  /* Radar detection, minimum staggered-2 pulses set */
include/wlioctl.h:2026:	int npulses_stg3;  /* Radar detection, minimum staggered-3 pulses set */
include/wlioctl.h:2033:	uint16 feature_mask; /* 16-bit mask to specify enabled features */
include/wlioctl.h:2040:	uint16 thresh0_20_lo;	/* Radar detection, thresh 0 (range 5250-5350MHz) for BW 20MHz */
include/wlioctl.h:2041:	uint16 thresh1_20_lo;	/* Radar detection, thresh 1 (range 5250-5350MHz) for BW 20MHz */
include/wlioctl.h:2042:	uint16 thresh0_40_lo;	/* Radar detection, thresh 0 (range 5250-5350MHz) for BW 40MHz */
include/wlioctl.h:2043:	uint16 thresh1_40_lo;	/* Radar detection, thresh 1 (range 5250-5350MHz) for BW 40MHz */
include/wlioctl.h:2044:	uint16 thresh0_80_lo;	/* Radar detection, thresh 0 (range 5250-5350MHz) for BW 80MHz */
include/wlioctl.h:2045:	uint16 thresh1_80_lo;	/* Radar detection, thresh 1 (range 5250-5350MHz) for BW 80MHz */
include/wlioctl.h:2046:	uint16 thresh0_160_lo;	/* Radar detection, thresh 0 (range 5250-5350MHz) for BW 160MHz */
include/wlioctl.h:2047:	uint16 thresh1_160_lo;	/* Radar detection, thresh 1 (range 5250-5350MHz) for BW 160MHz */
include/wlioctl.h:2048:	uint16 thresh0_20_hi;	/* Radar detection, thresh 0 (range 5470-5725MHz) for BW 20MHz */
include/wlioctl.h:2049:	uint16 thresh1_20_hi;	/* Radar detection, thresh 1 (range 5470-5725MHz) for BW 20MHz */
include/wlioctl.h:2050:	uint16 thresh0_40_hi;	/* Radar detection, thresh 0 (range 5470-5725MHz) for BW 40MHz */
include/wlioctl.h:2051:	uint16 thresh1_40_hi;	/* Radar detection, thresh 1 (range 5470-5725MHz) for BW 40MHz */
include/wlioctl.h:2052:	uint16 thresh0_80_hi;	/* Radar detection, thresh 0 (range 5470-5725MHz) for BW 80MHz */
include/wlioctl.h:2053:	uint16 thresh1_80_hi;	/* Radar detection, thresh 1 (range 5470-5725MHz) for BW 80MHz */
include/wlioctl.h:2054:	uint16 thresh0_160_hi;	/* Radar detection, thresh 0 (range 5470-5725MHz) for BW 160MHz */
include/wlioctl.h:2055:	uint16 thresh1_160_hi;	/* Radar detection, thresh 1 (range 5470-5725MHz) for BW 160MHz */
include/wlioctl.h:2059:#define WL_THRESHOLD_LO_BAND	70	/* range from 5250MHz - 5350MHz */
include/wlioctl.h:2086:/* dfs_status iovar-related defines */
include/wlioctl.h:2088:/* cac - channel availability check,
include/wlioctl.h:2089: * ism - in-service monitoring
include/wlioctl.h:2090: * csa - channel switching announcement
include/wlioctl.h:2094:#define WL_DFS_CACSTATE_IDLE		0	/* state for operating in non-radar channel */
include/wlioctl.h:2129:	int8  txpwr_antgain[2];				/* Ant gain for each band - from SROM */
include/wlioctl.h:2145:	int8  antgain[2];                /* Ant gain for each band - from SROM */
include/wlioctl.h:2160:#define WL_NUM_RATES_MCS_1STREAM	8 /* MCS 0-7 1-stream rates - SISO/CDD/STBC/MCS */
include/wlioctl.h:2183:	uint8 b20_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];		/* SISO MCS 0-7 */
include/wlioctl.h:2187:	uint8 b20_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
include/wlioctl.h:2188:	uint8 b20_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2189:	uint8 b20_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
include/wlioctl.h:2194:	uint8 b20_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2210:	uint8 b40_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];		/* SISO MCS 0-7 */
include/wlioctl.h:2214:	uint8 b40_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
include/wlioctl.h:2215:	uint8 b40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2216:	uint8 b40_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
include/wlioctl.h:2221:	uint8 b40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2237:	uint8 b20in40_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
include/wlioctl.h:2241:	uint8 b20in40_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
include/wlioctl.h:2242:	uint8 b20in40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2243:	uint8 b20in40_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
include/wlioctl.h:2248:	uint8 b20in40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2264:	uint8 b80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
include/wlioctl.h:2268:	uint8 b80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
include/wlioctl.h:2269:	uint8 b80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2270:	uint8 b80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
include/wlioctl.h:2275:	uint8 b80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2291:	uint8 b20in80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
include/wlioctl.h:2295:	uint8 b20in80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
include/wlioctl.h:2296:	uint8 b20in80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2297:	uint8 b20in80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
include/wlioctl.h:2302:	uint8 b20in80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2318:	uint8 b40in80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
include/wlioctl.h:2322:	uint8 b40in80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
include/wlioctl.h:2323:	uint8 b40in80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2324:	uint8 b40in80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
include/wlioctl.h:2329:	uint8 b40in80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
include/wlioctl.h:2342:	uint8 mcs32; /* C_CHECK - THIS NEEDS TO BE REMOVED THROUGHOUT THE CODE */
include/wlioctl.h:2569:	int8  antgain[2];			/* Ant gain for each band - from SROM */
include/wlioctl.h:2581:	int8 clm_limits[WL_NUMRATES];		/* regulatory limits - 20, 40 or 80MHz */
include/wlioctl.h:2582:	int8 clm_limits_subchan1[WL_NUMRATES];	/* regulatory limits - 20in40 or 40in80 */
include/wlioctl.h:2583:	int8 clm_limits_subchan2[WL_NUMRATES];	/* regulatory limits - 20in80MHz */
include/wlioctl.h:2586:	uint8 version;				/* Version of the data format wlu <--> driver */
include/wlioctl.h:2606:	int8  antgain[2];			/* Ant gain for each band - from SROM */
include/wlioctl.h:2634:#define SPECT_MNGMT_LOOSE_11H		1		/* allow non-11h APs in scan lists */
include/wlioctl.h:2635:#define SPECT_MNGMT_STRICT_11H		2		/* prune out non-11h APs from scan list */
include/wlioctl.h:2637:/* SPECT_MNGMT_LOOSE_11H_D - same as SPECT_MNGMT_LOOSE with the exception that Country IE
include/wlioctl.h:2644:#define WL_CHAN_BAND_5G		(1 << 2)	/* 5GHz-band channel */
include/wlioctl.h:2665:#define WL_BTC_2WIRE		2	/* use 2-wire BTC */
include/wlioctl.h:2666:#define WL_BTC_3WIRE		3	/* use 3-wire BTC */
include/wlioctl.h:2667:#define WL_BTC_4WIRE		4	/* use 4-wire BTC */
include/wlioctl.h:2736:/* use top-bit for WL_TIME_STAMP_VAL because this is a modifier
include/wlioctl.h:2737: * rather than a message-type of its own
include/wlioctl.h:2742:#define	WL_LED_NUMGPIO		32	/* gpio 0-31 */
include/wlioctl.h:2744:/* led per-pin behaviors */
include/wlioctl.h:2785:/* number of bytes needed to define a 128-bit mask for MAC event reporting */
include/wlioctl.h:2789: * Join preference iovar value is an array of tuples. Each tuple has a one-byte type,
include/wlioctl.h:2790: * a one-byte length, and a variable length value.  RSSI type tuple must be present
include/wlioctl.h:2800: * 1. RSSI - 2 octets
include/wlioctl.h:2804: * 2. WPA - 2 + 12 * n octets (n is # tuples defined below)
include/wlioctl.h:2810: * offset 2 + 12 * (n - 1) octets: tuple n
include/wlioctl.h:2820: * 3. BAND - 2 octets
include/wlioctl.h:2824: * 4. BAND RSSI - 2 octets
include/wlioctl.h:2909:	/* MAC counters: 32-bit version of d11.h's macstat_t */
include/wlioctl.h:2918:	uint32	txfunfl[8];	/* per-fifo tx underflows */
include/wlioctl.h:2922:	uint32	txphyerror;	/* Transmit phy error, type of error is reported in tx-status for
include/wlioctl.h:3027:	/* per-rate receive stat counters */
include/wlioctl.h:3151:	/* MAC counters: 32-bit version of d11.h's macstat_t */
include/wlioctl.h:3160:	uint32  txfunfl[8]; /* per-fifo tx underflows */
include/wlioctl.h:3164:	uint32  txphyerror; /* Transmit phy error, type of error is reported in tx-status for
include/wlioctl.h:3286:	/* per-rate receive stat counters */
include/wlioctl.h:3338:	/* per-rate receive stat counters */
include/wlioctl.h:3396:	uint8	keep_alive_id; /* 0 - 3 for N = 4 */
include/wlioctl.h:3445:/* structure for per-tid ampdu control */
include/wlioctl.h:3465:#define	DPT_DISCOVERY_SCAN	0x04	/* scan-based discovery mode */
include/wlioctl.h:3618:#define WL_SWFL_ABENCORE    0x0002 /* Allow AB on non-4318E chips */
include/wlioctl.h:3622:#define WL_SWFL_WLBSSSORT	0x0010 /* Per-port supports sorting of BSS */
include/wlioctl.h:3642: * (-100 < value < 0)   value is used directly as a roaming trigger in dBm
include/wlioctl.h:3652:#define WLC_ROAM_TRIGGER_AUTO		3 /* auto-detect environment */
include/wlioctl.h:3655:#define WLC_ROAM_NEVER_ROAM_TRIGGER	(-100) /* Avoid Roaming by setting a large value */
include/wlioctl.h:3873: * Keep-alive packet offloading.
include/wlioctl.h:3876:/* NAT keep-alive packets format: specifies the re-transmission period, the packet
include/wlioctl.h:3880:	uint32	period_msec;	/* Retransmission period (0 to disable packet re-transmits) */
include/wlioctl.h:3881:	uint16	len_bytes;	/* Size of packet to transmit (0 to disable packet re-transmits) */
include/wlioctl.h:3983:	uint32 delay;			/* Inter-packet delay */
include/wlioctl.h:4005:#define WL_WOWL_DIS         (1 << 2)    /* Wakeup on loss-of-link due to Disassoc/Deauth */
include/wlioctl.h:4010:#define WL_WOWL_EAPID       (1 << 7)    /* Wakeup after receipt of EAP-Identity Req */
include/wlioctl.h:4044:	uint16	ucode_wakeind;	/* What wakeup-event indication was set by ucode */
include/wlioctl.h:4152:	uint32 retry;          /* packets re-sent because they were not received */
include/wlioctl.h:4155:	uint32 max_avail;      /* the high-water mark of the queue capacity for packets -
include/wlioctl.h:4158:	uint32 max_used;       /* the high-water mark of the queue utilisation for packets -
include/wlioctl.h:4252: * affect backward compatibility with pre-existing apps
include/wlioctl.h:4433:#define IOBUF_ALLOWED_NUM_OF_LOGREC(type, len) ((len - LOGRRC_FIX_LEN)/sizeof(type))
include/wlioctl.h:4487:	uint8 ccastats[CCASTATS_MAX]; 	/* normalized as 0-255 */
include/wlioctl.h:4610:	int8 curr_temperature; /* on-chip temperature sensor reading */
include/wlioctl.h:4693:/* schedule option - WL_P2P_SCHED_TYPE_REQ_ABS */
include/wlioctl.h:4695:/* schedule option - WL_P2P_SCHED_TYPE_XXX */
include/wlioctl.h:4698:/* schedule option - WL_P2P_SCHED_TYPE_ABS */
include/wlioctl.h:4701:/* schedule option - WL_P2P_SCHED_TYPE_REQ_ABS */
include/wlioctl.h:4708:#define WL_P2P_FEAT_GO_NOLEGACY	(1 << 1)	/* GO does not probe respond to non-p2p probe
include/wlioctl.h:4797:/* n-mode support capability */
include/wlioctl.h:4974:	uint32  trf_mgmt_enabled;                           /* 0 - disabled, 1 - enabled */
include/sbpcmcia.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/sbpcmcia.h:24: * $Id: sbpcmcia.h 326494 2012-04-09 13:29:57Z $
include/bcmpcispi.h:2: * Broadcom PCI-SPI Host Controller Register Definitions
include/bcmpcispi.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmpcispi.h:24: * $Id: bcmpcispi.h 241182 2011-02-17 21:50:03Z $
include/bcmpcispi.h:40:	uint32 spih_data;		/* 0x08 SPI Data Register, 32-bits wide */
include/bcmpcispi.h:42:	uint32 PAD[4];			/* 0x10-0x1F PADDING */
include/bcmpcispi.h:46:	uint32 PAD[6];			/* 0x28-0x3F PADDING */
include/bcmpcispi.h:53:	uint32 PAD[4];			/* 0x50-0x5F PADDING */
include/bcmpcispi.h:55:	uint32 spih_hex_disp;		/* 0x60 SPI 4-digit hex display value */
include/bcmpcispi.h:58:	uint32 spih_disp_sel;		/* 0x6c SPI 4-digit hex display mode select (1=current) */
include/bcmpcispi.h:59:	uint32 PAD[4];			/* 0x70-0x7F PADDING */
include/bcmpcispi.h:60:	uint32 PAD[8];			/* 0x80-0x9F PADDING */
include/bcmpcispi.h:61:	uint32 PAD[8];			/* 0xA0-0xBF PADDING */
include/bcmpcispi.h:70:	uint32 cfg_space[0x40];		/* 0x000-0x0FF PCI Configuration Space (Read Only) */
include/bcmpcispi.h:100:	uint32 PAD[5];			/* 0x16C-0x17F PADDING */
include/packed_section_start.h:18: * Copyright (C) 1999-2012, Broadcom Corporation
include/packed_section_start.h:37: * $Id: packed_section_start.h 286783 2011-09-29 06:18:57Z $
include/packed_section_start.h:41:/* Error check - BWL_PACKED_SECTION is defined in packed_section_start.h
include/packed_section_start.h:54:/* Declare compiler-specific directives for structure packing. */
include/aidmp.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/aidmp.h:24: * $Id: aidmp.h 241182 2011-02-17 21:50:03Z $
include/aidmp.h:236:/* Out-of-band Router registers */
include/sbsdio.h:3: * sdio is a portion of the pcmcia core in core rev 3 - rev 8
include/sbsdio.h:7: * Copyright (C) 1999-2012, Broadcom Corporation
include/sbsdio.h:27: * $Id: sbsdio.h 361940 2012-10-10 08:32:12Z $
include/sbsdio.h:53:#define SBSDIO_FUNC1_SDIOPULLUP 	0x1000F		/* SdioPullUp (on cmd, d0-d2) */
include/sbsdio.h:95:#define SBSDIO_WATERMARK_MASK		0x7f		/* number of words - 1 for sd device
include/sbsdio.h:116:							 * external pads in tri-state; requires
include/sbsdio.h:119:#define SBSDIO_DEVCTL_SB_RST_CTL	0x30		/* Force SD->SB reset mapping (rev 11) */
include/sbsdio.h:157:#define SBSDIO_SB_ACCESS_2_4B_FLAG	0x08000		/* with b15, maps to 32-bit SB access */
include/bcmdevs.h:2: * Broadcom device-specific manifest constants.
include/bcmdevs.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmdevs.h:24: * $Id: bcmdevs.h 329854 2012-04-27 01:42:28Z $
include/bcmdevs.h:303:#define BCM4329_289PIN_PKG_ID	0		/* 4329 289-pin package id */
include/bcmdevs.h:304:#define BCM4329_182PIN_PKG_ID	1		/* 4329N 182-pin package id */
include/bcmdevs.h:334:#define BCM4314PCIE_PKG_ID		(8 | 2)	/* 4314 QFN PCI (ARM-less) package id */
include/bcmdevs.h:335:#define BCM4314SDIO_ARM_PKG_ID		(8 | 3)	/* 4314 QFN SDIO (ARM-less) package id */
include/bcmdevs.h:351:#define	BFL_CCKHIPWR		0x00000040  /* Can do high-power CCK transmission */
include/bcmdevs.h:384:#define BFL2_APLL_WAR		0x00000002  /* Flag to implement alternative A-band PLL settings */
include/bcmdevs.h:395:#define BFL2_SPUR_WAR		0x00000200  /* Board has a WAR for clock-harmonic spurs */
include/bcmdevs.h:396:#define BFL2_GPLL_WAR		0x00000400  /* Flag to narrow G-band PLL loop b/w */
include/bcmdevs.h:397:#define BFL2_TRISTATE_LED	0x00000800  /* Tri-state the LED */
include/bcmdevs.h:399:#define BFL2_2G_SPUR_WAR	0x00002000  /* WAR to reduce and avoid clock-harmonic spurs in 2G */
include/bcmdevs.h:402:#define BFL2_GPLL_WAR2	        0x00010000  /* Flag to widen G-band PLL loop b/w */
include/bcmdevs.h:426:/* board specific GPIO assignment, gpio 0-3 are also customer-configurable led */
include/bcmdevs.h:454:#define PCI_CFG_GPIO_XTAL	0x40	/* PCI config space GPIO 14 for Xtal power-up */
include/bcmdevs.h:455:#define PCI_CFG_GPIO_PLL	0x80	/* PCI config space GPIO 15 for PLL power-down */
include/bcmdevs.h:461:#define	XTAL_ON_DELAY		1000		/* us crystal power-on delay */
include/packed_section_end.h:18: * Copyright (C) 1999-2012, Broadcom Corporation
include/packed_section_end.h:37: * $Id: packed_section_end.h 241182 2011-02-17 21:50:03Z $
include/packed_section_end.h:41:/* Error check - BWL_PACKED_SECTION is defined in packed_section_start.h
include/packed_section_end.h:54:/* Compiler-specific directives for structure packing are declared in
include/pcicfg.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/pcicfg.h:24: * $Id: pcicfg.h 309193 2012-01-19 00:03:57Z $
include/pcicfg.h:32: * field offsetts. :-(
include/sbsdpcmdev.h:2: * Broadcom SiliconBackplane SDIO/PCMCIA hardware-specific
include/sbsdpcmdev.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
include/sbsdpcmdev.h:25: * $Id: sbsdpcmdev.h 347614 2012-07-27 10:24:51Z $
include/sbsdpcmdev.h:49:	dma64diag_t dmafifo;		/* DMA Diagnostic Regs, 0x280-0x28c */
include/sbsdpcmdev.h:55:	dma32regp_t dma32regs[2];	/* dma tx & rx, 0x200-0x23c */
include/sbsdpcmdev.h:56:	dma32diag_t dmafifo;		/* DMA Diagnostic Regs, 0x240-0x24c */
include/sbsdpcmdev.h:62:	dma32regp_t dmaregs;		/* DMA Regs, 0x200-0x21c, rev8 */
include/sbsdpcmdev.h:63:	dma32diag_t dmafifo;		/* DMA Diagnostic Regs, 0x220-0x22c */
include/sbsdpcmdev.h:136:	char cis[512];			/* 512 byte CIS, 0x400-0x5ff, rev6 */
include/sbsdpcmdev.h:139:	char pcmciafcr[256];		/* PCMCIA FCR, 0x600-6ff, rev6 */
include/sbsdpcmdev.h:159:	sbconfig_t sbconfig;		/* SbConfig Regs, 0xf00-0xfff, rev8 */
include/sbsdpcmdev.h:228:/* sdioaccess-accessible register address spaces */
include/sbsdpcmdev.h:232:#define SDA_F1_REG_SPACE	0x300	/* sdioAccess F1 core-specific register space */
include/sbsdpcmdev.h:234:/* SDA_F1_REG_SPACE sdioaccess-accessible F1 reg space register offsets */
include/sbsdpcmdev.h:266:#define SFC_ABORTALL	(1 << 3)	/* Abort cancels all in-progress frames */
include/hndpmu.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/hndpmu.h:24: * $Id: hndpmu.h 241182 2011-02-17 21:50:03Z $
include/epivers.h:2: * Copyright (C) 1999-2012, Broadcom Corporation
include/epivers.h:22: * $Id: epivers.h.in,v 13.33 2010-09-08 22:08:53 csm Exp $
include/bcmwifi_rates.h:2: * Indices for 802.11 a/b/g/n/ac 1-3 chain symmetric transmit rates
include/bcmwifi_rates.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
include/bcmwifi_rates.h:24: * $Id: bcmwifi_rates.h 252708 2011-04-12 06:45:56Z $
include/bcmwifi_rates.h:42:#define WL_RATE_DISABLED		(-128) /* Power value corresponding to unsupported rate */
Kconfig:5:	---help---
Kconfig:13:	---help---
Kconfig:20:	---help---
Kconfig:35:	---help---
Kconfig:43:	bool "Out-of-Band Interrupt"
Kconfig:44:	---help---
Kconfig:48:	bool "In-Band Interrupt"
Kconfig:50:	---help---
linux_osl.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
linux_osl.c:24: * $Id: linux_osl.c 373382 2012-12-07 07:59:52Z $
linux_osl.c:48:#define DHD_SKB_1PAGE_BUFSIZE	((PAGE_SIZE*1)-DHD_SKB_HDRSIZE)
linux_osl.c:49:#define DHD_SKB_2PAGE_BUFSIZE	((PAGE_SIZE*2)-DHD_SKB_HDRSIZE)
linux_osl.c:50:#define DHD_SKB_4PAGE_BUFSIZE	((PAGE_SIZE*4)-DHD_SKB_HDRSIZE)
linux_osl.c:117:	-EINVAL,		/* BCME_ERROR */
linux_osl.c:118:	-EINVAL,		/* BCME_BADARG */
linux_osl.c:119:	-EINVAL,		/* BCME_BADOPTION */
linux_osl.c:120:	-EINVAL,		/* BCME_NOTUP */
linux_osl.c:121:	-EINVAL,		/* BCME_NOTDOWN */
linux_osl.c:122:	-EINVAL,		/* BCME_NOTAP */
linux_osl.c:123:	-EINVAL,		/* BCME_NOTSTA */
linux_osl.c:124:	-EINVAL,		/* BCME_BADKEYIDX */
linux_osl.c:125:	-EINVAL,		/* BCME_RADIOOFF */
linux_osl.c:126:	-EINVAL,		/* BCME_NOTBANDLOCKED */
linux_osl.c:127:	-EINVAL, 		/* BCME_NOCLK */
linux_osl.c:128:	-EINVAL, 		/* BCME_BADRATESET */
linux_osl.c:129:	-EINVAL, 		/* BCME_BADBAND */
linux_osl.c:130:	-E2BIG,			/* BCME_BUFTOOSHORT */
linux_osl.c:131:	-E2BIG,			/* BCME_BUFTOOLONG */
linux_osl.c:132:	-EBUSY, 		/* BCME_BUSY */
linux_osl.c:133:	-EINVAL, 		/* BCME_NOTASSOCIATED */
linux_osl.c:134:	-EINVAL, 		/* BCME_BADSSIDLEN */
linux_osl.c:135:	-EINVAL, 		/* BCME_OUTOFRANGECHAN */
linux_osl.c:136:	-EINVAL, 		/* BCME_BADCHAN */
linux_osl.c:137:	-EFAULT, 		/* BCME_BADADDR */
linux_osl.c:138:	-ENOMEM, 		/* BCME_NORESOURCE */
linux_osl.c:139:	-EOPNOTSUPP,		/* BCME_UNSUPPORTED */
linux_osl.c:140:	-EMSGSIZE,		/* BCME_BADLENGTH */
linux_osl.c:141:	-EINVAL,		/* BCME_NOTREADY */
linux_osl.c:142:	-EPERM,			/* BCME_EPERM */
linux_osl.c:143:	-ENOMEM, 		/* BCME_NOMEM */
linux_osl.c:144:	-EINVAL, 		/* BCME_ASSOCIATED */
linux_osl.c:145:	-ERANGE, 		/* BCME_RANGE */
linux_osl.c:146:	-EINVAL, 		/* BCME_NOTFOUND */
linux_osl.c:147:	-EINVAL, 		/* BCME_WME_NOT_ENABLED */
linux_osl.c:148:	-EINVAL, 		/* BCME_TSPEC_NOTFOUND */
linux_osl.c:149:	-EINVAL, 		/* BCME_ACM_NOTSUPPORTED */
linux_osl.c:150:	-EINVAL,		/* BCME_NOT_WME_ASSOCIATION */
linux_osl.c:151:	-EIO,			/* BCME_SDIO_ERROR */
linux_osl.c:152:	-ENODEV,		/* BCME_DONGLE_DOWN */
linux_osl.c:153:	-EINVAL,		/* BCME_VERSION */
linux_osl.c:154:	-EIO,			/* BCME_TXFAIL */
linux_osl.c:155:	-EIO,			/* BCME_RXFAIL */
linux_osl.c:156:	-ENODEV,		/* BCME_NODEVICE */
linux_osl.c:157:	-EINVAL,		/* BCME_NMODE_DISABLED */
linux_osl.c:158:	-ENODATA,		/* BCME_NONRESIDENT */
linux_osl.c:164:#if BCME_LAST != -42
linux_osl.c:180:	return linuxbcmerrormap[-bcmerror];
linux_osl.c:198:	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(linuxbcmerrormap) - 1));
linux_osl.c:200:	osh->magic = OS_HANDLE_MAGIC;
linux_osl.c:201:	atomic_set(&osh->malloced, 0);
linux_osl.c:202:	osh->failed = 0;
linux_osl.c:203:	osh->dbgmem_list = NULL;
linux_osl.c:204:	spin_lock_init(&(osh->dbgmem_lock));
linux_osl.c:205:	osh->pdev = pdev;
linux_osl.c:206:	osh->pub.pkttag = pkttag;
linux_osl.c:207:	osh->bustype = bustype;
linux_osl.c:213:			osh->pub.mmbus = TRUE;
linux_osl.c:220:			osh->pub.mmbus = FALSE;
linux_osl.c:237:		sema_init(&bcm_static_buf->static_sem, 1);
linux_osl.c:239:		bcm_static_buf->buf_ptr = (unsigned char *)bcm_static_buf + STATIC_BUF_SIZE;
linux_osl.c:251:			bcm_static_skb->pkt_use[i] = 0;
linux_osl.c:253:		sema_init(&bcm_static_skb->osl_pkt_sem, 1);
linux_osl.c:257:	spin_lock_init(&(osh->pktalloc_lock));
linux_osl.c:277:	ASSERT(osh->magic == OS_HANDLE_MAGIC);
linux_osl.c:293:#define CTFPOOL_LOCK(ctfpool, flags)	spin_lock_irqsave(&(ctfpool)->lock, flags)
linux_osl.c:294:#define CTFPOOL_UNLOCK(ctfpool, flags)	spin_unlock_irqrestore(&(ctfpool)->lock, flags)
linux_osl.c:296:#define CTFPOOL_LOCK(ctfpool, flags)	spin_lock_bh(&(ctfpool)->lock)
linux_osl.c:297:#define CTFPOOL_UNLOCK(ctfpool, flags)	spin_unlock_bh(&(ctfpool)->lock)
linux_osl.c:310:	if ((osh == NULL) || (osh->ctfpool == NULL))
linux_osl.c:313:	CTFPOOL_LOCK(osh->ctfpool, flags);
linux_osl.c:314:	ASSERT(osh->ctfpool->curr_obj <= osh->ctfpool->max_obj);
linux_osl.c:317:	if (osh->ctfpool->curr_obj == osh->ctfpool->max_obj) {
linux_osl.c:318:		CTFPOOL_UNLOCK(osh->ctfpool, flags);
linux_osl.c:323:	skb = osl_alloc_skb(osh->ctfpool->obj_size);
linux_osl.c:326:		       osh->ctfpool->obj_size);
linux_osl.c:327:		CTFPOOL_UNLOCK(osh->ctfpool, flags);
linux_osl.c:332:	skb->next = (struct sk_buff *)osh->ctfpool->head;
linux_osl.c:333:	osh->ctfpool->head = skb;
linux_osl.c:334:	osh->ctfpool->fast_frees++;
linux_osl.c:335:	osh->ctfpool->curr_obj++;
linux_osl.c:338:	CTFPOOLPTR(osh, skb) = (void *)osh->ctfpool;
linux_osl.c:343:	CTFPOOL_UNLOCK(osh->ctfpool, flags);
linux_osl.c:354:	if ((osh == NULL) || (osh->ctfpool == NULL))
linux_osl.c:358:	while ((osh->ctfpool->refills > 0) && (thresh--)) {
linux_osl.c:360:		osh->ctfpool->refills--;
linux_osl.c:370:	osh->ctfpool = kmalloc(sizeof(ctfpool_t), GFP_ATOMIC);
linux_osl.c:371:	ASSERT(osh->ctfpool);
linux_osl.c:372:	bzero(osh->ctfpool, sizeof(ctfpool_t));
linux_osl.c:374:	osh->ctfpool->max_obj = numobj;
linux_osl.c:375:	osh->ctfpool->obj_size = size;
linux_osl.c:377:	spin_lock_init(&osh->ctfpool->lock);
linux_osl.c:379:	while (numobj--) {
linux_osl.c:381:			return -1;
linux_osl.c:382:		osh->ctfpool->fast_frees--;
linux_osl.c:399:	if ((osh == NULL) || (osh->ctfpool == NULL))
linux_osl.c:402:	CTFPOOL_LOCK(osh->ctfpool, flags);
linux_osl.c:404:	skb = osh->ctfpool->head;
linux_osl.c:407:		nskb = skb->next;
linux_osl.c:410:		osh->ctfpool->curr_obj--;
linux_osl.c:413:	ASSERT(osh->ctfpool->curr_obj == 0);
linux_osl.c:414:	osh->ctfpool->head = NULL;
linux_osl.c:415:	CTFPOOL_UNLOCK(osh->ctfpool, flags);
linux_osl.c:417:	kfree(osh->ctfpool);
linux_osl.c:418:	osh->ctfpool = NULL;
linux_osl.c:426:	if ((osh == NULL) || (osh->ctfpool == NULL))
linux_osl.c:443:	            osh->ctfpool->max_obj, osh->ctfpool->obj_size,
linux_osl.c:444:	            osh->ctfpool->curr_obj, osh->ctfpool->refills);
linux_osl.c:446:	            osh->ctfpool->fast_allocs, osh->ctfpool->fast_frees,
linux_osl.c:447:	            osh->ctfpool->slow_allocs);
linux_osl.c:461:	if (osh->ctfpool == NULL)
linux_osl.c:464:	CTFPOOL_LOCK(osh->ctfpool, flags);
linux_osl.c:465:	if (osh->ctfpool->head == NULL) {
linux_osl.c:466:		ASSERT(osh->ctfpool->curr_obj == 0);
linux_osl.c:467:		osh->ctfpool->slow_allocs++;
linux_osl.c:468:		CTFPOOL_UNLOCK(osh->ctfpool, flags);
linux_osl.c:472:	ASSERT(len <= osh->ctfpool->obj_size);
linux_osl.c:475:	skb = (struct sk_buff *)osh->ctfpool->head;
linux_osl.c:476:	osh->ctfpool->head = (void *)skb->next;
linux_osl.c:478:	osh->ctfpool->fast_allocs++;
linux_osl.c:479:	osh->ctfpool->curr_obj--;
linux_osl.c:480:	ASSERT(CTFPOOLHEAD(osh, skb) == (struct sock *)osh->ctfpool->head);
linux_osl.c:481:	CTFPOOL_UNLOCK(osh->ctfpool, flags);
linux_osl.c:484:	skb->next = skb->prev = NULL;
linux_osl.c:485:	skb->data = skb->head + 16;
linux_osl.c:486:	skb->tail = skb->head + 16;
linux_osl.c:488:	skb->len = 0;
linux_osl.c:489:	skb->cloned = 0;
linux_osl.c:491:	skb->list = NULL;
linux_osl.c:493:	atomic_set(&skb->users, 1);
linux_osl.c:500: * IP code depends on skb->cb to be setup correctly with various options
linux_osl.c:511:	if (osh->pub.pkttag)
linux_osl.c:512:		bzero((void*)((struct sk_buff *)pkt)->cb, OSL_PKTTAG_SZ);
linux_osl.c:516:	for (nskb = (struct sk_buff *)pkt; nskb; nskb = nskb->next) {
linux_osl.c:517:		spin_lock_irqsave(&osh->pktalloc_lock, flags);
linux_osl.c:518:		osh->pub.pktalloced--;
linux_osl.c:519:		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
linux_osl.c:537:	if (osh->pub.pkttag)
linux_osl.c:538:		bzero((void*)((struct sk_buff *)pkt)->cb, OSL_PKTTAG_SZ);
linux_osl.c:542:	for (nskb = (struct sk_buff *)pkt; nskb; nskb = nskb->next) {
linux_osl.c:543:		spin_lock_irqsave(&osh->pktalloc_lock, flags);
linux_osl.c:544:		osh->pub.pktalloced++;
linux_osl.c:545:		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
linux_osl.c:566:		skb->priority = 0;
linux_osl.c:569:		spin_lock_irqsave(&osh->pktalloc_lock, flags);
linux_osl.c:570:		osh->pub.pktalloced++;
linux_osl.c:571:		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
linux_osl.c:587:	skb->tstamp.tv.sec = 0;
linux_osl.c:589:	skb->stamp.tv_sec = 0;
linux_osl.c:593:	skb->dev = NULL;
linux_osl.c:594:	skb->dst = NULL;
linux_osl.c:595:	memset(skb->cb, 0, sizeof(skb->cb));
linux_osl.c:596:	skb->ip_summed = 0;
linux_osl.c:597:	skb->destructor = NULL;
linux_osl.c:604:	skb->next = (struct sk_buff *)ctfpool->head;
linux_osl.c:605:	ctfpool->head = (void *)skb;
linux_osl.c:607:	ctfpool->fast_frees++;
linux_osl.c:608:	ctfpool->curr_obj++;
linux_osl.c:610:	ASSERT(ctfpool->curr_obj <= ctfpool->max_obj);
linux_osl.c:624:	if (send && osh->pub.tx_fn)
linux_osl.c:625:		osh->pub.tx_fn(osh->pub.tx_ctx, p, 0);
linux_osl.c:629:	/* perversion: we use skb->next to chain multi-skb packets */
linux_osl.c:631:		nskb = skb->next;
linux_osl.c:632:		skb->next = NULL;
linux_osl.c:637:		if ((PKTISFAST(osh, skb)) && (atomic_read(&skb->users) == 1))
linux_osl.c:644:			if (skb->destructor)
linux_osl.c:655:		spin_lock_irqsave(&osh->pktalloc_lock, flags);
linux_osl.c:656:		osh->pub.pktalloced--;
linux_osl.c:657:		spin_unlock_irqrestore(&osh->pktalloc_lock, flags);
linux_osl.c:676:	down(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:680:			if (bcm_static_skb->pkt_use[i] == 0)
linux_osl.c:685:			bcm_static_skb->pkt_use[i] = 1;
linux_osl.c:687:			skb = bcm_static_skb->skb_4k[i];
linux_osl.c:688:			skb->tail = skb->data + len;
linux_osl.c:689:			skb->len = len;
linux_osl.c:691:			up(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:699:			if (bcm_static_skb->pkt_use[i + STATIC_PKT_MAX_NUM]
linux_osl.c:705:			bcm_static_skb->pkt_use[i + STATIC_PKT_MAX_NUM] = 1;
linux_osl.c:706:			skb = bcm_static_skb->skb_8k[i];
linux_osl.c:707:			skb->tail = skb->data + len;
linux_osl.c:708:			skb->len = len;
linux_osl.c:710:			up(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:716:	if (bcm_static_skb->pkt_use[STATIC_PKT_MAX_NUM * 2] == 0) {
linux_osl.c:717:		bcm_static_skb->pkt_use[STATIC_PKT_MAX_NUM * 2] = 1;
linux_osl.c:719:		skb = bcm_static_skb->skb_16k;
linux_osl.c:720:		skb->tail = skb->data + len;
linux_osl.c:721:		skb->len = len;
linux_osl.c:723:		up(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:728:	up(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:742:	down(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:744:		if (p == bcm_static_skb->skb_4k[i]) {
linux_osl.c:745:			bcm_static_skb->pkt_use[i] = 0;
linux_osl.c:746:			up(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:752:		if (p == bcm_static_skb->skb_8k[i]) {
linux_osl.c:753:			bcm_static_skb->pkt_use[i + STATIC_PKT_MAX_NUM] = 0;
linux_osl.c:754:			up(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:759:	if (p == bcm_static_skb->skb_16k) {
linux_osl.c:760:		bcm_static_skb->pkt_use[STATIC_PKT_MAX_NUM*2] = 0;
linux_osl.c:761:		up(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:765:	up(&bcm_static_skb->osl_pkt_sem);
linux_osl.c:778:	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
linux_osl.c:784:		pci_read_config_dword(osh->pdev, offset, &val);
linux_osl.c:787:	} while (retry--);
linux_osl.c:798:	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
linux_osl.c:804:		pci_write_config_dword(osh->pdev, offset, val);
linux_osl.c:809:	} while (retry--);
linux_osl.c:813:/* return bus # for the pci device pointed by osh->pdev */
linux_osl.c:817:	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
linux_osl.c:819:	return ((struct pci_dev *)osh->pdev)->bus->number;
linux_osl.c:822:/* return slot # for the pci device pointed by osh->pdev */
linux_osl.c:826:	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
linux_osl.c:828:	return PCI_SLOT(((struct pci_dev *)osh->pdev)->devfn);
linux_osl.c:831:/* return the pci device pointed by osh->pdev */
linux_osl.c:835:	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
linux_osl.c:837:	return osh->pdev;
linux_osl.c:864:		ASSERT(osh->magic == OS_HANDLE_MAGIC);
linux_osl.c:872:			down(&bcm_static_buf->static_sem);
linux_osl.c:876:				if (bcm_static_buf->buf_use[i] == 0)
linux_osl.c:882:				up(&bcm_static_buf->static_sem);
linux_osl.c:887:			bcm_static_buf->buf_use[i] = 1;
linux_osl.c:888:			up(&bcm_static_buf->static_sem);
linux_osl.c:890:			bzero(bcm_static_buf->buf_ptr+STATIC_BUF_SIZE*i, size);
linux_osl.c:892:				atomic_add(size, &osh->malloced);
linux_osl.c:894:			return ((void *)(bcm_static_buf->buf_ptr+STATIC_BUF_SIZE*i));
linux_osl.c:902:			osh->failed++;
linux_osl.c:906:		atomic_add(size, &osh->malloced);
linux_osl.c:922:			buf_idx = ((unsigned char *)addr - bcm_static_buf->buf_ptr)/STATIC_BUF_SIZE;
linux_osl.c:924:			down(&bcm_static_buf->static_sem);
linux_osl.c:925:			bcm_static_buf->buf_use[buf_idx] = 0;
linux_osl.c:926:			up(&bcm_static_buf->static_sem);
linux_osl.c:929:				ASSERT(osh->magic == OS_HANDLE_MAGIC);
linux_osl.c:930:				atomic_sub(size, &osh->malloced);
linux_osl.c:937:		ASSERT(osh->magic == OS_HANDLE_MAGIC);
linux_osl.c:938:		atomic_sub(size, &osh->malloced);
linux_osl.c:946:	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
linux_osl.c:947:	return (atomic_read(&osh->malloced));
linux_osl.c:953:	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
linux_osl.c:954:	return (osh->failed);
linux_osl.c:968:	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
linux_osl.c:974:	return (pci_alloc_consistent(osh->pdev, size, (dma_addr_t*)pap));
linux_osl.c:980:	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
linux_osl.c:982:	pci_free_consistent(osh->pdev, size, va, (dma_addr_t)pa);
linux_osl.c:990:	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
linux_osl.c:992:	return (pci_map_single(osh->pdev, va, size, dir));
linux_osl.c:1000:	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
linux_osl.c:1002:	pci_unmap_single(osh->pdev, (uint32)pa, size, dir);
linux_osl.c:1037:		usec -= d;
linux_osl.c:1073:		ctfpool->refills++;
linux_osl.c:1077:	/* skb_clone copies skb->cb.. we don't want that */
linux_osl.c:1078:	if (osh->pub.pkttag)
linux_osl.c:1079:		bzero((void*)((struct sk_buff *)p)->cb, OSL_PKTTAG_SZ);
linux_osl.c:1082:	spin_lock_irqsave(&osh->pktalloc_lock, irqflags);
linux_osl.c:1083:	osh->pub.pktalloced++;
linux_osl.c:1084:	spin_unlock_irqrestore(&osh->pktalloc_lock, irqflags);
linux_osl.c:1094: * BINOSL selects the slightly slower function-call-based binary compatible osl.
linux_osl.c:1125:	rdlen = kernel_read(fp, fp->f_pos, buf, len);
linux_osl.c:1127:		fp->f_pos += rdlen;
Makefile:2:DHDCFLAGS = -Wall -Wstrict-prototypes -Dlinux -DBCMDRIVER                \
Makefile:3:	-DBCMDONGLEHOST -DUNRELEASEDCHIP -DBCMDMA32 -DBCMFILEIMAGE            \
Makefile:4:	-DDHDTHREAD -DDHD_DEBUG -DSDTEST -DBDC -DTOE                          \
Makefile:5:	-DDHD_BCMEVENTS -DSHOW_EVENTS -DPROP_TXSTATUS -DBCMDBG                \
Makefile:6:	-DMMC_SDIO_ABORT -DBCMSDIO -DBCMLXSDMMC -DBCMPLATFORM_BUS -DWLP2P     \
Makefile:7:	-DWIFI_ACT_FRAME -DARP_OFFLOAD_SUPPORT                                \
Makefile:8:	-DKEEP_ALIVE -DPKT_FILTER_SUPPORT                                     \
Makefile:9:	-DEMBEDDED_PLATFORM -DENABLE_INSMOD_NO_FW_LOAD -DPNO_SUPPORT          \
Makefile:10:	-DDHD_USE_IDLECOUNT -DSET_RANDOM_MAC_SOFTAP -DVSDB      \
Makefile:11:	-DWL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST -DSDIO_CRC_ERROR_FIX       \
Makefile:12:	-DESCAN_RESULT_PATCH -DHT40_GO -DPASS_ARP_PACKET -DSUPPORT_PM2_ONLY   \
Makefile:13:	-DDHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT -DAMPDU_HOSTREORDER       \
Makefile:14:	-DCUSTOM_SDIO_F2_BLKSIZE=128 -DWL_SDO -DWL_SUPPORT_BACKPORTED_KPATCHES\
Makefile:15:	-Idrivers/net/wireless/bcmdhd -Idrivers/net/wireless/bcmdhd/include
Makefile:22:obj-$(CONFIG_BCMDHD) += bcmdhd.o
Makefile:23:bcmdhd-objs += $(DHDOFILES)
Makefile:27:#DHDCFLAGS += -Iarch/arm/plat-samsung/include
Makefile:28:DHDCFLAGS += -DCUSTOMER_HW
Makefile:29:DHDCFLAGS += -DSET_RANDOM_MAC_SOFTAP
Makefile:30:DHDCFLAGS += -DDISABLE_FW_ROAM_SUSPEND -DDISABLE_BUILTIN_ROAM
Makefile:34:DHDCFLAGS += -DOOB_INTR_ONLY -DHW_OOB -DCUSTOMER_OOB
Makefile:36:DHDCFLAGS += -DSDIO_ISR_THREAD
Makefile:40:	DHDCFLAGS += -DBAND_AG
Makefile:44:bcmdhd-objs += wl_iw.o
Makefile:45:DHDCFLAGS += -DSOFTAP -DWL_WIRELESS_EXT -DUSE_IW
Makefile:48:bcmdhd-objs += wl_cfg80211.o wl_cfgp2p.o wl_linux_mon.o dhd_cfg80211.o
Makefile:49:DHDCFLAGS += -DWL_CFG80211 -DWL_CFG80211_STA_EVENT -DWL_ENABLE_P2P_IF
Makefile:50:DHDCFLAGS += -DCUSTOM_ROAM_TRIGGER_SETTING=-65
Makefile:51:DHDCFLAGS += -DCUSTOM_ROAM_DELTA_SETTING=15
Makefile:52:DHDCFLAGS += -DCUSTOM_KEEP_ALIVE_SETTING=28000
Makefile:53:DHDCFLAGS += -DCUSTOM_PNO_EVENT_LOCK_xTIME=7
Makefile:56:DHDCFLAGS += -DWL_SCHED_SCAN
Makefile:60:EXTRA_LDFLAGS += --strip-debug
sbutils.c:2: * Misc utility routines for accessing chip-specific features
sbutils.c:3: * of the SiliconBackplane-based Broadcom chips.
sbutils.c:5: * Copyright (C) 1999-2012, Broadcom Corporation
sbutils.c:25: * $Id: sbutils.c 310902 2012-01-26 19:45:33Z $
sbutils.c:79:		OSL_PCMCIA_WRITE_ATTR(sii->osh, MEM_SEG, &tmp, 1);
sbutils.c:83:	val = R_REG(sii->osh, sbr);
sbutils.c:87:		OSL_PCMCIA_WRITE_ATTR(sii->osh, MEM_SEG, &tmp, 1);
sbutils.c:111:		OSL_PCMCIA_WRITE_ATTR(sii->osh, MEM_SEG, &tmp, 1);
sbutils.c:115:	if (BUSTYPE(sii->pub.bustype) == PCMCIA_BUS) {
sbutils.c:116:		dummy = R_REG(sii->osh, sbr);
sbutils.c:118:		W_REG(sii->osh, (volatile uint16 *)sbr, (uint16)(v & 0xffff));
sbutils.c:119:		dummy = R_REG(sii->osh, sbr);
sbutils.c:121:		W_REG(sii->osh, ((volatile uint16 *)sbr + 1), (uint16)((v >> 16) & 0xffff));
sbutils.c:123:		W_REG(sii->osh, sbr, v);
sbutils.c:127:		OSL_PCMCIA_WRITE_ATTR(sii->osh, MEM_SEG, &tmp, 1);
sbutils.c:139:	sb = REGS2SB(sii->curmap);
sbutils.c:141:	return ((R_SBREG(sii, &sb->sbidhigh) & SBIDH_CC_MASK) >> SBIDH_CC_SHIFT);
sbutils.c:159:	intflag = R_SBREG(sii, &sb->sbflagst);
sbutils.c:173:	sb = REGS2SB(sii->curmap);
sbutils.c:175:	return R_SBREG(sii, &sb->sbtpsflag) & SBTPS_NUM0_MASK;
sbutils.c:186:	sb = REGS2SB(sii->curmap);
sbutils.c:188:	if (siflag == -1)
sbutils.c:192:	W_SBREG(sii, &sb->sbintvec, vec);
sbutils.c:201:	for (i = 0; i < sii->numcores; i ++)
sbutils.c:202:		if (sba == sii->coresba[i])
sbutils.c:214:	switch (BUSTYPE(sii->pub.bustype)) {
sbutils.c:216:		sbconfig_t *sb = REGS2SB(sii->curmap);
sbutils.c:217:		sbaddr = sb_base(R_SBREG(sii, &sb->sbadmatch0));
sbutils.c:222:		sbaddr = OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(uint32));
sbutils.c:227:		OSL_PCMCIA_READ_ATTR(sii->osh, PCMCIA_ADDR0, &tmp, 1);
sbutils.c:229:		OSL_PCMCIA_READ_ATTR(sii->osh, PCMCIA_ADDR1, &tmp, 1);
sbutils.c:231:		OSL_PCMCIA_READ_ATTR(sii->osh, PCMCIA_ADDR2, &tmp, 1);
sbutils.c:238:		sbaddr = (uint32)(uintptr)sii->curmap;
sbutils.c:257:	sb = REGS2SB(sii->curmap);
sbutils.c:259:	return ((R_SBREG(sii, &sb->sbidhigh) & SBIDH_VC_MASK) >> SBIDH_VC_SHIFT);
sbutils.c:270:	sb = REGS2SB(sii->curmap);
sbutils.c:271:	sbidh = R_SBREG(sii, &sb->sbidhigh);
sbutils.c:276:/* set core-specific control flags */
sbutils.c:285:	sb = REGS2SB(sii->curmap);
sbutils.c:290:	w = (R_SBREG(sii, &sb->sbtmstatelow) & ~(mask << SBTML_SICF_SHIFT)) |
sbutils.c:292:	W_SBREG(sii, &sb->sbtmstatelow, w);
sbutils.c:295:/* set/clear core-specific control flags */
sbutils.c:304:	sb = REGS2SB(sii->curmap);
sbutils.c:310:		w = (R_SBREG(sii, &sb->sbtmstatelow) & ~(mask << SBTML_SICF_SHIFT)) |
sbutils.c:312:		W_SBREG(sii, &sb->sbtmstatelow, w);
sbutils.c:318:	return (R_SBREG(sii, &sb->sbtmstatelow) >> SBTML_SICF_SHIFT);
sbutils.c:321:/* set/clear core-specific status flags */
sbutils.c:330:	sb = REGS2SB(sii->curmap);
sbutils.c:337:		w = (R_SBREG(sii, &sb->sbtmstatehigh) & ~(mask << SBTMH_SISF_SHIFT)) |
sbutils.c:339:		W_SBREG(sii, &sb->sbtmstatehigh, w);
sbutils.c:343:	return (R_SBREG(sii, &sb->sbtmstatehigh) >> SBTMH_SISF_SHIFT);
sbutils.c:353:	sb = REGS2SB(sii->curmap);
sbutils.c:355:	return ((R_SBREG(sii, &sb->sbtmstatelow) &
sbutils.c:388:	if (BUSTYPE(sii->pub.bustype) == SI_BUS) {
sbutils.c:392:		if (!sii->regs[coreidx]) {
sbutils.c:393:			sii->regs[coreidx] = REG_MAP(sii->coresba[coreidx],
sbutils.c:395:			ASSERT(GOODREGS(sii->regs[coreidx]));
sbutils.c:397:		r = (uint32 *)((uchar *)sii->regs[coreidx] + regoff);
sbutils.c:398:	} else if (BUSTYPE(sii->pub.bustype) == PCI_BUS) {
sbutils.c:401:		if ((sii->coreid[coreidx] == CC_CORE_ID) && SI_FAST(sii)) {
sbutils.c:405:			r = (uint32 *)((char *)sii->curmap + PCI_16KB0_CCREGS_OFFSET + regoff);
sbutils.c:406:		} else if (sii->pub.buscoreidx == coreidx) {
sbutils.c:412:				r = (uint32 *)((char *)sii->curmap +
sbutils.c:415:				r = (uint32 *)((char *)sii->curmap +
sbutils.c:426:		origidx = si_coreidx(&sii->pub);
sbutils.c:429:		r = (uint32*) ((uchar*)sb_setcoreidx(&sii->pub, coreidx) + regoff);
sbutils.c:439:			w = (R_REG(sii->osh, r) & ~mask) | val;
sbutils.c:440:			W_REG(sii->osh, r, w);
sbutils.c:448:		if ((CHIPID(sii->pub.chip) == BCM5354_CHIP_ID) &&
sbutils.c:453:			w = R_REG(sii->osh, r);
sbutils.c:459:			sb_setcoreidx(&sii->pub, origidx);
sbutils.c:491:	for (i = 0, next = sii->numcores; i < numcores && next < SB_BUS_MAXCORES; i++, next++) {
sbutils.c:492:		sii->coresba[next] = sbba + (i * SI_CORE_SIZE);
sbutils.c:495:		if ((BUSTYPE(sii->pub.bustype) == SI_BUS) && (sii->coresba[next] == sba)) {
sbutils.c:497:			sii->regs[next] = regs;
sbutils.c:501:		sii->curmap = _sb_setcoreidx(sii, next);
sbutils.c:502:		sii->curidx = next;
sbutils.c:504:		sii->coreid[next] = sb_coreid(&sii->pub);
sbutils.c:508:		if (sii->coreid[next] == CC_CORE_ID) {
sbutils.c:509:			chipcregs_t *cc = (chipcregs_t *)sii->curmap;
sbutils.c:510:			uint32 ccrev = sb_corerev(&sii->pub);
sbutils.c:512:			/* determine numcores - this is the total # cores in the chip */
sbutils.c:514:				numcores = (R_REG(sii->osh, &cc->chipid) & CID_CC_MASK) >>
sbutils.c:518:				uint chip = CHIPID(sii->pub.chip);
sbutils.c:534:				sii->pub.issim ? "QT" : ""));
sbutils.c:537:		else if (sii->coreid[next] == OCP_CORE_ID) {
sbutils.c:538:			sbconfig_t *sb = REGS2SB(sii->curmap);
sbutils.c:539:			uint32 nsbba = R_SBREG(sii, &sb->sbadmatch1);
sbutils.c:542:			sii->numcores = next + 1;
sbutils.c:550:			nsbcc = (R_SBREG(sii, &sb->sbtmstatehigh) & 0x000f0000) >> 16;
sbutils.c:553:				numcores -= nsbcc;
sbutils.c:560:	sii->numcores = i + ncc;
sbutils.c:561:	return sii->numcores;
sbutils.c:573:	sb = REGS2SB(sii->curmap);
sbutils.c:575:	sii->pub.socirev = (R_SBREG(sii, &sb->sbidlow) & SBIDL_RV_MASK) >> SBIDL_RV_SHIFT;
sbutils.c:583:	sii->numcores = _sb_scan(sii, origsba, regs, 0, SI_ENUM_BASE, 1);
sbutils.c:598:	if (coreidx >= sii->numcores)
sbutils.c:605:	ASSERT((sii->intrsenabled_fn == NULL) || !(*(sii)->intrsenabled_fn)((sii)->intr_arg));
sbutils.c:607:	sii->curmap = _sb_setcoreidx(sii, coreidx);
sbutils.c:608:	sii->curidx = coreidx;
sbutils.c:610:	return (sii->curmap);
sbutils.c:619:	uint32 sbaddr = sii->coresba[coreidx];
sbutils.c:622:	switch (BUSTYPE(sii->pub.bustype)) {
sbutils.c:625:		if (!sii->regs[coreidx]) {
sbutils.c:626:			sii->regs[coreidx] = REG_MAP(sbaddr, SI_CORE_SIZE);
sbutils.c:627:			ASSERT(GOODREGS(sii->regs[coreidx]));
sbutils.c:629:		regs = sii->regs[coreidx];
sbutils.c:634:		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, sbaddr);
sbutils.c:635:		regs = sii->curmap;
sbutils.c:640:		OSL_PCMCIA_WRITE_ATTR(sii->osh, PCMCIA_ADDR0, &tmp, 1);
sbutils.c:642:		OSL_PCMCIA_WRITE_ATTR(sii->osh, PCMCIA_ADDR1, &tmp, 1);
sbutils.c:644:		OSL_PCMCIA_WRITE_ATTR(sii->osh, PCMCIA_ADDR2, &tmp, 1);
sbutils.c:645:		regs = sii->curmap;
sbutils.c:651:		if (!sii->regs[coreidx]) {
sbutils.c:652:			sii->regs[coreidx] = (void *)(uintptr)sbaddr;
sbutils.c:653:			ASSERT(GOODREGS(sii->regs[coreidx]));
sbutils.c:655:		regs = sii->regs[coreidx];
sbutils.c:675:	sb = REGS2SB(sii->curmap);
sbutils.c:679:		addrm =  &sb->sbadmatch0;
sbutils.c:683:		addrm =  &sb->sbadmatch1;
sbutils.c:687:		addrm =  &sb->sbadmatch2;
sbutils.c:691:		addrm =  &sb->sbadmatch3;
sbutils.c:710:	sb = REGS2SB(sii->curmap);
sbutils.c:713:	return ((R_SBREG(sii, &sb->sbidlow) & SBIDL_AR_MASK) >> SBIDL_AR_SHIFT) + 1;
sbutils.c:749:	origidx = sii->curidx;
sbutils.c:755:	if (sii->pub.ccrev != NOREV) {
sbutils.c:760:		W_REG(sii->osh, &ccregs->broadcastaddress, SB_COMMIT);
sbutils.c:761:		W_REG(sii->osh, &ccregs->broadcastdata, 0x0);
sbutils.c:779:	ASSERT(GOODREGS(sii->curmap));
sbutils.c:780:	sb = REGS2SB(sii->curmap);
sbutils.c:783:	if (R_SBREG(sii, &sb->sbtmstatelow) & SBTML_RESET)
sbutils.c:787:	if ((R_SBREG(sii, &sb->sbtmstatelow) & (SICF_CLOCK_EN << SBTML_SICF_SHIFT)) == 0)
sbutils.c:790:	/* set target reject and spin until busy is clear (preserve core-specific bits) */
sbutils.c:791:	OR_SBREG(sii, &sb->sbtmstatelow, SBTML_REJ);
sbutils.c:792:	dummy = R_SBREG(sii, &sb->sbtmstatelow);
sbutils.c:795:	SPINWAIT((R_SBREG(sii, &sb->sbtmstatehigh) & SBTMH_BUSY), 100000);
sbutils.c:796:	if (R_SBREG(sii, &sb->sbtmstatehigh) & SBTMH_BUSY)
sbutils.c:799:	if (R_SBREG(sii, &sb->sbidlow) & SBIDL_INIT) {
sbutils.c:800:		OR_SBREG(sii, &sb->sbimstate, SBIM_RJ);
sbutils.c:801:		dummy = R_SBREG(sii, &sb->sbimstate);
sbutils.c:804:		SPINWAIT((R_SBREG(sii, &sb->sbimstate) & SBIM_BY), 100000);
sbutils.c:808:	W_SBREG(sii, &sb->sbtmstatelow,
sbutils.c:811:	dummy = R_SBREG(sii, &sb->sbtmstatelow);
sbutils.c:816:	if (R_SBREG(sii, &sb->sbidlow) & SBIDL_INIT)
sbutils.c:817:		AND_SBREG(sii, &sb->sbimstate, ~SBIM_RJ);
sbutils.c:821:	W_SBREG(sii, &sb->sbtmstatelow, ((bits << SBTML_SICF_SHIFT) | SBTML_REJ | SBTML_RESET));
sbutils.c:825:/* reset and re-enable a core
sbutils.c:827: * bits - core specific bits that are set during and after reset sequence
sbutils.c:828: * resetbits - core specific bits that are set only during reset sequence
sbutils.c:838:	ASSERT(GOODREGS(sii->curmap));
sbutils.c:839:	sb = REGS2SB(sii->curmap);
sbutils.c:851:	W_SBREG(sii, &sb->sbtmstatelow,
sbutils.c:854:	dummy = R_SBREG(sii, &sb->sbtmstatelow);
sbutils.c:858:	if (R_SBREG(sii, &sb->sbtmstatehigh) & SBTMH_SERR) {
sbutils.c:859:		W_SBREG(sii, &sb->sbtmstatehigh, 0);
sbutils.c:861:	if ((dummy = R_SBREG(sii, &sb->sbimstate)) & (SBIM_IBE | SBIM_TO)) {
sbutils.c:862:		AND_SBREG(sii, &sb->sbimstate, ~(SBIM_IBE | SBIM_TO));
sbutils.c:866:	W_SBREG(sii, &sb->sbtmstatelow,
sbutils.c:868:	dummy = R_SBREG(sii, &sb->sbtmstatelow);
sbutils.c:873:	W_SBREG(sii, &sb->sbtmstatelow, ((bits | SICF_CLOCK_EN) << SBTML_SICF_SHIFT));
sbutils.c:874:	dummy = R_SBREG(sii, &sb->sbtmstatelow);
sbutils.c:882: * of the chip and so it issues accesses to non-memory
sbutils.c:897: * Returns the timeout state before changing it or -1
sbutils.c:919:		switch (BUSTYPE(sii->pub.bustype)) {
sbutils.c:921:			idx = sii->pub.buscoreidx;
sbutils.c:945:	tmp = R_SBREG(sii, &sb->sbimconfiglow);
sbutils.c:947:	W_SBREG(sii, &sb->sbimconfiglow, (tmp & ~TO_MASK) | to);
siutils.c:2: * Misc utility routines for accessing chip-specific features
siutils.c:3: * of the SiliconBackplane-based Broadcom chips.
siutils.c:5: * Copyright (C) 1999-2012, Broadcom Corporation
siutils.c:25: * $Id: siutils.c 347632 2012-07-27 11:00:35Z $
siutils.c:68: * devid - pci device id (used to determine chip#)
siutils.c:69: * osh - opaque OS handle
siutils.c:70: * regs - virtual address of initial core registers
siutils.c:71: * bustype - pci/pcmcia/sb/sdio/etc
siutils.c:72: * vars - pointer to a pointer area for "environment" variables
siutils.c:73: * varsz - pointer to int to return the size of the vars
siutils.c:91:	sii->vars = vars ? *vars : NULL;
siutils.c:92:	sii->varsz = varsz ? *varsz : 0;
siutils.c:144:		sii->memseg = TRUE;
siutils.c:175:		/* Also, disable the extra SDIO pull-ups */
siutils.c:191:	cc = si_setcoreidx(&sii->pub, SI_CC_IDX);
siutils.c:195:	sii->pub.ccrev = (int)si_corerev(&sii->pub);
siutils.c:198:	if (sii->pub.ccrev >= 11)
siutils.c:199:		sii->pub.chipst = R_REG(sii->osh, &cc->chipstatus);
siutils.c:202:	sii->pub.cccaps = R_REG(sii->osh, &cc->capabilities);
siutils.c:205:	if (sii->pub.ccrev >= 35)
siutils.c:206:		sii->pub.cccaps_ext = R_REG(sii->osh, &cc->capabilities_ext);
siutils.c:209:	if (sii->pub.cccaps & CC_CAP_PMU) {
siutils.c:210:		sii->pub.pmucaps = R_REG(sii->osh, &cc->pmucapabilities);
siutils.c:211:		sii->pub.pmurev = sii->pub.pmucaps & PCAP_REV_MASK;
siutils.c:215:		sii->pub.ccrev, sii->pub.cccaps, sii->pub.chipst, sii->pub.pmurev,
siutils.c:216:		sii->pub.pmucaps));
siutils.c:219:	sii->pub.buscoretype = NODEV_CORE_ID;
siutils.c:220:	sii->pub.buscorerev = (uint)NOREV;
siutils.c:221:	sii->pub.buscoreidx = BADIDX;
siutils.c:227:	for (i = 0; i < sii->numcores; i++) {
siutils.c:230:		si_setcoreidx(&sii->pub, i);
siutils.c:231:		cid = si_coreid(&sii->pub);
siutils.c:232:		crev = si_corerev(&sii->pub);
siutils.c:236:		        i, cid, crev, sii->coresba[i], sii->regs[i]));
siutils.c:252:			sii->pub.buscorerev = crev;
siutils.c:253:			sii->pub.buscoretype = cid;
siutils.c:254:			sii->pub.buscoreidx = i;
siutils.c:260:			sii->pub.buscorerev = crev;
siutils.c:261:			sii->pub.buscoretype = cid;
siutils.c:262:			sii->pub.buscoreidx = i;
siutils.c:266:		if ((savewin && (savewin == sii->coresba[i])) ||
siutils.c:267:		    (regs == sii->regs[i]))
siutils.c:272:		sii->pub.buscoretype = PCI_CORE_ID;
siutils.c:273:		sii->pub.buscorerev = pcirev;
siutils.c:274:		sii->pub.buscoreidx = pciidx;
siutils.c:277:			sii->pub.buscoretype = PCIE2_CORE_ID;
siutils.c:279:			sii->pub.buscoretype = PCIE_CORE_ID;
siutils.c:280:		sii->pub.buscorerev = pcierev;
siutils.c:281:		sii->pub.buscoreidx = pcieidx;
siutils.c:284:	SI_VMSG(("Buscore id/type/rev %d/0x%x/%d\n", sii->pub.buscoreidx, sii->pub.buscoretype,
siutils.c:285:	         sii->pub.buscorerev));
siutils.c:287:	if (BUSTYPE(sii->pub.bustype) == SI_BUS && (CHIPID(sii->pub.chip) == BCM4712_CHIP_ID) &&
siutils.c:288:	    (sii->pub.chippkg != BCM4712LARGE_PKG_ID) && (CHIPREV(sii->pub.chiprev) <= 3))
siutils.c:289:		OR_REG(sii->osh, &cc->slow_clk_ctl, SCC_SS_XTAL);
siutils.c:292:	/* Make sure any on-chip ARM is off (in case strapping is wrong), or downloaded code was
siutils.c:296:		if (si_setcore(&sii->pub, ARM7S_CORE_ID, 0) ||
siutils.c:297:		    si_setcore(&sii->pub, ARMCM3_CORE_ID, 0))
siutils.c:298:			si_core_disable(&sii->pub, 0);
siutils.c:302:	si_setcoreidx(&sii->pub, *origidx);
siutils.c:314:	struct si_pub *sih = &sii->pub;
siutils.c:326:	sih->buscoreidx = BADIDX;
siutils.c:328:	sii->curmap = regs;
siutils.c:329:	sii->sdh = sdh;
siutils.c:330:	sii->osh = osh;
siutils.c:336:		savewin = OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(uint32));
siutils.c:339:		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, SI_ENUM_BASE);
siutils.c:344:		cc = (chipcregs_t *)sii->curmap;
siutils.c:349:	sih->bustype = bustype;
siutils.c:371:	w = R_REG(osh, &cc->chipid);
siutils.c:372:	sih->socitype = (w & CID_TYPE_MASK) >> CID_TYPE_SHIFT;
siutils.c:374:	sih->chip = w & CID_ID_MASK;
siutils.c:375:	sih->chiprev = (w & CID_REV_MASK) >> CID_REV_SHIFT;
siutils.c:376:	sih->chippkg = (w & CID_PKG_MASK) >> CID_PKG_SHIFT;
siutils.c:379:	if (CHIPID(sih->chip) == BCM43362_CHIP_ID) {
siutils.c:391:	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID) && (sih->chiprev == 0) &&
siutils.c:392:		(sih->chippkg != BCM4329_289PIN_PKG_ID)) {
siutils.c:393:		sih->chippkg = BCM4329_182PIN_PKG_ID;
siutils.c:395:	sih->issim = IS_SIM(sih->chippkg);
siutils.c:398:	if (CHIPTYPE(sii->pub.socitype) == SOCI_SB) {
siutils.c:400:		sb_scan(&sii->pub, regs, devid);
siutils.c:401:	} else if (CHIPTYPE(sii->pub.socitype) == SOCI_AI) {
siutils.c:404:		ai_scan(&sii->pub, (void *)(uintptr)cc, devid);
siutils.c:405:	} else if (CHIPTYPE(sii->pub.socitype) == SOCI_UBUS) {
siutils.c:406:		SI_MSG(("Found chip type UBUS (0x%08x), chip id = 0x%4x\n", w, sih->chip));
siutils.c:408:		ub_scan(&sii->pub, (void *)(uintptr)cc, devid);
siutils.c:414:	if (sii->numcores == 0) {
siutils.c:425:	if (CHIPID(sih->chip) == BCM4322_CHIP_ID && (((sih->chipst & CST4322_SPROM_OTP_SEL_MASK)
siutils.c:433:	if ((sii->pub.ccrev == 0x25) && ((CHIPID(sih->chip) == BCM43236_CHIP_ID ||
siutils.c:434:	                                  CHIPID(sih->chip) == BCM43235_CHIP_ID ||
siutils.c:435:	                                  CHIPID(sih->chip) == BCM43234_CHIP_ID ||
siutils.c:436:	                                  CHIPID(sih->chip) == BCM43238_CHIP_ID) &&
siutils.c:437:	                                 (CHIPREV(sii->pub.chiprev) <= 2))) {
siutils.c:439:		if ((cc->chipstatus & CST43236_BP_CLK) != 0) {
siutils.c:441:			clkdiv = R_REG(osh, &cc->clkdiv);
siutils.c:444:			W_REG(osh, &cc->clkdiv, clkdiv);
siutils.c:459:		if (sii->pub.ccrev >= 20) {
siutils.c:465:			if ((CHIPID(sih->chip) == BCM4314_CHIP_ID) ||
siutils.c:466:				(CHIPID(sih->chip) == BCM43142_CHIP_ID)) {
siutils.c:471:			W_REG(osh, &cc->gpiopullup, gpiopullup);
siutils.c:472:			W_REG(osh, &cc->gpiopulldown, gpiopulldown);
siutils.c:477:	/* clear any previous epidiag-induced target abort */
siutils.c:500:	if (BUSTYPE(sih->bustype) == SI_BUS)
siutils.c:502:			if (sii->regs[idx]) {
siutils.c:503:				REG_UNMAP(sii->regs[idx]);
siutils.c:504:				sii->regs[idx] = NULL;
siutils.c:512:		MFREE(sii->osh, sii, sizeof(si_info_t));
siutils.c:521:	return sii->osh;
siutils.c:530:	if (sii->osh != NULL) {
siutils.c:532:		ASSERT(!sii->osh);
siutils.c:534:	sii->osh = osh;
siutils.c:545:	sii->intr_arg = intr_arg;
siutils.c:546:	sii->intrsoff_fn = (si_intrsoff_t)intrsoff_fn;
siutils.c:547:	sii->intrsrestore_fn = (si_intrsrestore_t)intrsrestore_fn;
siutils.c:548:	sii->intrsenabled_fn = (si_intrsenabled_t)intrsenabled_fn;
siutils.c:552:	sii->dev_coreid = sii->coreid[sii->curidx];
siutils.c:561:	sii->intrsoff_fn = NULL;
siutils.c:569:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:571:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:572:		return R_REG(sii->osh, ((uint32 *)(uintptr)
siutils.c:573:			    (sii->oob_router + OOB_STATUSA)));
siutils.c:583:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:585:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:587:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:598:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:600:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:602:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:614:	return sii->coreid[sii->curidx];
siutils.c:623:	return sii->curidx;
siutils.c:626:/* return the core-type instantiation # of the current core */
siutils.c:639:	idx = sii->curidx;
siutils.c:641:	ASSERT(GOODREGS(sii->curmap));
siutils.c:646:		if (sii->coreid[i] == coreid)
siutils.c:655:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:657:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:659:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:670:	return ((sih->cccaps & CC_CAP_BKPLN64) != 0);
siutils.c:676:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:678:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:680:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:700:	for (i = 0; i < sii->numcores; i++)
siutils.c:701:		if (sii->coreid[i] == coreid) {
siutils.c:718:	bcopy((uchar*)sii->coreid, (uchar*)coreid, (sii->numcores * sizeof(uint)));
siutils.c:719:	return (sii->numcores);
siutils.c:729:	ASSERT(GOODREGS(sii->curmap));
siutils.c:731:	return (sii->curmap);
siutils.c:748:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:750:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:752:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:763:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:765:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:767:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:792:		else if (coreid == sih->buscoretype)
siutils.c:796:	*origidx = sii->curidx;
siutils.c:810:	if (SI_FAST(sii) && ((coreid == CC_CORE_ID) || (coreid == sih->buscoretype)))
siutils.c:820:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:822:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:824:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:835:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:837:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:839:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:850:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:852:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:854:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:866:	if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:875:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:877:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:879:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:890:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:892:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:894:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:903:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:905:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:907:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:918:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:920:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:922:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:934:	if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:942:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:944:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:946:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:957:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:959:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:961:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:968:	if (CHIPTYPE(sih->socitype) == SOCI_SB)
siutils.c:970:	else if (CHIPTYPE(sih->socitype) == SOCI_AI)
siutils.c:972:	else if (CHIPTYPE(sih->socitype) == SOCI_UBUS)
siutils.c:976:/* Run bist on current core. Caller needs to take care of core-specific bist hazards */
siutils.c:1108:		if ((CHIPID(sih->chip) == BCM4319_CHIP_ID) &&
siutils.c:1109:		    (CHIPREV(sih->chiprev) == 0) && (ticks != 0)) {
siutils.c:1116:			nb = (sih->ccrev < 26) ? 16 : ((sih->ccrev >= 37) ? 32 : 24);
siutils.c:1118:		 * so we specially handle the 32-bit case.
siutils.c:1123:			maxt = ((1 << nb) - 1);
siutils.c:1132:		maxt = (1 << 28) - 1;
siutils.c:1160:/* return the slow clock source - LPO, XTAL, or PCI */
siutils.c:1166:	ASSERT(SI_FAST(sii) || si_coreid(&sii->pub) == CC_CORE_ID);
siutils.c:1168:	if (sii->pub.ccrev < 6) {
siutils.c:1169:		if ((BUSTYPE(sii->pub.bustype) == PCI_BUS) &&
siutils.c:1170:		    (OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(uint32)) &
siutils.c:1175:	} else if (sii->pub.ccrev < 10) {
siutils.c:1176:		cc = (chipcregs_t *)si_setcoreidx(&sii->pub, sii->curidx);
siutils.c:1177:		return (R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_SS_MASK);
siutils.c:1178:	} else	/* Insta-clock */
siutils.c:1189:	ASSERT(SI_FAST(sii) || si_coreid(&sii->pub) == CC_CORE_ID);
siutils.c:1192:	ASSERT(R_REG(sii->osh, &cc->capabilities) & CC_CAP_PWR_CTL);
siutils.c:1195:	if (sii->pub.ccrev < 6) {
siutils.c:1200:	} else if (sii->pub.ccrev < 10) {
siutils.c:1202:		        (((R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHIFT) + 1);
siutils.c:1213:		div = R_REG(sii->osh, &cc->system_clk_ctl) >> SYCC_CD_SHIFT;
siutils.c:1238:	slowmaxfreq = si_slowclk_freq(sii, (sii->pub.ccrev >= 10) ? FALSE : TRUE, cc);
siutils.c:1243:	W_REG(sii->osh, &cc->pll_on_delay, pll_on_delay);
siutils.c:1244:	W_REG(sii->osh, &cc->fref_sel_delay, fref_sel_delay);
siutils.c:1262:		origidx = sii->curidx;
siutils.c:1270:	if (sih->ccrev >= 10)
siutils.c:1271:		SET_REG(sii->osh, &cc->system_clk_ctl, SYCC_CD_MASK,
siutils.c:1292: *   to some chip-specific purpose.
siutils.c:1305:	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
siutils.c:1327:	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
siutils.c:1349:	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
siutils.c:1366:	if ((BUSTYPE(sih->bustype) != SI_BUS) || (!priority)) {
siutils.c:1367:		ASSERT((BUSTYPE(sih->bustype) == SI_BUS) && (priority));
siutils.c:1371:	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
siutils.c:1372:		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
siutils.c:1397:	if ((BUSTYPE(sih->bustype) != SI_BUS) || (!priority)) {
siutils.c:1398:		ASSERT((BUSTYPE(sih->bustype) == SI_BUS) && (priority));
siutils.c:1402:	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
siutils.c:1403:		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
siutils.c:1434:	if ((BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
siutils.c:1451:	if ((BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
siutils.c:1465:	if (sih->ccrev < 16)
siutils.c:1476:	if (sih->ccrev < 16)
siutils.c:1488:	if (sih->ccrev < 20)
siutils.c:1500:	if (sih->ccrev < 11)
siutils.c:1526:	if (sih->ccrev < 11)
siutils.c:1529:	if ((gi = MALLOC(sii->osh, sizeof(gpioh_item_t))) == NULL)
siutils.c:1533:	gi->event = event;
siutils.c:1534:	gi->handler = cb;
siutils.c:1535:	gi->arg = arg;
siutils.c:1536:	gi->level = level;
siutils.c:1538:	gi->next = sii->gpioh_head;
siutils.c:1539:	sii->gpioh_head = gi;
siutils.c:1551:	if (sih->ccrev < 11)
siutils.c:1554:	ASSERT(sii->gpioh_head != NULL);
siutils.c:1555:	if ((void*)sii->gpioh_head == gpioh) {
siutils.c:1556:		sii->gpioh_head = sii->gpioh_head->next;
siutils.c:1557:		MFREE(sii->osh, gpioh, sizeof(gpioh_item_t));
siutils.c:1560:		p = sii->gpioh_head;
siutils.c:1561:		n = p->next;
siutils.c:1564:				p->next = n->next;
siutils.c:1565:				MFREE(sii->osh, gpioh, sizeof(gpioh_item_t));
siutils.c:1569:			n = n->next;
siutils.c:1587:	for (h = sii->gpioh_head; h != NULL; h = h->next) {
siutils.c:1588:		if (h->handler) {
siutils.c:1589:			uint32 status = (h->level ? level : edge) & h->event;
siutils.c:1590:			uint32 polarity = (h->level ? levelp : edgep) & h->event;
siutils.c:1594:				h->handler(status, h->arg);
siutils.c:1598:	si_gpioevent(sih, GPIO_REGEVT, edge, edge); /* clear edge-trigger status */
siutils.c:1606:	if (sih->ccrev < 11)
siutils.c:1623:	W_REG(sii->osh, &regs->bankidx, bankidx);
siutils.c:1624:	bankinfo = R_REG(sii->osh, &regs->bankinfo);
siutils.c:1663:		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
siutils.c:1667:			W_REG(sii->osh, &regs->bankidx, bankidx);
siutils.c:1668:			bankinfo = R_REG(sii->osh, &regs->bankinfo);
siutils.c:1681:				W_REG(sii->osh, &regs->bankinfo, bankinfo);
siutils.c:1734:		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
siutils.c:1738:			W_REG(sii->osh, &regs->bankidx, bankidx);
siutils.c:1739:			bankinfo = R_REG(sii->osh, &regs->bankinfo);
siutils.c:1797:		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
siutils.c:1845:		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
siutils.c:1857:			W_REG(sii->osh, &regs->bankidx, bankidx);
siutils.c:1858:			bankinfo = R_REG(sii->osh, &regs->bankinfo);
siutils.c:1908:	coreinfo = R_REG(sii->osh, &regs->coreinfo);
siutils.c:1921:			nb --;
siutils.c:1924:			memsize += (1 << ((lss - 1) + SR_BSZ_BASE));
siutils.c:1944:/* Return the TCM-RAM size of the ARMCR4 core. */
siutils.c:1981:	corecap = R_REG(sii->osh, arm_cap_reg);
siutils.c:1990:		W_REG(sii->osh, arm_bidx, idx);
siutils.c:1992:		bxinfo = R_REG(sii->osh, arm_binfo);
siutils.c:2020:	if ((CHIPID(sih->chip) == BCM4334_CHIP_ID) && (CHIPREV(sih->chiprev) < 2)) {
siutils.c:2038:	coreinfo = R_REG(sii->osh, &regs->coreinfo);
siutils.c:2045:			W_REG(sii->osh, &regs->bankidx, i);
siutils.c:2046:			if (R_REG(sii->osh, &regs->bankinfo) & SOCRAM_BANKINFO_RETNTRAM_MASK)
siutils.c:2076:	if (!(sih->cccaps & CC_CAP_UARTGPIO))
siutils.c:2079:	/* si_corereg cannot be used as we have to guarantee 8-bit read/writes */
siutils.c:2087:	W_REG(sii->osh, &cc->uart0mcr, R_REG(sii->osh, &cc->uart0mcr) | 0x04);
siutils.c:2112:	val = R_REG(sii->osh, &cc->chipcontrol);
siutils.c:2118:		W_REG(sii->osh, &cc->chipcontrol, val);
siutils.c:2121:		W_REG(sii->osh, &cc->chipcontrol, val);
siutils.c:2140:	W_REG(sii->osh, &cc->chipcontrol, val);
siutils.c:2155:	val = R_REG(sii->osh, &cc->chipcontrol);
siutils.c:2173:	val = R_REG(sii->osh, &cc->chipcontrol);
siutils.c:2176:		if (sih->chippkg == 9 || sih->chippkg == 0xb) {
siutils.c:2179:			W_REG(sii->osh, &cc->chipcontrol, val);
siutils.c:2182:			if (sih->chiprev > 0) {
siutils.c:2183:				W_REG(sii->osh, &cc->chipcontrol, val |
siutils.c:2186:				W_REG(sii->osh, &cc->chipcontrol, val | (CCTRL4331_EXTPA_EN));
siutils.c:2191:		W_REG(sii->osh, &cc->chipcontrol, val);
siutils.c:2211:	val = R_REG(sii->osh, &cc->chipcontrol);
siutils.c:2220:		W_REG(sii->osh, &cc->chipcontrol, val);
siutils.c:2236:	sel_chip = (CHIPID(sih->chip) == BCM4331_CHIP_ID) ||
siutils.c:2237:		(CHIPID(sih->chip) == BCM43431_CHIP_ID);
siutils.c:2238:	sel_chip &= ((sih->chippkg == 9 || sih->chippkg == 0xb));
siutils.c:2248:	val = R_REG(sii->osh, &cc->chipcontrol);
siutils.c:2252:		W_REG(sii->osh, &cc->chipcontrol, val);
siutils.c:2255:		W_REG(sii->osh, &cc->chipcontrol, val);
siutils.c:2268:/* Enable BT-COEX & Ex-PA for 4313 */
siutils.c:2282:	W_REG(sii->osh, &cc->gpiocontrol,
siutils.c:2283:		R_REG(sii->osh, &cc->gpiocontrol) | GPIO_CTRL_EPA_EN_MASK);
siutils.c:2305:	W_REG(sii->osh, &cc->gpiocontrol,
siutils.c:2306:		R_REG(sii->osh, &cc->gpiocontrol) | GPIO_CTRL_5_6_EN_MASK);
siutils.c:2308:	W_REG(sii->osh, &cc->gpioouten,
siutils.c:2309:		R_REG(sii->osh, &cc->gpioouten) | GPIO_CTRL_5_6_EN_MASK);
siutils.c:2326:	W_REG(sii->osh, &cc->chipcontrol,
siutils.c:2327:		R_REG(sii->osh, &cc->chipcontrol) | CC_BTCOEX_EN_MASK);
siutils.c:2343:	W_REG(sii->osh, &cc->gpioouten, GPIO_CTRL_7_6_EN_MASK);
siutils.c:2344:	W_REG(sii->osh, &cc->gpioout, GPIO_OUT_7_EN_MASK);
siutils.c:2358:	switch (BUSTYPE(sih->bustype)) {
siutils.c:2360:		ASSERT(sii->osh != NULL);
siutils.c:2361:		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_VID, sizeof(uint32));
siutils.c:2372:	if (sih->ccrev >= 31) {
siutils.c:2378:		if ((sih->cccaps & CC_CAP_SROM) == 0)
siutils.c:2382:		origidx = sii->curidx;
siutils.c:2384:		sromctrl = R_REG(sii->osh, &cc->sromcontrol);
siutils.c:2389:	switch (CHIPID(sih->chip)) {
siutils.c:2391:		return ((sih->chipst & CST4312_SPROM_OTP_SEL_MASK) != CST4312_OTP_SEL);
siutils.c:2393:		return (sih->chipst & CST4325_SPROM_SEL) != 0;
siutils.c:2398:		spromotp = (sih->chipst & CST4322_SPROM_OTP_SEL_MASK) >>
siutils.c:2403:		return (sih->chipst & CST4329_SPROM_SEL) != 0;
siutils.c:2405:		return (sih->chipst & CST4315_SPROM_SEL) != 0;
siutils.c:2407:		return (sih->chipst & CST4319_SPROM_SEL) != 0;
siutils.c:2410:		return (sih->chipst & CST4336_SPROM_PRESENT) != 0;
siutils.c:2412:		return (sih->chipst & CST4330_SPROM_PRESENT) != 0;
siutils.c:2414:		return (sih->chipst & CST4313_SPROM_PRESENT) != 0;
siutils.c:2417:		return (sih->chipst & CST4331_SPROM_PRESENT) != 0;
siutils.c:2419:		return ((sih->chipst & CST43239_SPROM_MASK) &&
siutils.c:2420:			!(sih->chipst & CST43239_SFLASH_MASK));
siutils.c:2422:		return ((sih->chipst & CST4324_SPROM_MASK) &&
siutils.c:2423:			!(sih->chipst & CST4324_SFLASH_MASK));
siutils.c:2425:		return ((sih->chipst & CST4335_SPROM_MASK) &&
siutils.c:2426:			!(sih->chipst & CST4335_SFLASH_MASK));
siutils.c:2432:		return (sih->chipst & CST43228_OTP_PRESENT) != CST43228_OTP_PRESENT;
siutils.c:2451:	sromctl = R_REG(osh, &cc->sromcontrol);
siutils.c:2473:	W_REG(osh, &cc->sromcontrol, value);
siutils_priv.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
siutils_priv.h:24: * $Id: siutils_priv.h 309193 2012-01-19 00:03:57Z $
siutils_priv.h:104:#define	NOREV		-1		/* Invalid rev */
siutils_priv.h:106:#define PCI(si)		((BUSTYPE((si)->pub.bustype) == PCI_BUS) &&	\
siutils_priv.h:107:			 ((si)->pub.buscoretype == PCI_CORE_ID))
siutils_priv.h:109:#define PCIE_GEN1(si)	((BUSTYPE((si)->pub.bustype) == PCI_BUS) &&	\
siutils_priv.h:110:			 ((si)->pub.buscoretype == PCIE_CORE_ID))
siutils_priv.h:112:#define PCIE_GEN2(si)	((BUSTYPE((si)->pub.bustype) == PCI_BUS) &&	\
siutils_priv.h:113:			 ((si)->pub.buscoretype == PCIE2_CORE_ID))
siutils_priv.h:117:#define PCMCIA(si)	((BUSTYPE((si)->pub.bustype) == PCMCIA_BUS) && ((si)->memseg == TRUE))
siutils_priv.h:122:#define SI_FAST(si) (PCIE(si) || (PCI(si) && ((si)->pub.buscorerev >= 13)))
siutils_priv.h:124:#define PCIEREGS(si) (((char *)((si)->curmap) + PCI_16KB0_PCIREGS_OFFSET))
siutils_priv.h:125:#define CCREGS_FAST(si) (((char *)((si)->curmap) + PCI_16KB0_CCREGS_OFFSET))
siutils_priv.h:132:	if ((si)->intrsoff_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
siutils_priv.h:133:		intr_val = (*(si)->intrsoff_fn)((si)->intr_arg); }
siutils_priv.h:135:	if ((si)->intrsrestore_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
siutils_priv.h:136:		(*(si)->intrsrestore_fn)((si)->intr_arg, intr_val); }
siutils_priv.h:141:#define	XTALMINFREQ		19800000	/* 20 MHz - 1% */
siutils_priv.h:150:	(((PCIE_GEN1(si)) && (si->pub.chip == BCM4311_CHIP_ID) && ((si->pub.chiprev <= 1))) || \
siutils_priv.h:151:	((PCI(si) || PCIE_GEN1(si)) && (si->pub.chip == BCM4321_CHIP_ID)) || \
siutils_priv.h:152:	(PCIE_GEN1(si) && (si->pub.chip == BCM4716_CHIP_ID)) || \
siutils_priv.h:153:	(PCIE_GEN1(si) && (si->pub.chip == BCM4748_CHIP_ID)))
siutils_priv.h:191:/* Wake-on-wireless-LAN (WOWL) */
uamp_api.h:6: * Copyright (C) 1999-2012, Broadcom Corporation
uamp_api.h:26: * $Id: uamp_api.h 294267 2011-11-04 23:41:52Z $
uamp_api.h:67:/* tUAMP_EVT_DATA: union for event-specific data, used by UAMP_CBACK */
uamp_api.h:81:**              p_amp_evt_data: pointer to event-specific data
wl_android.c:2: * Linux cfg80211 driver - Android related functions
wl_android.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
wl_android.c:24: * $Id: wl_android.c 372668 2012-12-04 14:07:12Z $
wl_android.c:70:			printk(KERN_ERR "ANDROID-ERROR) ");	\
wl_android.c:77:			printk(KERN_ERR "ANDROID-TRACE) ");	\
wl_android.c:84:			printk(KERN_ERR "ANDROID-INFO) ");	\
wl_android.c:96:#define	CMD_SCAN_ACTIVE		"SCAN-ACTIVE"
wl_android.c:97:#define	CMD_SCAN_PASSIVE	"SCAN-PASSIVE"
wl_android.c:100:#define CMD_RXFILTER_START	"RXFILTER-START"
wl_android.c:101:#define CMD_RXFILTER_STOP	"RXFILTER-STOP"
wl_android.c:102:#define CMD_RXFILTER_ADD	"RXFILTER-ADD"
wl_android.c:103:#define CMD_RXFILTER_REMOVE	"RXFILTER-REMOVE"
wl_android.c:104:#define CMD_BTCOEXSCAN_START	"BTCOEXSCAN-START"
wl_android.c:105:#define CMD_BTCOEXSCAN_STOP	"BTCOEXSCAN-STOP"
wl_android.c:212:		return -1;
wl_android.c:230:		return -1;
wl_android.c:237:		return -1;
wl_android.c:255:	suspend_flag = *(command + strlen(CMD_SETSUSPENDOPT) + 1) - '0';
wl_android.c:263:			ANDROID_INFO(("%s: Suspend Flag %d -> %d\n",
wl_android.c:278:	suspend_flag = *(command + strlen(CMD_SETSUSPENDMODE) + 1) - '0';
wl_android.c:299:		return -1;
wl_android.c:308:	int res = -1;
wl_android.c:355:	tlv_size_left = total_len - strlen(CMD_PNOSETUP_SET);
wl_android.c:360:	if ((cmd_tlv_temp->prefix == PNO_TLV_PREFIX) &&
wl_android.c:361:		(cmd_tlv_temp->version == PNO_TLV_VERSION) &&
wl_android.c:362:		(cmd_tlv_temp->subver == PNO_TLV_SUBVERSION)) {
wl_android.c:365:		tlv_size_left -= sizeof(cmd_tlv_t);
wl_android.c:437:		return -EINVAL;
wl_android.c:450:		} while (retry-- >= 0);
wl_android.c:459:				ret = -EFAULT;
wl_android.c:480:		return -EINVAL;
wl_android.c:500:	if ((strlen(command) - strlen(CMD_SETFWPATH)) > MOD_PARAM_PATHLEN)
wl_android.c:501:		return -1;
wl_android.c:503:		command + strlen(CMD_SETFWPATH) + 1, MOD_PARAM_PATHLEN - 1);
wl_android.c:546:	okc_enable = command[strlen(CMD_OKC_ENABLE) + 1] - '0';
wl_android.c:563:		return -1;
wl_android.c:570:		return -1;
wl_android.c:588:	if (!ifr->ifr_data) {
wl_android.c:589:		ret = -EINVAL;
wl_android.c:592:	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
wl_android.c:593:		ret = -EFAULT;
wl_android.c:599:		ret = -EINVAL;
wl_android.c:605:		ret = -ENOMEM;
wl_android.c:609:		ret = -EFAULT;
wl_android.c:613:	ANDROID_INFO(("%s: Android private cmd \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name));
wl_android.c:624:		ANDROID_ERROR(("%s: Ignore private cmd \"%s\" - iface %s is down\n",
wl_android.c:625:			__FUNCTION__, command, ifr->ifr_name));
wl_android.c:634:		/* TBD: SCAN-ACTIVE */
wl_android.c:637:		/* TBD: SCAN-PASSIVE */
wl_android.c:653:		int filter_num = *(command + strlen(CMD_RXFILTER_ADD) + 1) - '0';
wl_android.c:657:		int filter_num = *(command + strlen(CMD_RXFILTER_REMOVE) + 1) - '0';
wl_android.c:662:		/* TBD: BTCOEXSCAN-START */
wl_android.c:665:		/* TBD: BTCOEXSCAN-STOP */
wl_android.c:672:		uint mode = *(command + strlen(CMD_BTCOEXMODE) + 1) - '0';
wl_android.c:688:		uint band = *(command + strlen(CMD_SETBAND) + 1) - '0';
wl_android.c:691:			bytes_written = -1;
wl_android.c:718:		uint pfn_enabled = *(command + strlen(CMD_PNOENABLE_SET) + 1) - '0';
wl_android.c:728:			priv_cmd.total_len - skip);
wl_android.c:738:			priv_cmd.total_len - skip);
wl_android.c:745:			priv_cmd.total_len - skip, *(command + skip - 2) - '0');
wl_android.c:755:		ANDROID_ERROR(("Unknown PRIVATE command %s - ignored\n", command));
wl_android.c:772:			ret = -EFAULT;
wl_android.c:826:	rssi_head = &rssi_cache_ctrl->m_cache_head;
wl_android.c:831:			__FUNCTION__, i, &node->BSSID));
wl_android.c:833:		node = cur->next;
wl_android.c:844:	int i = -1, tmp = 0;
wl_android.c:851:	rssi_head = &rssi_cache_ctrl->m_cache_head;
wl_android.c:856:		if (node->dirty >= max || node->dirty >= RSSICACHE_LEN) {
wl_android.c:859:				*rssi_head = node->next;
wl_android.c:862:				prev->next = node->next;
wl_android.c:865:				__FUNCTION__, i, &node->BSSID));
wl_android.c:871:				node = prev->next;
wl_android.c:876:		node = node->next;
wl_android.c:885:	rssi_head = &rssi_cache_ctrl->m_cache_head;
wl_android.c:890:		node->dirty += 1;
wl_android.c:891:		node = node->next;
wl_android.c:911:	rssi_head = &rssi_cache_ctrl->m_cache_head;
wl_android.c:914:		if (!memcmp(&node->BSSID, &bssid, ETHER_ADDR_LEN)) {
wl_android.c:917:			for(j=0; j<RSSIAVG_LEN-1; j++)
wl_android.c:918:				node->RSSI[j] = node->RSSI[j+1];
wl_android.c:919:			node->RSSI[j] = rssi;
wl_android.c:920:			node->dirty = 0;
wl_android.c:924:		node = node->next;
wl_android.c:936:	if (!ss_list->count)
wl_android.c:939:	rssi_head = &rssi_cache_ctrl->m_cache_head;
wl_android.c:942:	for (i = 0; i < ss_list->count; i++) {
wl_android.c:946:		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : ss_list->bss_info;
wl_android.c:948:			if (!memcmp(&node->BSSID, &bi->BSSID, ETHER_ADDR_LEN)) {
wl_android.c:950:					__FUNCTION__, k, &bi->BSSID, dtoh16(bi->RSSI), bi->SSID));
wl_android.c:951:				for(j=0; j<RSSIAVG_LEN-1; j++)
wl_android.c:952:					node->RSSI[j] = node->RSSI[j+1];
wl_android.c:953:				node->RSSI[j] = dtoh16(bi->RSSI);
wl_android.c:954:				node->dirty = 0;
wl_android.c:958:			node = node->next;
wl_android.c:972:				__FUNCTION__, k, &bi->BSSID, dtoh16(bi->RSSI), bi->SSID));
wl_android.c:974:		leaf->next = NULL;
wl_android.c:975:		leaf->dirty = 0;
wl_android.c:976:		memcpy(&leaf->BSSID, &bi->BSSID, ETHER_ADDR_LEN);
wl_android.c:978:			leaf->RSSI[j] = dtoh16(bi->RSSI);
wl_android.c:983:			prev->next = leaf;
wl_android.c:991:	int j, rssi_sum, rssi=-200;
wl_android.c:993:	rssi_head = &rssi_cache_ctrl->m_cache_head;
wl_android.c:998:		if (!memcmp(&node->BSSID, addr, ETHER_ADDR_LEN)) {
wl_android.c:1002:				rssi_sum += node->RSSI[RSSIAVG_LEN-j-1];
wl_android.c:1006:		node = node->next;
wl_android.c:1008:	if (rssi >= -2)
wl_android.c:1009:		rssi = -2;
wl_android.c:1010:	if (rssi == -200) {
wl_android.c:1029:			if (rssi - (RSSI_MIN+RSSI_INT*(j+1)) < 0)
wl_android.c:1037:	if (rssi >= -2)
wl_android.c:1038:		rssi = -2;
wl_android.c:1054:	bss_head = &bss_cache_ctrl->m_cache_head;
wl_android.c:1059:			__FUNCTION__, i, &node->results.bss_info->BSSID));
wl_android.c:1061:		node = cur->next;
wl_android.c:1072:	int i = -1, tmp = 0;
wl_android.c:1074:	bss_head = &bss_cache_ctrl->m_cache_head;
wl_android.c:1079:		if (node->dirty >= BSSCACHE_LEN) {
wl_android.c:1082:				*bss_head = node->next;
wl_android.c:1085:				prev->next = node->next;
wl_android.c:1088:				__FUNCTION__, i, &node->results.bss_info->BSSID,
wl_android.c:1089:				dtoh16(node->results.bss_info->RSSI), node->results.bss_info->SSID));
wl_android.c:1095:				node = prev->next;
wl_android.c:1100:		node = node->next;
wl_android.c:1109:	bss_head = &bss_cache_ctrl->m_cache_head;
wl_android.c:1114:		node->dirty += 1;
wl_android.c:1115:		node = node->next;
wl_android.c:1126:	if (!ss_list->count)
wl_android.c:1129:	bss_head = &bss_cache_ctrl->m_cache_head;
wl_android.c:1131:	for (i=0; i < ss_list->count; i++) {
wl_android.c:1134:		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : ss_list->bss_info;
wl_android.c:1137:			if (!memcmp(&node->results.bss_info->BSSID, &bi->BSSID, ETHER_ADDR_LEN)) {
wl_android.c:1139:				leaf = kmalloc(dtoh32(bi->length) + WLC_IW_SS_CACHE_CTRL_FIELD_MAXLEN, GFP_KERNEL);
wl_android.c:1142:						__FUNCTION__, dtoh32(bi->length) + WLC_IW_SS_CACHE_CTRL_FIELD_MAXLEN));
wl_android.c:1146:				memcpy(leaf->results.bss_info, bi, dtoh32(bi->length));
wl_android.c:1147:				leaf->next = node->next;
wl_android.c:1148:				leaf->dirty = 0;
wl_android.c:1149:				leaf->results.count = 1;
wl_android.c:1150:				leaf->results.version = ss_list->version;
wl_android.c:1152:					__FUNCTION__, k, &bi->BSSID, dtoh16(bi->RSSI), bi->SSID));
wl_android.c:1156:					prev->next = leaf;
wl_android.c:1165:			node = node->next;
wl_android.c:1171:		leaf = kmalloc(dtoh32(bi->length) + WLC_IW_SS_CACHE_CTRL_FIELD_MAXLEN, GFP_KERNEL);
wl_android.c:1174:				dtoh32(bi->length) + WLC_IW_SS_CACHE_CTRL_FIELD_MAXLEN));
wl_android.c:1178:				__FUNCTION__, k, &bi->BSSID, dtoh16(bi->RSSI), bi->SSID));
wl_android.c:1180:		memcpy(leaf->results.bss_info, bi, dtoh32(bi->length));
wl_android.c:1181:		leaf->next = NULL;
wl_android.c:1182:		leaf->dirty = 0;
wl_android.c:1183:		leaf->results.count = 1;
wl_android.c:1184:		leaf->results.version = ss_list->version;
wl_android.c:1190:			prev->next = leaf;
wl_android.c:1199:	timer = &bss_cache_ctrl->m_timer;
wl_android.c:1203:			(*timer)->expires = jiffies + BSSCACHE_TIME * HZ / 1000;
wl_android.c:1218:	bss_cache_ctrl->m_timer_expired = 1;
wl_android.c:1228:	if (bss_cache_ctrl->m_timer) {
wl_android.c:1229:		kfree(bss_cache_ctrl->m_timer);
wl_android.c:1237:	bss_cache_ctrl->m_timer_expired = 0;
wl_android.c:1239:	bss_cache_ctrl->m_timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
wl_android.c:1240:	if (!bss_cache_ctrl->m_timer) {
wl_android.c:1244:	init_timer(bss_cache_ctrl->m_timer);
wl_android.c:1245:	bss_cache_ctrl->m_timer->function = (void *)wl_set_bss_cache_timer_flag;
wl_android.c:1246:	bss_cache_ctrl->m_timer->data = (ulong)bss_cache_ctrl;
wl_android.c:1277:		ret = -EINVAL;
wl_android.c:1296:	if (wifi_control_data && wifi_control_data->mem_prealloc) {
wl_android.c:1297:		alloc_ptr = wifi_control_data->mem_prealloc(section, size);
wl_android.c:1313:		*irq_flags_ptr = wifi_irqres->flags & IRQF_TRIGGER_MASK;
wl_android.c:1314:		return (int)wifi_irqres->start;
wl_android.c:1319:	return -1;
wl_android.c:1326:	if (wifi_control_data && wifi_control_data->set_power) {
wl_android.c:1327:		wifi_control_data->set_power(on);
wl_android.c:1339:		return -EINVAL;
wl_android.c:1340:	if (wifi_control_data && wifi_control_data->get_mac_addr) {
wl_android.c:1341:		return wifi_control_data->get_mac_addr(buf);
wl_android.c:1343:	return -EOPNOTSUPP;
wl_android.c:1353:	if (wifi_control_data && wifi_control_data->get_country_code) {
wl_android.c:1354:		return wifi_control_data->get_country_code(ccode);
wl_android.c:1363:	if (wifi_control_data && wifi_control_data->set_carddetect) {
wl_android.c:1364:		wifi_control_data->set_carddetect(on);
wl_android.c:1372:		(struct wifi_platform_data *)(pdev->dev.platform_data);
wl_android.c:1380:	wifi_set_carddetect(1);	/* CardDetect (0->1) */
wl_android.c:1389:		(struct wifi_platform_data *)(pdev->dev.platform_data);
wl_android.c:1395:	wifi_set_carddetect(0);	/* CardDetect (1->0) */
wl_android.c:1406:		return -EBUSY;
wl_android.h:2: * Linux cfg80211 driver - Android related functions
wl_android.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
wl_android.h:24: * $Id: wl_android.h 367273 2012-11-07 09:58:55Z $
wl_android.h:82:#define RSSI_MAX -80
wl_android.h:83:#define RSSI_MIN -94
wl_android.h:84:#define RSSI_INT ((RSSI_MAX-RSSI_MIN)/RSSI_OFFSET)
wl_cfg80211.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
wl_cfg80211.c:24: * $Id: wl_cfg80211.c 374275 2012-12-12 11:44:18Z $
wl_cfg80211.c:128:		REG_RULE(2412-10, 2472+10, 40, 6, 20, 0),
wl_cfg80211.c:130:		/* IEEE 802.11 channel 14 - Only JP enables
wl_cfg80211.c:133:		REG_RULE(2484-10, 2484+10, 20, 6, 20, 0),
wl_cfg80211.c:135:		REG_RULE(5150-10, 5350+10, 40, 6, 20, 0),
wl_cfg80211.c:137:		REG_RULE(5470-10, 5850+10, 40, 6, 20, 0), }
wl_cfg80211.c:451:		return -EIO;						\
wl_cfg80211.c:684:		        "to pre-11ac format\n",
wl_cfg80211.c:800:	key->index = htod32(key->index);
wl_cfg80211.c:801:	key->len = htod32(key->len);
wl_cfg80211.c:802:	key->algo = htod32(key->algo);
wl_cfg80211.c:803:	key->flags = htod32(key->flags);
wl_cfg80211.c:804:	key->rxiv.hi = htod32(key->rxiv.hi);
wl_cfg80211.c:805:	key->rxiv.lo = htod16(key->rxiv.lo);
wl_cfg80211.c:806:	key->iv_initialized = htod32(key->iv_initialized);
wl_cfg80211.c:811:	key->index = dtoh32(key->index);
wl_cfg80211.c:812:	key->len = dtoh32(key->len);
wl_cfg80211.c:813:	key->algo = dtoh32(key->algo);
wl_cfg80211.c:814:	key->flags = dtoh32(key->flags);
wl_cfg80211.c:815:	key->rxiv.hi = dtoh32(key->rxiv.hi);
wl_cfg80211.c:816:	key->rxiv.lo = dtoh16(key->rxiv.lo);
wl_cfg80211.c:817:	key->iv_initialized = dtoh32(key->iv_initialized);
wl_cfg80211.c:843:	len -= 4;	/* for the WPS IE's OUI, oui_type fields */
wl_cfg80211.c:854:		len -= 4;			/* for the attr id, attr len fields */
wl_cfg80211.c:855:		len -= subelt_len;	/* for the remaining fields in this attribute */
wl_cfg80211.c:925:	*(u32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
wl_cfg80211.c:926:	if ((err = wldev_ioctl(dev, WLC_GET_BSS_INFO, wl->extra_buf,
wl_cfg80211.c:932:			bss = (struct wl_bss_info *) (wl->extra_buf + 4);
wl_cfg80211.c:933:			chspec =  bss->chanspec;
wl_cfg80211.c:943:	return ERR_PTR(-EOPNOTSUPP);
wl_cfg80211.c:959:	s32 timeout = -1;
wl_cfg80211.c:960:	s32 wlif_type = -1;
wl_cfg80211.c:976:		return ERR_PTR(-EINVAL);
wl_cfg80211.c:979:	dhd = (dhd_pub_t *)(wl->pub);
wl_cfg80211.c:1017:	if (wl->p2p_supported && (wlif_type != -1)) {
wl_cfg80211.c:1028:			timeout = wait_event_interruptible_timeout(wl->netif_change_event,
wl_cfg80211.c:1041:				WL_ERR(("timeount < 0, return -EAGAIN\n"));
wl_cfg80211.c:1042:				return ERR_PTR(-EAGAIN);
wl_cfg80211.c:1047:			if (wl->iface_cnt == IFACE_MAX_CNT)
wl_cfg80211.c:1048:				return ERR_PTR(-ENOMEM);
wl_cfg80211.c:1053:			return ERR_PTR(-ENODEV);
wl_cfg80211.c:1055:		if (!wl->p2p)
wl_cfg80211.c:1056:			return ERR_PTR(-ENODEV);
wl_cfg80211.c:1058:		if (wl->p2p && !wl->p2p->on && strstr(name, WL_P2P_INTERFACE_PREFIX)) {
wl_cfg80211.c:1064:				&wl->p2p->dev_addr, &wl->p2p->int_addr);
wl_cfg80211.c:1067:		memset(wl->p2p->vir_ifname, 0, IFNAMSIZ);
wl_cfg80211.c:1068:		strncpy(wl->p2p->vir_ifname, name, IFNAMSIZ - 1);
wl_cfg80211.c:1072:		if (!wl->wlfc_on && !disable_proptx) {
wl_cfg80211.c:1073:			dhd->wlfc_enabled = true;
wl_cfg80211.c:1078:			wl->wlfc_on = true;
wl_cfg80211.c:1088:		/* For P2P mode, use P2P-specific driver features to create the
wl_cfg80211.c:1094:		err = wl_cfgp2p_ifadd(wl, &wl->p2p->int_addr, htod32(wlif_type), chspec);
wl_cfg80211.c:1098:			return ERR_PTR(-ENOMEM);
wl_cfg80211.c:1101:		timeout = wait_event_interruptible_timeout(wl->netif_change_event,
wl_cfg80211.c:1110:				return ERR_PTR(-ENOMEM);
wl_cfg80211.c:1112:			vwdev->wiphy = wl->wdev->wiphy;
wl_cfg80211.c:1114:				wl->p2p->vir_ifname));
wl_cfg80211.c:1115:			vwdev->iftype = type;
wl_cfg80211.c:1117:			_ndev->ieee80211_ptr = vwdev;
wl_cfg80211.c:1118:			SET_NETDEV_DEV(_ndev, wiphy_dev(vwdev->wiphy));
wl_cfg80211.c:1119:			vwdev->netdev = _ndev;
wl_cfg80211.c:1121:			wl->p2p->vif_created = true;
wl_cfg80211.c:1128:			if (net_attach && !net_attach(wl->pub, _ndev->ifindex)) {
wl_cfg80211.c:1134:					"created net attach done\n", wl->p2p->vir_ifname));
wl_cfg80211.c:1155:			WL_ERR((" virtual interface(%s) is not created \n", wl->p2p->vir_ifname));
wl_cfg80211.c:1156:			memset(wl->p2p->vir_ifname, '\0', IFNAMSIZ);
wl_cfg80211.c:1157:			wl->p2p->vif_created = false;
wl_cfg80211.c:1159:		if (dhd->wlfc_enabled && wl->wlfc_on) {
wl_cfg80211.c:1160:			dhd->wlfc_enabled = false;
wl_cfg80211.c:1162:			wl->wlfc_on = false;
wl_cfg80211.c:1170:	return ERR_PTR(-ENODEV);
wl_cfg80211.c:1178:	s32 timeout = -1;
wl_cfg80211.c:1182:	if (wl->p2p_net == dev) {
wl_cfg80211.c:1189:	if (wl->p2p_supported) {
wl_cfg80211.c:1190:		memcpy(p2p_mac.octet, wl->p2p->int_addr.octet, ETHER_ADDR_LEN);
wl_cfg80211.c:1192:		/* Clear GO_NEG_PHASE bit to take care of GO-NEG-FAIL cases
wl_cfg80211.c:1196:		if (wl->p2p->vif_created) {
wl_cfg80211.c:1207:					(&wl->iface_disable, msecs_to_jiffies(500));
wl_cfg80211.c:1222:					wait_for_completion_timeout(&wl->iface_disable,
wl_cfg80211.c:1241:					"HANG Notification sent to %s\n", ret, ndev->name));
wl_cfg80211.c:1245:			timeout = wait_event_interruptible_timeout(wl->netif_change_event,
wl_cfg80211.c:1246:				(wl->p2p->vif_created == false),
wl_cfg80211.c:1248:			if (timeout > 0 && (wl->p2p->vif_created == false)) {
wl_cfg80211.c:1270:	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
wl_cfg80211.c:1295:		return -EINVAL;
wl_cfg80211.c:1298:		return -EINVAL;
wl_cfg80211.c:1301:		if (wl->p2p_supported && wl->p2p->vif_created) {
wl_cfg80211.c:1302:			WL_DBG(("p2p_vif_created (%d) p2p_on (%d)\n", wl->p2p->vif_created,
wl_cfg80211.c:1315:				ndev->name, ap, infra, type));
wl_cfg80211.c:1318:			wl_cfgp2p_ifchange(wl, &wl->p2p->int_addr, htod32(wlif_type), chspec);
wl_cfg80211.c:1319:			wait_event_interruptible_timeout(wl->netif_change_event,
wl_cfg80211.c:1323:			dhd->op_mode &= ~DHD_FLAG_P2P_GC_MODE;
wl_cfg80211.c:1324:			dhd->op_mode |= DHD_FLAG_P2P_GO_MODE;
wl_cfg80211.c:1332:			if (!wl->ap_info &&
wl_cfg80211.c:1333:				!(wl->ap_info = kzalloc(sizeof(struct ap_info), GFP_KERNEL))) {
wl_cfg80211.c:1335:				return -ENOMEM;
wl_cfg80211.c:1339:			return -EINVAL;
wl_cfg80211.c:1345:	ndev->ieee80211_ptr->iftype = type;
wl_cfg80211.c:1360:	if (wl->p2p_supported && wl_get_p2p_status(wl, IF_ADD)) {
wl_cfg80211.c:1362:			"new name: %s\n", ndev->name, wl->p2p->vir_ifname));
wl_cfg80211.c:1364:		strncpy(ndev->name, wl->p2p->vir_ifname, IFNAMSIZ - 1);
wl_cfg80211.c:1368:		ndev->ifindex = idx;
wl_cfg80211.c:1371:		wake_up_interruptible(&wl->netif_change_event);
wl_cfg80211.c:1385:	wake_up_interruptible(&wl->netif_change_event);
wl_cfg80211.c:1396:	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
wl_cfg80211.c:1398:	if (!ndev || (strlen(ndev->name) == 0)) {
wl_cfg80211.c:1403:	if (p2p_is_on(wl) && wl->p2p->vif_created &&
wl_cfg80211.c:1405:		if (wl->scan_request &&
wl_cfg80211.c:1406:			(wl->escan_info.ndev == ndev)) {
wl_cfg80211.c:1408:			wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
wl_cfg80211.c:1419:			(unsigned int)ndev, wl->p2p->vir_ifname));
wl_cfg80211.c:1421:		memset(wl->p2p->vir_ifname, '\0', IFNAMSIZ);
wl_cfg80211.c:1425:		wl->p2p->vif_created = false;
wl_cfg80211.c:1429:		if (dhd->wlfc_enabled && wl->wlfc_on) {
wl_cfg80211.c:1430:			dhd->wlfc_enabled = false;
wl_cfg80211.c:1432:			wl->wlfc_on = false;
wl_cfg80211.c:1438:	wake_up_interruptible(&wl->netif_change_event);
wl_cfg80211.c:1470:		wake_up_interruptible(&wl->netif_change_event);
wl_cfg80211.c:1488:	pos = p2p_ie->subelts;
wl_cfg80211.c:1489:	end = p2p_ie->subelts + (p2p_ie->len - 4);
wl_cfg80211.c:1492:		p2p_ie->len));
wl_cfg80211.c:1497:			CFGP2P_DBG((" -- Invalid P2P attribute"));
wl_cfg80211.c:1505:				   attr_len, (int) (end - pos - 3)));
wl_cfg80211.c:1541:	memcpy(&params->bssid, &ether_bcast, ETHER_ADDR_LEN);
wl_cfg80211.c:1542:	params->bss_type = DOT11_BSSTYPE_ANY;
wl_cfg80211.c:1543:	params->scan_type = 0;
wl_cfg80211.c:1544:	params->nprobes = -1;
wl_cfg80211.c:1545:	params->active_time = -1;
wl_cfg80211.c:1546:	params->passive_time = -1;
wl_cfg80211.c:1547:	params->home_time = -1;
wl_cfg80211.c:1548:	params->channel_num = 0;
wl_cfg80211.c:1549:	memset(&params->ssid, 0, sizeof(wlc_ssid_t));
wl_cfg80211.c:1552:	WL_SCAN(("nprobes=%d\n", params->nprobes));
wl_cfg80211.c:1553:	WL_SCAN(("active_time=%d\n", params->active_time));
wl_cfg80211.c:1554:	WL_SCAN(("passive_time=%d\n", params->passive_time));
wl_cfg80211.c:1555:	WL_SCAN(("home_time=%d\n", params->home_time));
wl_cfg80211.c:1556:	WL_SCAN(("scan_type=%d\n", params->scan_type));
wl_cfg80211.c:1558:	params->nprobes = htod32(params->nprobes);
wl_cfg80211.c:1559:	params->active_time = htod32(params->active_time);
wl_cfg80211.c:1560:	params->passive_time = htod32(params->passive_time);
wl_cfg80211.c:1561:	params->home_time = htod32(params->home_time);
wl_cfg80211.c:1567:	n_ssids = request->n_ssids;
wl_cfg80211.c:1568:	n_channels = request->n_channels;
wl_cfg80211.c:1575:			channel = ieee80211_frequency_to_channel(request->channels[i]->center_freq);
wl_cfg80211.c:1577:			if ((wl->escan_info.ndev != wl_to_prmry_ndev(wl)) &&
wl_cfg80211.c:1578:				(request->channels[i]->flags &
wl_cfg80211.c:1582:			if (request->channels[i]->band == IEEE80211_BAND_2GHZ) {
wl_cfg80211.c:1584:				if (wl->curr_band == WLC_BAND_5G) {
wl_cfg80211.c:1592:				if (wl->curr_band == WLC_BAND_2G) {
wl_cfg80211.c:1603:			params->channel_list[j] = channel;
wl_cfg80211.c:1604:			params->channel_list[j] &= WL_CHANSPEC_CHAN_MASK;
wl_cfg80211.c:1605:			params->channel_list[j] |= chanspec;
wl_cfg80211.c:1607:				channel, params->channel_list[j]));
wl_cfg80211.c:1608:			params->channel_list[j] = wl_chspec_host_to_driver(params->channel_list[j]);
wl_cfg80211.c:1623:			ssid.SSID_len = request->ssids[i].ssid_len;
wl_cfg80211.c:1624:			memcpy(ssid.SSID, request->ssids[i].ssid, ssid.SSID_len);
wl_cfg80211.c:1637:	params->channel_num =
wl_cfg80211.c:1642:		params->active_time = WL_SCAN_CONNECT_DWELL_TIME_MS;
wl_cfg80211.c:1657:		n_channels = request->n_channels;
wl_cfg80211.c:1658:		n_ssids = request->n_ssids;
wl_cfg80211.c:1671:		err = -ENOMEM;
wl_cfg80211.c:1674:	wl_scan_prep(&params->params, request);
wl_cfg80211.c:1676:	params->version = htod32(ISCAN_REQ_VERSION);
wl_cfg80211.c:1677:	params->action = htod16(action);
wl_cfg80211.c:1678:	params->scan_duration = htod16(0);
wl_cfg80211.c:1682:		err = -ENOMEM;
wl_cfg80211.c:1685:	err = wldev_iovar_setbuf(iscan->dev, "iscan", params, params_size,
wl_cfg80211.c:1686:		iscan->ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
wl_cfg80211.c:1688:		if (err == -EBUSY) {
wl_cfg80211.c:1708:	iscan->state = WL_ISCAN_STATE_SCANING;
wl_cfg80211.c:1710:	passive_scan = wl->active_scan ? 0 : 1;
wl_cfg80211.c:1717:	wl->iscan_kickstart = true;
wl_cfg80211.c:1719:	mod_timer(&iscan->timer, jiffies + msecs_to_jiffies(iscan->timer_ms));
wl_cfg80211.c:1720:	iscan->timer_on = 1;
wl_cfg80211.c:1731:		return -ENOMEM;
wl_cfg80211.c:1735:	list->count = htod32(WL_NUMCHANNELS);
wl_cfg80211.c:1766:		err = -EINVAL;
wl_cfg80211.c:1769:	if (!wl->p2p_supported || !p2p_scan(wl)) {
wl_cfg80211.c:1771:		WL_SCAN((" LEGACY E-SCAN START\n"));
wl_cfg80211.c:1775:			n_channels = request->n_channels;
wl_cfg80211.c:1776:			n_ssids = request->n_ssids;
wl_cfg80211.c:1789:			err = -ENOMEM;
wl_cfg80211.c:1793:		wl_scan_prep(&params->params, request);
wl_cfg80211.c:1795:		params->version = htod32(ESCAN_REQ_VERSION);
wl_cfg80211.c:1796:		params->action =  htod16(action);
wl_cfg80211.c:1797:		params->sync_id = htod16(0x1234);
wl_cfg80211.c:1801:			err = -ENOMEM;
wl_cfg80211.c:1805:			wl->escan_ioctl_buf, WLC_IOCTL_MEDLEN, NULL);
wl_cfg80211.c:1819:		if (request && request->n_channels) {
wl_cfg80211.c:1820:			num_chans = request->n_channels;
wl_cfg80211.c:1826:				err = -ENOMEM;
wl_cfg80211.c:1831:				n_valid_chan = dtoh32(list->count);
wl_cfg80211.c:1837:					_freq = request->channels[i]->center_freq;
wl_cfg80211.c:1842:					if ((wl->curr_band != WLC_BAND_AUTO) &&
wl_cfg80211.c:1843:						(wl->curr_band != channel_band) &&
wl_cfg80211.c:1849:					if (request->channels[i]->flags &
wl_cfg80211.c:1858:						if (channel == (dtoh32(list->element[j])))
wl_cfg80211.c:1885:		err = wl_cfgp2p_escan(wl, ndev, wl->active_scan, num_chans, default_chan_list,
wl_cfg80211.c:1893:		if ((err == BCME_EPERM) && wl->scan_suppressed)
wl_cfg80211.c:1910:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:1911:	results = (wl_scan_results_t *) wl->escan_info.escan_buf;
wl_cfg80211.c:1912:	results->version = 0;
wl_cfg80211.c:1913:	results->count = 0;
wl_cfg80211.c:1914:	results->buflen = WL_SCAN_RESULTS_FIXED_SIZE;
wl_cfg80211.c:1916:	wl->escan_info.ndev = ndev;
wl_cfg80211.c:1917:	wl->escan_info.wiphy = wiphy;
wl_cfg80211.c:1918:	wl->escan_info.escan_state = WL_ESCAN_STATE_SCANING;
wl_cfg80211.c:1919:	passive_scan = wl->active_scan ? 0 : 1;
wl_cfg80211.c:1929:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:1951:	s32 bssidx = -1;
wl_cfg80211.c:1960:	if (ndev == wl->p2p_net) {
wl_cfg80211.c:1966:		return -EAGAIN;
wl_cfg80211.c:1971:		if (wl->scan_request == NULL) {
wl_cfg80211.c:1976:			return -EAGAIN;
wl_cfg80211.c:1981:		return -EAGAIN;
wl_cfg80211.c:1983:	if (request && request->n_ssids > WL_SCAN_PARAMS_SSID_MAX) {
wl_cfg80211.c:1985:		return -EOPNOTSUPP;
wl_cfg80211.c:1995:	mod_timer(&wl->scan_timeout, jiffies + msecs_to_jiffies(WL_SCAN_TIMER_INTERVAL_MS));
wl_cfg80211.c:1998:		ssids = request->ssids;
wl_cfg80211.c:1999:		if (wl->iscan_on && (!ssids || !ssids->ssid_len || request->n_ssids != 1)) {
wl_cfg80211.c:2001:		} else if (wl->escan_on) {
wl_cfg80211.c:2004:			for (i = 0; i < request->n_ssids; i++) {
wl_cfg80211.c:2012:				if (wl->p2p_supported) {
wl_cfg80211.c:2020:							&wl->p2p->dev_addr, &wl->p2p->int_addr);
wl_cfg80211.c:2030:				if (wl->p2p_supported) {
wl_cfg80211.c:2047:				if (!wl->p2p_supported || !p2p_scan(wl)) {
wl_cfg80211.c:2052:						(u8 *)request->ie, request->ie_len)) != NULL) {
wl_cfg80211.c:2053:						ie_len = interworking_ie->len;
wl_cfg80211.c:2056:						       VNDR_IE_CUSTOM_FLAG, interworking_ie->id,
wl_cfg80211.c:2057:						       interworking_ie->data, interworking_ie->len);
wl_cfg80211.c:2062:					} else if (wl->iw_ie_len != 0) {
wl_cfg80211.c:2075:						VNDR_IE_PRBREQ_FLAG, (u8 *)request->ie,
wl_cfg80211.c:2076:						request->ie_len);
wl_cfg80211.c:2089:	wl->scan_request = request;
wl_cfg80211.c:2098:		if (wl->p2p_supported) {
wl_cfg80211.c:2102:				wl->afx_hdl->my_listen_chan =
wl_cfg80211.c:2103:					wl_find_listen_channel(wl, (u8 *)request->ie,
wl_cfg80211.c:2104:					request->ie_len);
wl_cfg80211.c:2106:					request->ie, request->ie_len);
wl_cfg80211.c:2121:		memset(&sr->ssid, 0, sizeof(sr->ssid));
wl_cfg80211.c:2122:		sr->ssid.SSID_len =
wl_cfg80211.c:2123:			min_t(u8, sizeof(sr->ssid.SSID), ssids->ssid_len);
wl_cfg80211.c:2124:		if (sr->ssid.SSID_len) {
wl_cfg80211.c:2125:			memcpy(sr->ssid.SSID, ssids->ssid, sr->ssid.SSID_len);
wl_cfg80211.c:2126:			sr->ssid.SSID_len = htod32(sr->ssid.SSID_len);
wl_cfg80211.c:2128:				sr->ssid.SSID, sr->ssid.SSID_len));
wl_cfg80211.c:2132:		WL_SCAN(("sr->ssid.SSID_len (%d)\n", sr->ssid.SSID_len));
wl_cfg80211.c:2133:		passive_scan = wl->active_scan ? 0 : 1;
wl_cfg80211.c:2140:		err = wldev_ioctl(ndev, WLC_SCAN, &sr->ssid,
wl_cfg80211.c:2141:			sizeof(sr->ssid), false);
wl_cfg80211.c:2143:			if (err == -EBUSY) {
wl_cfg80211.c:2145:					"canceled\n", sr->ssid.SSID));
wl_cfg80211.c:2162:		WL_ERR(("Scan err = (%d), busy?%d", err, -EBUSY));
wl_cfg80211.c:2163:		err = -EBUSY;
wl_cfg80211.c:2167:	if (err == -EBUSY) {
wl_cfg80211.c:2197:	if (timer_pending(&wl->scan_timeout))
wl_cfg80211.c:2198:		del_timer_sync(&wl->scan_timeout);
wl_cfg80211.c:2199:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:2200:	wl->scan_request = NULL;
wl_cfg80211.c:2201:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:2217:		if ((err == BCME_EPERM) && wl->scan_suppressed)
wl_cfg80211.c:2274:		(wl->conf->rts_threshold != wiphy->rts_threshold)) {
wl_cfg80211.c:2275:		wl->conf->rts_threshold = wiphy->rts_threshold;
wl_cfg80211.c:2276:		err = wl_set_rts(ndev, wl->conf->rts_threshold);
wl_cfg80211.c:2281:		(wl->conf->frag_threshold != wiphy->frag_threshold)) {
wl_cfg80211.c:2282:		wl->conf->frag_threshold = wiphy->frag_threshold;
wl_cfg80211.c:2283:		err = wl_set_frag(ndev, wl->conf->frag_threshold);
wl_cfg80211.c:2288:		(wl->conf->retry_long != wiphy->retry_long)) {
wl_cfg80211.c:2289:		wl->conf->retry_long = wiphy->retry_long;
wl_cfg80211.c:2290:		err = wl_set_retry(ndev, wl->conf->retry_long, true);
wl_cfg80211.c:2295:		(wl->conf->retry_short != wiphy->retry_short)) {
wl_cfg80211.c:2296:		wl->conf->retry_short = wiphy->retry_short;
wl_cfg80211.c:2297:		err = wl_set_retry(ndev, wl->conf->retry_short, false);
wl_cfg80211.c:2321:	if (params->bssid) {
wl_cfg80211.c:2323:		return -EOPNOTSUPP;
wl_cfg80211.c:2325:	bss = cfg80211_get_ibss(wiphy, NULL, params->ssid, params->ssid_len);
wl_cfg80211.c:2327:		memcpy(ssid.ssid, params->ssid, params->ssid_len);
wl_cfg80211.c:2328:		ssid.ssid_len = params->ssid_len;
wl_cfg80211.c:2332:				 -EBUSY)) {
wl_cfg80211.c:2349:			params->ssid, params->ssid_len);
wl_cfg80211.c:2352:		wl->ibss_starter = false;
wl_cfg80211.c:2355:		wl->ibss_starter = true;
wl_cfg80211.c:2357:	chan = params->channel;
wl_cfg80211.c:2359:		wl->channel = ieee80211_frequency_to_channel(chan->center_freq);
wl_cfg80211.c:2365:	memcpy((void *)join_params.ssid.SSID, (void *)params->ssid,
wl_cfg80211.c:2366:		params->ssid_len);
wl_cfg80211.c:2367:	join_params.ssid.SSID_len = htod32(params->ssid_len);
wl_cfg80211.c:2368:	if (params->bssid)
wl_cfg80211.c:2369:		memcpy(&join_params.params.bssid, params->bssid,
wl_cfg80211.c:2403:	if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)
wl_cfg80211.c:2406:	else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)
wl_cfg80211.c:2422:	sec->wpa_versions = sme->crypto.wpa_versions;
wl_cfg80211.c:2435:	switch (sme->auth_type) {
wl_cfg80211.c:2450:		WL_ERR(("invalid auth type (%d)\n", sme->auth_type));
wl_cfg80211.c:2460:	sec->auth_type = sme->auth_type;
wl_cfg80211.c:2474:	if (sme->crypto.n_ciphers_pairwise) {
wl_cfg80211.c:2475:		switch (sme->crypto.ciphers_pairwise[0]) {
wl_cfg80211.c:2491:				sme->crypto.ciphers_pairwise[0]));
wl_cfg80211.c:2492:			return -EINVAL;
wl_cfg80211.c:2495:	if (sme->crypto.cipher_group) {
wl_cfg80211.c:2496:		switch (sme->crypto.cipher_group) {
wl_cfg80211.c:2512:				sme->crypto.cipher_group));
wl_cfg80211.c:2513:			return -EINVAL;
wl_cfg80211.c:2520:		if (sme->privacy)
wl_cfg80211.c:2523:			/* WPS-2.0 allows no security */
wl_cfg80211.c:2536:	sec->cipher_pairwise = sme->crypto.ciphers_pairwise[0];
wl_cfg80211.c:2537:	sec->cipher_group = sme->crypto.cipher_group;
wl_cfg80211.c:2551:	if (sme->crypto.n_akm_suites) {
wl_cfg80211.c:2559:			switch (sme->crypto.akm_suites[0]) {
wl_cfg80211.c:2568:					sme->crypto.cipher_group));
wl_cfg80211.c:2569:				return -EINVAL;
wl_cfg80211.c:2573:			switch (sme->crypto.akm_suites[0]) {
wl_cfg80211.c:2582:					sme->crypto.cipher_group));
wl_cfg80211.c:2583:				return -EINVAL;
wl_cfg80211.c:2595:	sec->wpa_auth = sme->crypto.akm_suites[0];
wl_cfg80211.c:2611:	WL_DBG(("key len (%d)\n", sme->key_len));
wl_cfg80211.c:2612:	if (sme->key_len) {
wl_cfg80211.c:2615:			sec->wpa_versions, sec->cipher_pairwise));
wl_cfg80211.c:2616:		if (!(sec->wpa_versions & (NL80211_WPA_VERSION_1 |
wl_cfg80211.c:2618:			(sec->cipher_pairwise & (WLAN_CIPHER_SUITE_WEP40 |
wl_cfg80211.c:2622:			key.len = (u32) sme->key_len;
wl_cfg80211.c:2623:			key.index = (u32) sme->key_idx;
wl_cfg80211.c:2626:				return -EINVAL;
wl_cfg80211.c:2628:			memcpy(key.data, sme->key, key.len);
wl_cfg80211.c:2630:			switch (sec->cipher_pairwise) {
wl_cfg80211.c:2639:					sme->crypto.ciphers_pairwise[0]));
wl_cfg80211.c:2640:				return -EINVAL;
wl_cfg80211.c:2648:				wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:2653:			if (sec->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {
wl_cfg80211.c:2678:	struct ieee80211_channel *chan = sme->channel;
wl_cfg80211.c:2693:	if (unlikely(!sme->ssid)) {
wl_cfg80211.c:2695:		return -EOPNOTSUPP;
wl_cfg80211.c:2704:	if (wl->scan_request) {
wl_cfg80211.c:2709:	if (sme->bssid) {
wl_cfg80211.c:2710:		memcpy(connect_req_bssid, sme->bssid, ETHER_ADDR_LEN);
wl_cfg80211.c:2753:				VNDR_IE_ASSOCREQ_FLAG, sme->ie, sme->ie_len);
wl_cfg80211.c:2756:		if ((wpa2_ie = bcm_parse_tlvs((u8 *)sme->ie, sme->ie_len,
wl_cfg80211.c:2761:		if ((wpa_ie = wl_cfgp2p_find_wpaie((u8 *)sme->ie,
wl_cfg80211.c:2762:			sme->ie_len)) != NULL) {
wl_cfg80211.c:2767:			wpaie_len = (wpa_ie != NULL) ? wpa_ie->length : wpa2_ie->len;
wl_cfg80211.c:2770:				wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
wl_cfg80211.c:2773:				wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
wl_cfg80211.c:2777:			VNDR_IE_ASSOCREQ_FLAG, (u8 *)sme->ie, sme->ie_len);
wl_cfg80211.c:2784:		wl->channel = ieee80211_frequency_to_channel(chan->center_freq);
wl_cfg80211.c:2786:		WL_DBG(("channel (%d), center_req (%d), %d channels\n", wl->channel,
wl_cfg80211.c:2787:			chan->center_freq, chan_cnt));
wl_cfg80211.c:2789:		wl->channel = 0;
wl_cfg80211.c:2790:	WL_DBG(("ie (%p), ie_len (%zd)\n", sme->ie, sme->ie_len));
wl_cfg80211.c:2829:		err = -ENOMEM;
wl_cfg80211.c:2833:	ext_join_params->ssid.SSID_len = min(sizeof(ext_join_params->ssid.SSID), sme->ssid_len);
wl_cfg80211.c:2834:	memcpy(&ext_join_params->ssid.SSID, sme->ssid, ext_join_params->ssid.SSID_len);
wl_cfg80211.c:2835:	wl_update_prof(wl, dev, NULL, &ext_join_params->ssid, WL_PROF_SSID);
wl_cfg80211.c:2836:	ext_join_params->ssid.SSID_len = htod32(ext_join_params->ssid.SSID_len);
wl_cfg80211.c:2840:	ext_join_params->scan.active_time = WL_SCAN_JOIN_ACTIVE_DWELL_TIME_MS;
wl_cfg80211.c:2841:	ext_join_params->scan.passive_time = WL_SCAN_JOIN_PASSIVE_DWELL_TIME_MS;
wl_cfg80211.c:2843:	ext_join_params->scan.scan_type = -1;
wl_cfg80211.c:2844:	ext_join_params->scan.nprobes
wl_cfg80211.c:2845:		= (ext_join_params->scan.active_time/WL_SCAN_JOIN_PROBE_INTERVAL_MS);
wl_cfg80211.c:2846:	ext_join_params->scan.home_time = -1;
wl_cfg80211.c:2848:	if (sme->bssid)
wl_cfg80211.c:2849:		memcpy(&ext_join_params->assoc.bssid, sme->bssid, ETH_ALEN);
wl_cfg80211.c:2851:		memcpy(&ext_join_params->assoc.bssid, &ether_bcast, ETH_ALEN);
wl_cfg80211.c:2852:	ext_join_params->assoc.chanspec_num = chan_cnt;
wl_cfg80211.c:2856:		channel = wl->channel;
wl_cfg80211.c:2862:		ext_join_params->assoc.chanspec_list[0]  &= WL_CHANSPEC_CHAN_MASK;
wl_cfg80211.c:2863:		ext_join_params->assoc.chanspec_list[0] |= chspec;
wl_cfg80211.c:2864:		ext_join_params->assoc.chanspec_list[0] =
wl_cfg80211.c:2865:			wl_chspec_host_to_driver(ext_join_params->assoc.chanspec_list[0]);
wl_cfg80211.c:2867:	ext_join_params->assoc.chanspec_num = htod32(ext_join_params->assoc.chanspec_num);
wl_cfg80211.c:2868:	if (ext_join_params->ssid.SSID_len < IEEE80211_MAX_SSID_LEN) {
wl_cfg80211.c:2869:		WL_INFO(("ssid \"%s\", len (%d)\n", ext_join_params->ssid.SSID,
wl_cfg80211.c:2870:			ext_join_params->ssid.SSID_len));
wl_cfg80211.c:2874:		wl->ioctl_buf, WLC_IOCTL_MAXLEN, wl_cfgp2p_find_idx(wl, dev), &wl->ioctl_buf_sync);
wl_cfg80211.c:2890:	join_params.ssid.SSID_len = min(sizeof(join_params.ssid.SSID), sme->ssid_len);
wl_cfg80211.c:2891:	memcpy(&join_params.ssid.SSID, sme->ssid, join_params.ssid.SSID_len);
wl_cfg80211.c:2894:	if (sme->bssid)
wl_cfg80211.c:2895:		memcpy(&join_params.params.bssid, sme->bssid, ETH_ALEN);
wl_cfg80211.c:2899:	wl_ch_to_chanspec(wl->channel, &join_params, &join_params_size);
wl_cfg80211.c:2935:		if (wl->scan_request) {
wl_cfg80211.c:2972:			WL_ERR(("TX_POWER_LIMITTED - dbm is negative\n"));
wl_cfg80211.c:2973:			return -EINVAL;
wl_cfg80211.c:2978:			WL_ERR(("TX_POWER_FIXED - dbm is negative..\n"));
wl_cfg80211.c:2979:			return -EINVAL;
wl_cfg80211.c:3002:	wl->conf->tx_power = dbm;
wl_cfg80211.c:3071:	key.len = (u32) params->key_len;
wl_cfg80211.c:3078:			wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:3086:			return -EINVAL;
wl_cfg80211.c:3089:		memcpy(key.data, params->key, key.len);
wl_cfg80211.c:3092:			(params->cipher == WLAN_CIPHER_SUITE_TKIP)) {
wl_cfg80211.c:3100:		if (params->seq && params->seq_len == 6) {
wl_cfg80211.c:3103:			ivptr = (u8 *) params->seq;
wl_cfg80211.c:3110:		switch (params->cipher) {
wl_cfg80211.c:3132:			WL_ERR(("Invalid cipher (0x%x)\n", params->cipher));
wl_cfg80211.c:3133:			return -EINVAL;
wl_cfg80211.c:3139:			wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:3172:	key.len = (u32) params->key_len;
wl_cfg80211.c:3177:		return -EINVAL;
wl_cfg80211.c:3179:	memcpy(key.data, params->key, key.len);
wl_cfg80211.c:3182:	switch (params->cipher) {
wl_cfg80211.c:3215:		WL_ERR(("Invalid cipher (0x%x)\n", params->cipher));
wl_cfg80211.c:3216:		return -EINVAL;
wl_cfg80211.c:3221:	err = wldev_iovar_setbuf_bsscfg(dev, "wsec_key", &key, sizeof(key), wl->ioctl_buf,
wl_cfg80211.c:3222:		WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:3257:		return -EINVAL;
wl_cfg80211.c:3269:	err = wldev_iovar_setbuf_bsscfg(dev, "wsec_key", &key, sizeof(key), wl->ioctl_buf,
wl_cfg80211.c:3270:		WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:3272:		if (err == -EINVAL) {
wl_cfg80211.c:3315:			if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP40) {
wl_cfg80211.c:3318:			} else if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP104) {
wl_cfg80211.c:3333:			return -EINVAL;
wl_cfg80211.c:3345:	return -EOPNOTSUPP;
wl_cfg80211.c:3361:	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
wl_cfg80211.c:3365:			ETHER_ADDR_LEN, wl->ioctl_buf, WLC_IOCTL_SMLEN, &wl->ioctl_buf_sync);
wl_cfg80211.c:3370:		sinfo->filled = STATION_INFO_INACTIVE_TIME;
wl_cfg80211.c:3371:		sta = (sta_info_t *)wl->ioctl_buf;
wl_cfg80211.c:3372:		sta->len = dtoh16(sta->len);
wl_cfg80211.c:3373:		sta->cap = dtoh16(sta->cap);
wl_cfg80211.c:3374:		sta->flags = dtoh32(sta->flags);
wl_cfg80211.c:3375:		sta->idle = dtoh32(sta->idle);
wl_cfg80211.c:3376:		sta->in = dtoh32(sta->in);
wl_cfg80211.c:3377:		sinfo->inactive_time = sta->idle * 1000;
wl_cfg80211.c:3379:		if (sta->flags & WL_STA_ASSOC) {
wl_cfg80211.c:3380:			sinfo->filled |= STATION_INFO_CONNECTED_TIME;
wl_cfg80211.c:3381:			sinfo->connected_time = sta->in;
wl_cfg80211.c:3384:			bcm_ether_ntoa((const struct ether_addr *)mac, eabuf), sinfo->inactive_time,
wl_cfg80211.c:3385:			sta->idle * 1000));
wl_cfg80211.c:3393:			if (err == -ERESTARTSYS)
wl_cfg80211.c:3395:			err = -ENODEV;
wl_cfg80211.c:3409:			sinfo->filled |= STATION_INFO_TX_BITRATE;
wl_cfg80211.c:3410:			sinfo->txrate.legacy = rate * 5;
wl_cfg80211.c:3426:		sinfo->filled |= STATION_INFO_SIGNAL;
wl_cfg80211.c:3427:		sinfo->signal = rssi;
wl_cfg80211.c:3432:			sinfo->filled |= (STATION_INFO_RX_PACKETS |
wl_cfg80211.c:3436:			sinfo->rx_packets = pktcnt.rx_good_pkt;
wl_cfg80211.c:3437:			sinfo->rx_dropped_misc = pktcnt.rx_bad_pkt;
wl_cfg80211.c:3438:			sinfo->tx_packets = pktcnt.tx_good_pkt;
wl_cfg80211.c:3439:			sinfo->tx_failed  = pktcnt.tx_bad_pkt;
wl_cfg80211.c:3442:		if (err && (err != -ERESTARTSYS)) {
wl_cfg80211.c:3457:	int pm = -1;
wl_cfg80211.c:3461:	if (err || (pm == -1)) {
wl_cfg80211.c:3466:		if (dev->ieee80211_ptr)
wl_cfg80211.c:3467:			dev->ieee80211_ptr->ps = pm;
wl_cfg80211.c:3481:	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
wl_cfg80211.c:3485:	if (wl->p2p_net == dev || _net_info == NULL) {
wl_cfg80211.c:3488:	WL_DBG(("%s: Enter power save enabled %d\n", dev->name, enabled));
wl_cfg80211.c:3492:	pm = enabled ? ((dhd->in_suspend) ? PM_MAX : PM_FAST) : PM_OFF;
wl_cfg80211.c:3497:	if (_net_info->pm_block || wl->vsdb_mode) {
wl_cfg80211.c:3500:			dev->name, _net_info->pm_block, wl->vsdb_mode));
wl_cfg80211.c:3504:	WL_DBG(("%s:power save %s\n", dev->name, (pm ? "enabled" : "disabled")));
wl_cfg80211.c:3507:		if (err == -ENODEV)
wl_cfg80211.c:3572:			(int)wl->status));
wl_cfg80211.c:3576:		wl_set_drv_status(wl, SCAN_ABORTING, iter->ndev);
wl_cfg80211.c:3578:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:3579:	if (wl->scan_request) {
wl_cfg80211.c:3580:		cfg80211_scan_done(wl->scan_request, true);
wl_cfg80211.c:3581:		wl->scan_request = NULL;
wl_cfg80211.c:3584:		wl_clr_drv_status(wl, SCANNING, iter->ndev);
wl_cfg80211.c:3585:		wl_clr_drv_status(wl, SCAN_ABORTING, iter->ndev);
wl_cfg80211.c:3587:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:3589:		if (wl_get_drv_status(wl, CONNECTING, iter->ndev)) {
wl_cfg80211.c:3590:			wl_bss_connect_done(wl, iter->ndev, NULL, NULL, false);
wl_cfg80211.c:3607:		return -EINVAL;
wl_cfg80211.c:3610:	 * Refer code wlc_bsscfg.c->wlc_bsscfg_sta_init
wl_cfg80211.c:3618:	WL_DBG(("No of elements %d\n", pmk_list->pmkids.npmkid));
wl_cfg80211.c:3619:	for (i = 0; i < pmk_list->pmkids.npmkid; i++) {
wl_cfg80211.c:3621:			&pmk_list->pmkids.pmkid[i].BSSID));
wl_cfg80211.c:3623:			WL_DBG(("%02x\n", pmk_list->pmkids.pmkid[i].PMKID[j]));
wl_cfg80211.c:3628:			sizeof(*pmk_list), wl->ioctl_buf, WLC_IOCTL_MAXLEN, NULL);
wl_cfg80211.c:3643:	for (i = 0; i < wl->pmk_list->pmkids.npmkid; i++)
wl_cfg80211.c:3644:		if (!memcmp(pmksa->bssid, &wl->pmk_list->pmkids.pmkid[i].BSSID,
wl_cfg80211.c:3648:		memcpy(&wl->pmk_list->pmkids.pmkid[i].BSSID, pmksa->bssid,
wl_cfg80211.c:3650:		memcpy(&wl->pmk_list->pmkids.pmkid[i].PMKID, pmksa->pmkid,
wl_cfg80211.c:3652:		if (i == wl->pmk_list->pmkids.npmkid)
wl_cfg80211.c:3653:			wl->pmk_list->pmkids.npmkid++;
wl_cfg80211.c:3655:		err = -EINVAL;
wl_cfg80211.c:3657:	WL_DBG(("set_pmksa,IW_PMKSA_ADD - PMKID: %pM =\n",
wl_cfg80211.c:3658:		&wl->pmk_list->pmkids.pmkid[wl->pmk_list->pmkids.npmkid - 1].BSSID));
wl_cfg80211.c:3661:			wl->pmk_list->pmkids.pmkid[wl->pmk_list->pmkids.npmkid - 1].
wl_cfg80211.c:3665:	err = wl_update_pmklist(dev, wl->pmk_list, err);
wl_cfg80211.c:3680:	memcpy(&pmkid.pmkid[0].BSSID, pmksa->bssid, ETHER_ADDR_LEN);
wl_cfg80211.c:3681:	memcpy(pmkid.pmkid[0].PMKID, pmksa->pmkid, WPA2_PMKID_LEN);
wl_cfg80211.c:3683:	WL_DBG(("del_pmksa,IW_PMKSA_REMOVE - PMKID: %pM =\n",
wl_cfg80211.c:3689:	for (i = 0; i < wl->pmk_list->pmkids.npmkid; i++)
wl_cfg80211.c:3691:		    (pmksa->bssid, &wl->pmk_list->pmkids.pmkid[i].BSSID,
wl_cfg80211.c:3695:	if ((wl->pmk_list->pmkids.npmkid > 0) &&
wl_cfg80211.c:3696:		(i < wl->pmk_list->pmkids.npmkid)) {
wl_cfg80211.c:3697:		memset(&wl->pmk_list->pmkids.pmkid[i], 0, sizeof(pmkid_t));
wl_cfg80211.c:3698:		for (; i < (wl->pmk_list->pmkids.npmkid - 1); i++) {
wl_cfg80211.c:3699:			memcpy(&wl->pmk_list->pmkids.pmkid[i].BSSID,
wl_cfg80211.c:3700:				&wl->pmk_list->pmkids.pmkid[i + 1].BSSID,
wl_cfg80211.c:3702:			memcpy(&wl->pmk_list->pmkids.pmkid[i].PMKID,
wl_cfg80211.c:3703:				&wl->pmk_list->pmkids.pmkid[i + 1].PMKID,
wl_cfg80211.c:3706:		wl->pmk_list->pmkids.npmkid--;
wl_cfg80211.c:3708:		err = -EINVAL;
wl_cfg80211.c:3711:	err = wl_update_pmklist(dev, wl->pmk_list, err);
wl_cfg80211.c:3723:	memset(wl->pmk_list, 0, sizeof(*wl->pmk_list));
wl_cfg80211.c:3724:	err = wl_update_pmklist(dev, wl->pmk_list, err);
wl_cfg80211.c:3746:	params->nprobes = nprobes;
wl_cfg80211.c:3750:	memcpy(&params->bssid, &ether_bcast, ETHER_ADDR_LEN);
wl_cfg80211.c:3751:	params->bss_type = DOT11_BSSTYPE_ANY;
wl_cfg80211.c:3752:	params->scan_type = DOT11_SCANTYPE_ACTIVE;
wl_cfg80211.c:3753:	params->nprobes = htod32(1);
wl_cfg80211.c:3754:	params->active_time = htod32(-1);
wl_cfg80211.c:3755:	params->passive_time = htod32(-1);
wl_cfg80211.c:3756:	params->home_time = htod32(10);
wl_cfg80211.c:3757:	if (channel == -1)
wl_cfg80211.c:3758:		params->channel_list[0] = htodchanspec(channel);
wl_cfg80211.c:3760:		params->channel_list[0] = wl_ch_host_to_driver(channel);
wl_cfg80211.c:3763:	params->channel_num = htod32((0 << WL_SCAN_PARAMS_NSSID_SHIFT) |
wl_cfg80211.c:3785:		dev->ifindex, ieee80211_frequency_to_channel(channel->center_freq),
wl_cfg80211.c:3788:	if (wl->p2p_net == dev) {
wl_cfg80211.c:3794:	if (!wl->p2p) {
wl_cfg80211.c:3795:		WL_ERR(("wl->p2p is not initialized\n"));
wl_cfg80211.c:3806:	target_channel = ieee80211_frequency_to_channel(channel->center_freq);
wl_cfg80211.c:3807:	memcpy(&wl->remain_on_chan, channel, sizeof(struct ieee80211_channel));
wl_cfg80211.c:3808:	wl->remain_on_chan_type = channel_type;
wl_cfg80211.c:3809:	id = ++wl->last_roc_id;
wl_cfg80211.c:3811:		id = ++wl->last_roc_id;
wl_cfg80211.c:3821:		if (timer_pending(&wl->p2p->listen_timer)) {
wl_cfg80211.c:3823:			del_timer_sync(&wl->p2p->listen_timer);
wl_cfg80211.c:3826:		_timer = &wl->p2p->listen_timer;
wl_cfg80211.c:3849:	if (wl->p2p && !wl->p2p->on) {
wl_cfg80211.c:3854:		wl_cfgp2p_generate_bss_mac(&primary_mac, &wl->p2p->dev_addr, &wl->p2p->int_addr);
wl_cfg80211.c:3900:	WL_DBG((" enter ) netdev_ifidx: %d \n", dev->ifindex));
wl_cfg80211.c:3912:	if (afx_instance != NULL && wl->afx_hdl->is_active) {
wl_cfg80211.c:3913:		if (wl->afx_hdl->is_listen && wl->afx_hdl->my_listen_chan) {
wl_cfg80211.c:3914:			ret = wl_cfgp2p_discover_listen(wl, wl->afx_hdl->my_listen_chan,
wl_cfg80211.c:3917:			ret = wl_cfgp2p_act_frm_search(wl, wl->afx_hdl->dev,
wl_cfg80211.c:3918:				wl->afx_hdl->bssidx, wl->afx_hdl->peer_listen_chan);
wl_cfg80211.c:3923:				complete(&wl->act_frm_scan);
wl_cfg80211.c:3934:		return -1;
wl_cfg80211.c:3939:	wl->afx_hdl->is_active = TRUE;
wl_cfg80211.c:3944:	while ((wl->afx_hdl->retry < max_retry) &&
wl_cfg80211.c:3945:		(wl->afx_hdl->peer_chan == WL_INVALID)) {
wl_cfg80211.c:3946:		wl->afx_hdl->is_listen = FALSE;
wl_cfg80211.c:3949:			wl->afx_hdl->retry));
wl_cfg80211.c:3951:		schedule_work(&wl->afx_hdl->work);
wl_cfg80211.c:3952:		wait_for_completion_timeout(&wl->act_frm_scan,
wl_cfg80211.c:3955:		if ((wl->afx_hdl->peer_chan != WL_INVALID) ||
wl_cfg80211.c:3959:		if (wl->afx_hdl->my_listen_chan) {
wl_cfg80211.c:3961:				wl->afx_hdl->my_listen_chan));
wl_cfg80211.c:3963:			wl->afx_hdl->is_listen = TRUE;
wl_cfg80211.c:3964:			schedule_work(&wl->afx_hdl->work);
wl_cfg80211.c:3965:			wait_for_completion_timeout(&wl->act_frm_scan,
wl_cfg80211.c:3970:		wl->afx_hdl->retry++;
wl_cfg80211.c:3975:	wl->afx_hdl->is_active = FALSE;
wl_cfg80211.c:3980:	return (wl->afx_hdl->peer_chan);
wl_cfg80211.c:3986:	 * 0: off, 1: on,  (-1): do nothing
wl_cfg80211.c:4003:		(wifi_p2p_pub_act_frame_t *) (action_frame->data);
wl_cfg80211.c:4007:	config_af_params->extra_listen = true;
wl_cfg80211.c:4009:	config_af_params->search_channel = false;
wl_cfg80211.c:4010:	config_af_params->max_tx_retry = WL_AF_TX_MAX_RETRY;
wl_cfg80211.c:4011:	config_af_params->mpc_onoff = -1;
wl_cfg80211.c:4013:	switch (act_frm->subtype) {
wl_cfg80211.c:4018:		config_af_params->mpc_onoff = 0;
wl_cfg80211.c:4019:		config_af_params->search_channel = true;
wl_cfg80211.c:4020:		wl->next_af_subtype = act_frm->subtype + 1;
wl_cfg80211.c:4023:		af_params->dwell_time = WL_MED_DWELL_TIME;
wl_cfg80211.c:4028:		wl->next_af_subtype = act_frm->subtype + 1;
wl_cfg80211.c:4030:		af_params->dwell_time = WL_MED_DWELL_TIME;
wl_cfg80211.c:4039:		config_af_params->mpc_onoff = 1;
wl_cfg80211.c:4042:		af_params->dwell_time = WL_MIN_DWELL_TIME;
wl_cfg80211.c:4045:		config_af_params->extra_listen = false;
wl_cfg80211.c:4050:		config_af_params->search_channel = true;
wl_cfg80211.c:4051:		wl->next_af_subtype = act_frm->subtype + 1;
wl_cfg80211.c:4054:		af_params->dwell_time = WL_MED_DWELL_TIME;
wl_cfg80211.c:4059:		af_params->dwell_time = WL_MIN_DWELL_TIME;
wl_cfg80211.c:4061:		config_af_params->extra_listen = false;
wl_cfg80211.c:4065:		config_af_params->search_channel = true;
wl_cfg80211.c:4067:		wl->next_af_subtype = act_frm->subtype + 1;
wl_cfg80211.c:4069:		af_params->dwell_time = WL_LONG_DWELL_TIME;
wl_cfg80211.c:4074:		af_params->dwell_time = WL_MIN_DWELL_TIME;
wl_cfg80211.c:4076:		config_af_params->extra_listen = false;
wl_cfg80211.c:4080:		if (IS_PROV_DISC_WITHOUT_GROUP_ID(&act_frm->elts[0],
wl_cfg80211.c:4081:			action_frame->len)) {
wl_cfg80211.c:4082:			config_af_params->search_channel = true;
wl_cfg80211.c:4085:		config_af_params->mpc_onoff = 0;
wl_cfg80211.c:4086:		wl->next_af_subtype = act_frm->subtype + 1;
wl_cfg80211.c:4088:		af_params->dwell_time = WL_MED_DWELL_TIME;
wl_cfg80211.c:4092:		wl->next_af_subtype = P2P_PAF_GON_REQ;
wl_cfg80211.c:4094:		af_params->dwell_time = WL_MED_DWELL_TIME;
wl_cfg80211.c:4096:		config_af_params->extra_listen = false;
wl_cfg80211.c:4102:			act_frm->subtype));
wl_cfg80211.c:4122:	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
wl_cfg80211.c:4124:	wl_cfgp2p_print_actframe(true, action_frame->data, action_frame->len);
wl_cfg80211.c:4126:	category = action_frame->data[DOT11_ACTION_CAT_OFF];
wl_cfg80211.c:4127:	action = action_frame->data[DOT11_ACTION_ACT_OFF];
wl_cfg80211.c:4131:	wl->next_af_subtype = P2P_PAF_SUBTYPE_INVALID;
wl_cfg80211.c:4133:	config_af_params.mpc_onoff = -1;
wl_cfg80211.c:4140:	/* Public Action Frame Process - DOT11_ACTION_CAT_PUBLIC */
wl_cfg80211.c:4159:				wl->next_af_subtype = action + 1;
wl_cfg80211.c:4161:				af_params->dwell_time = WL_MED_DWELL_TIME;
wl_cfg80211.c:4165:				af_params->dwell_time = WL_MIN_DWELL_TIME;
wl_cfg80211.c:4178:		if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
wl_cfg80211.c:4190:	if (config_af_params.search_channel && IS_P2P_SOCIAL(af_params->channel) &&
wl_cfg80211.c:4215:	if (wl->next_af_subtype != P2P_PAF_SUBTYPE_INVALID) {
wl_cfg80211.c:4220:	memcpy(wl->afx_hdl->tx_dst_addr.octet,
wl_cfg80211.c:4221:		af_params->action_frame.da.octet,
wl_cfg80211.c:4222:		sizeof(wl->afx_hdl->tx_dst_addr.octet));
wl_cfg80211.c:4225:	wl->afx_hdl->pending_tx_act_frm = af_params;
wl_cfg80211.c:4230:		wl->afx_hdl->bssidx = wl_cfgp2p_find_idx(wl, dev);
wl_cfg80211.c:4231:		wl->afx_hdl->dev = dev;
wl_cfg80211.c:4232:		wl->afx_hdl->retry = 0;
wl_cfg80211.c:4233:		wl->afx_hdl->peer_chan = WL_INVALID;
wl_cfg80211.c:4240:		/* Suspend P2P discovery's search-listen to prevent it from
wl_cfg80211.c:4243:		wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
wl_cfg80211.c:4251:		af_params->channel = wl->afx_hdl->peer_chan;
wl_cfg80211.c:4264:		if (af_params->channel) {
wl_cfg80211.c:4265:			if (jiffies_to_msecs(jiffies - off_chan_started_jiffies) >
wl_cfg80211.c:4289:		wl->af_sent_channel == wl->afx_hdl->my_listen_chan) {
wl_cfg80211.c:4292:		extar_listen_time = af_params->dwell_time -
wl_cfg80211.c:4293:			jiffies_to_msecs(jiffies - wl->af_tx_sent_jiffies);
wl_cfg80211.c:4299:				af_params->dwell_time, extar_listen_time));
wl_cfg80211.c:4300:			if (wl_cfgp2p_discover_listen(wl, wl->af_sent_channel,
wl_cfg80211.c:4302:				wait_for_completion_timeout(&wl->wait_next_af,
wl_cfg80211.c:4311:	if (wl->afx_hdl->pending_tx_act_frm)
wl_cfg80211.c:4312:		wl->afx_hdl->pending_tx_act_frm = NULL;
wl_cfg80211.c:4314:	WL_INFO(("-- sending Action Frame is %s, listen chan: %d\n",
wl_cfg80211.c:4315:		(ack) ? "Succeeded!!":"Failed!!", wl->afx_hdl->my_listen_chan));
wl_cfg80211.c:4354:	if (ndev == wl->p2p_net) {
wl_cfg80211.c:4363:	if (bssidx == -1) {
wl_cfg80211.c:4366:		return -ENODEV;
wl_cfg80211.c:4369:		/* Suspend P2P discovery search-listen to prevent it from changing the
wl_cfg80211.c:4374:			return -EFAULT;
wl_cfg80211.c:4378:	id = wl->send_action_id++;
wl_cfg80211.c:4380:		id = wl->send_action_id++;
wl_cfg80211.c:4383:	if (ieee80211_is_mgmt(mgmt->frame_control)) {
wl_cfg80211.c:4384:		if (ieee80211_is_probe_resp(mgmt->frame_control)) {
wl_cfg80211.c:4386:			s32 ie_len = len - ie_offset;
wl_cfg80211.c:4393:		} else if (ieee80211_is_disassoc(mgmt->frame_control) ||
wl_cfg80211.c:4394:			ieee80211_is_deauth(mgmt->frame_control)) {
wl_cfg80211.c:4395:			memcpy(scb_val.ea.octet, mgmt->da, ETH_ALEN);
wl_cfg80211.c:4396:			scb_val.val = mgmt->u.disassoc.reason_code;
wl_cfg80211.c:4402:				bcm_ether_ntoa((const struct ether_addr *)mgmt->da, eabuf),
wl_cfg80211.c:4408:		} else if (ieee80211_is_action(mgmt->frame_control)) {
wl_cfg80211.c:4409:			/* Abort the dwell time of any previous off-channel
wl_cfg80211.c:4411:			* off-channel action frames relies on the driver's
wl_cfg80211.c:4412:			* scan engine.  If a previous off-channel action frame
wl_cfg80211.c:4417: * And previous off-channel action frame must be ended before new af tx.
wl_cfg80211.c:4434:		return -ENOMEM;
wl_cfg80211.c:4437:	action_frame = &af_params->action_frame;
wl_cfg80211.c:4440:	action_frame->packetId = *cookie;
wl_cfg80211.c:4441:	WL_DBG(("action frame %d\n", action_frame->packetId));
wl_cfg80211.c:4443:	memcpy(&action_frame->da, &mgmt->da[0], ETHER_ADDR_LEN);
wl_cfg80211.c:4444:	memcpy(&af_params->BSSID, &mgmt->bssid[0], ETHER_ADDR_LEN);
wl_cfg80211.c:4447:	action_frame->len = len - DOT11_MGMT_HDR_LEN;
wl_cfg80211.c:4448:	WL_DBG(("action_frame->len: %d\n", action_frame->len));
wl_cfg80211.c:4451:	af_params->channel =
wl_cfg80211.c:4452:		ieee80211_frequency_to_channel(channel->center_freq);
wl_cfg80211.c:4455:	wl->afx_hdl->peer_listen_chan = af_params->channel;
wl_cfg80211.c:4456:	WL_DBG(("channel from upper layer %d\n", wl->afx_hdl->peer_listen_chan));
wl_cfg80211.c:4459:	 * Dwell time to stay off-channel to wait for a response action frame
wl_cfg80211.c:4462:	af_params->dwell_time = WL_DWELL_TIME;
wl_cfg80211.c:4464:	memcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN], action_frame->len);
wl_cfg80211.c:4467:		action_frame, action_frame->len, bssidx);
wl_cfg80211.c:4496:	if (params->use_cts_prot >= 0) {
wl_cfg80211.c:4499:	if (params->use_short_preamble >= 0) {
wl_cfg80211.c:4502:	if (params->use_short_slot_time >= 0) {
wl_cfg80211.c:4505:	if (params->basic_rates) {
wl_cfg80211.c:4508:	if (params->ap_isolate >= 0) {
wl_cfg80211.c:4511:	if (params->ht_opmode >= 0) {
wl_cfg80211.c:4535:	if (wl->p2p_net == dev) {
wl_cfg80211.c:4538:	_chan = ieee80211_frequency_to_channel(chan->center_freq);
wl_cfg80211.c:4540:		dev->ifindex, channel_type, _chan));
wl_cfg80211.c:4543:	if (chan->band == IEEE80211_BAND_5GHZ) {
wl_cfg80211.c:4546:			wl->ioctl_buf, WLC_IOCTL_SMLEN, &wl->ioctl_buf_sync);
wl_cfg80211.c:4560:			if (WL_BW_CAP_80MHZ(wl->ioctl_buf[0]))
wl_cfg80211.c:4562:			else if (WL_BW_CAP_40MHZ(wl->ioctl_buf[0]))
wl_cfg80211.c:4569:	} else if (chan->band == IEEE80211_BAND_2GHZ)
wl_cfg80211.c:4626:	/* set upper-layer auth */
wl_cfg80211.c:4658:	len =  wpa2ie->len;
wl_cfg80211.c:4660:	mcast = (wpa_suite_mcast_t *)&wpa2ie->data[WPA2_VERSION_LEN];
wl_cfg80211.c:4661:	switch (mcast->type) {
wl_cfg80211.c:4679:	if ((len -= WPA_SUITE_LEN) <= 0)
wl_cfg80211.c:4684:	suite_count = ltoh16_ua(&ucast->count);
wl_cfg80211.c:4685:	switch (ucast->list[0].type) {
wl_cfg80211.c:4702:	if ((len -= (WPA_IE_SUITE_COUNT_LEN + (WPA_SUITE_LEN * suite_count))) <= 0)
wl_cfg80211.c:4708:	mgmt = (wpa_suite_auth_key_mgmt_t *)&ucast->list[suite_count];
wl_cfg80211.c:4709:	suite_count = ltoh16_ua(&mgmt->count);
wl_cfg80211.c:4710:	switch (mgmt->list[0].type) {
wl_cfg80211.c:4724:	if ((len -= (WPA_IE_SUITE_COUNT_LEN + (WPA_SUITE_LEN * suite_count))) >= RSN_CAP_LEN) {
wl_cfg80211.c:4725:		rsn_cap[0] = *(u8 *)&mgmt->list[suite_count];
wl_cfg80211.c:4726:		rsn_cap[1] = *((u8 *)&mgmt->list[suite_count] + 1);
wl_cfg80211.c:4756:	/* set upper-layer auth */
wl_cfg80211.c:4786:	len = wpaie->length;    /* value length */
wl_cfg80211.c:4787:	len -= WPA_IE_TAG_FIXED_LEN;
wl_cfg80211.c:4796:	len -= WPA_SUITE_LEN;
wl_cfg80211.c:4797:	if (!bcmp(mcast->oui, WPA_OUI, WPA_OUI_LEN)) {
wl_cfg80211.c:4798:		if (IS_WPA_CIPHER(mcast->type)) {
wl_cfg80211.c:4800:			switch (mcast->type) {
wl_cfg80211.c:4827:	count = ltoh16_ua(&ucast->count);
wl_cfg80211.c:4828:	len -= WPA_IE_SUITE_COUNT_LEN;
wl_cfg80211.c:4830:		i++, len -= WPA_SUITE_LEN) {
wl_cfg80211.c:4831:		if (!bcmp(ucast->list[i].oui, WPA_OUI, WPA_OUI_LEN)) {
wl_cfg80211.c:4832:			if (IS_WPA_CIPHER(ucast->list[i].type)) {
wl_cfg80211.c:4834:				switch (ucast->list[i].type) {
wl_cfg80211.c:4855:	len -= (count - i) * WPA_SUITE_LEN;
wl_cfg80211.c:4862:	mgmt = (wpa_suite_auth_key_mgmt_t *)&ucast->list[count];
wl_cfg80211.c:4863:	count = ltoh16_ua(&mgmt->count);
wl_cfg80211.c:4864:	len -= WPA_IE_SUITE_COUNT_LEN;
wl_cfg80211.c:4866:		i++, len -= WPA_SUITE_LEN) {
wl_cfg80211.c:4867:		if (!bcmp(mgmt->list[i].oui, WPA_OUI, WPA_OUI_LEN)) {
wl_cfg80211.c:4868:			if (IS_WPA_AKM(mgmt->list[i].type)) {
wl_cfg80211.c:4870:				switch (mgmt->list[i].type) {
wl_cfg80211.c:4902:	/* set upper-layer auth */
wl_cfg80211.c:4921:	if (dev_role == NL80211_IFTYPE_P2P_GO && (ies->wpa2_ie)) {
wl_cfg80211.c:4922:		/* For P2P GO, the sec type is WPA2-PSK */
wl_cfg80211.c:4924:		if (wl_validate_wpa2ie(dev, ies->wpa2_ie, bssidx)  < 0)
wl_cfg80211.c:4931:		if ((ies->wpa2_ie || ies->wpa_ie) &&
wl_cfg80211.c:4932:			((wl_validate_wpa2ie(dev, ies->wpa2_ie, bssidx)  < 0 ||
wl_cfg80211.c:4933:			wl_validate_wpaie(dev, ies->wpa_ie, bssidx) < 0))) {
wl_cfg80211.c:4934:			wl->ap_info->security_mode = false;
wl_cfg80211.c:4938:		wl->ap_info->security_mode = true;
wl_cfg80211.c:4939:		if (wl->ap_info->rsn_ie) {
wl_cfg80211.c:4940:			kfree(wl->ap_info->rsn_ie);
wl_cfg80211.c:4941:			wl->ap_info->rsn_ie = NULL;
wl_cfg80211.c:4943:		if (wl->ap_info->wpa_ie) {
wl_cfg80211.c:4944:			kfree(wl->ap_info->wpa_ie);
wl_cfg80211.c:4945:			wl->ap_info->wpa_ie = NULL;
wl_cfg80211.c:4947:		if (wl->ap_info->wps_ie) {
wl_cfg80211.c:4948:			kfree(wl->ap_info->wps_ie);
wl_cfg80211.c:4949:			wl->ap_info->wps_ie = NULL;
wl_cfg80211.c:4951:		if (ies->wpa_ie != NULL) {
wl_cfg80211.c:4953:			wl->ap_info->rsn_ie = NULL;
wl_cfg80211.c:4954:			wl->ap_info->wpa_ie = kmemdup(ies->wpa_ie,
wl_cfg80211.c:4955:				ies->wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
wl_cfg80211.c:4957:		} else if (ies->wpa2_ie != NULL) {
wl_cfg80211.c:4959:			wl->ap_info->wpa_ie = NULL;
wl_cfg80211.c:4960:			wl->ap_info->rsn_ie = kmemdup(ies->wpa2_ie,
wl_cfg80211.c:4961:				ies->wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
wl_cfg80211.c:4965:		if (!ies->wpa2_ie && !ies->wpa_ie) {
wl_cfg80211.c:4967:			wl->ap_info->security_mode = false;
wl_cfg80211.c:4970:		if (ies->wps_ie) {
wl_cfg80211.c:4971:			wl->ap_info->wps_ie = kmemdup(ies->wps_ie, ies->wps_ie_len, GFP_KERNEL);
wl_cfg80211.c:4989:		info->beacon_interval, info->dtim_period));
wl_cfg80211.c:4991:	if (info->beacon_interval) {
wl_cfg80211.c:4993:			&info->beacon_interval, sizeof(s32), true)) < 0) {
wl_cfg80211.c:4999:	if (info->dtim_period) {
wl_cfg80211.c:5001:			&info->dtim_period, sizeof(s32), true)) < 0) {
wl_cfg80211.c:5007:	if ((info->ssid) && (info->ssid_len > 0) &&
wl_cfg80211.c:5008:		(info->ssid_len <= 32)) {
wl_cfg80211.c:5009:		WL_DBG(("SSID (%s) len:%d \n", info->ssid, info->ssid_len));
wl_cfg80211.c:5012:			memset(wl->hostapd_ssid.SSID, 0x00, 32);
wl_cfg80211.c:5013:			memcpy(wl->hostapd_ssid.SSID, info->ssid, info->ssid_len);
wl_cfg80211.c:5014:			wl->hostapd_ssid.SSID_len = info->ssid_len;
wl_cfg80211.c:5017:			memset(wl->p2p->ssid.SSID, 0x00, 32);
wl_cfg80211.c:5018:			memcpy(wl->p2p->ssid.SSID, info->ssid, info->ssid_len);
wl_cfg80211.c:5019:			wl->p2p->ssid.SSID_len = info->ssid_len;
wl_cfg80211.c:5023:	if (info->hidden_ssid) {
wl_cfg80211.c:5026:		WL_DBG(("hidden_ssid_enum_val: %d \n", info->hidden_ssid));
wl_cfg80211.c:5041:	if ((ies->wps_ie = wl_cfgp2p_find_wpsie(ptr, len)) != NULL) {
wl_cfg80211.c:5043:		ies->wps_ie_len = ies->wps_ie->length + WPA_RSN_IE_TAG_FIXED_LEN;
wl_cfg80211.c:5049:	if ((ies->wpa2_ie = bcm_parse_tlvs(ptr, len,
wl_cfg80211.c:5052:		ies->wpa2_ie_len = ies->wpa2_ie->len;
wl_cfg80211.c:5056:	if ((ies->wpa_ie = wl_cfgp2p_find_wpaie(ptr, len)) != NULL) {
wl_cfg80211.c:5058:		ies->wpa_ie_len = ies->wpa_ie->length;
wl_cfg80211.c:5086:		if (!is_bssup && (ies->wpa2_ie != NULL)) {
wl_cfg80211.c:5094:			err = wldev_iovar_setbuf_bsscfg(dev, "ssid", &wl->p2p->ssid,
wl_cfg80211.c:5095:				sizeof(wl->p2p->ssid), wl->ioctl_buf, WLC_IOCTL_MAXLEN,
wl_cfg80211.c:5096:				bssidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:5135:		memcpy(join_params.ssid.SSID, wl->hostapd_ssid.SSID,
wl_cfg80211.c:5136:			wl->hostapd_ssid.SSID_len);
wl_cfg80211.c:5137:		join_params.ssid.SSID_len = htod32(wl->hostapd_ssid.SSID_len);
wl_cfg80211.c:5170:	if (wl_cfg80211_parse_ies((u8 *)info->tail,
wl_cfg80211.c:5171:		info->tail_len, ies) < 0) {
wl_cfg80211.c:5173:		err = -EINVAL;
wl_cfg80211.c:5179:		VNDR_IE_BEACON_FLAG, (u8 *)info->tail,
wl_cfg80211.c:5180:		info->tail_len)) < 0) {
wl_cfg80211.c:5187:	if (wl_cfg80211_parse_ies((u8 *)info->proberesp_ies,
wl_cfg80211.c:5188:		info->proberesp_ies_len, &prb_ies) < 0) {
wl_cfg80211.c:5190:		err = -EINVAL;
wl_cfg80211.c:5196:		VNDR_IE_PRBRSP_FLAG, (u8 *)info->proberesp_ies,
wl_cfg80211.c:5197:		info->proberesp_ies_len)) < 0) {
wl_cfg80211.c:5218:	if (ies->wps_ie) {
wl_cfg80211.c:5219:		if (wl->ap_info->wps_ie &&
wl_cfg80211.c:5220:			memcmp(wl->ap_info->wps_ie, ies->wps_ie, ies->wps_ie_len)) {
wl_cfg80211.c:5222:			kfree(wl->ap_info->wps_ie);
wl_cfg80211.c:5223:			wl->ap_info->wps_ie = kmemdup(ies->wps_ie, ies->wps_ie_len, GFP_KERNEL);
wl_cfg80211.c:5224:		} else if (wl->ap_info->wps_ie == NULL) {
wl_cfg80211.c:5226:			wl->ap_info->wps_ie = kmemdup(ies->wps_ie, ies->wps_ie_len, GFP_KERNEL);
wl_cfg80211.c:5228:		if ((ies->wpa_ie != NULL || ies->wpa2_ie != NULL)) {
wl_cfg80211.c:5229:			if (!wl->ap_info->security_mode) {
wl_cfg80211.c:5232:				if (ies->wpa_ie != NULL) {
wl_cfg80211.c:5233:					wl->ap_info->wpa_ie = kmemdup(ies->wpa_ie,
wl_cfg80211.c:5234:					ies->wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
wl_cfg80211.c:5237:					wl->ap_info->rsn_ie = kmemdup(ies->wpa2_ie,
wl_cfg80211.c:5238:					ies->wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
wl_cfg80211.c:5241:			} else if (wl->ap_info->wpa_ie) {
wl_cfg80211.c:5243:				if (ies->wpa_ie != NULL) {
wl_cfg80211.c:5245:					kfree(wl->ap_info->rsn_ie);
wl_cfg80211.c:5246:					wl->ap_info->rsn_ie = NULL;
wl_cfg80211.c:5247:					wl->ap_info->wpa_ie = kmemdup(ies->wpa_ie,
wl_cfg80211.c:5248:					ies->wpa_ie->length + WPA_RSN_IE_TAG_FIXED_LEN,
wl_cfg80211.c:5250:				} else if (memcmp(wl->ap_info->rsn_ie,
wl_cfg80211.c:5251:					ies->wpa2_ie, ies->wpa2_ie->len
wl_cfg80211.c:5254:					kfree(wl->ap_info->rsn_ie);
wl_cfg80211.c:5255:					wl->ap_info->rsn_ie = kmemdup(ies->wpa2_ie,
wl_cfg80211.c:5256:					ies->wpa2_ie->len + WPA_RSN_IE_TAG_FIXED_LEN,
wl_cfg80211.c:5258:					wl->ap_info->wpa_ie = NULL;
wl_cfg80211.c:5262:				wl->ap_info->security_mode = true;
wl_cfg80211.c:5264:				if (wl_validate_wpa2ie(dev, ies->wpa2_ie, bssidx)  < 0 ||
wl_cfg80211.c:5265:					wl_validate_wpaie(dev, ies->wpa_ie, bssidx) < 0) {
wl_cfg80211.c:5296:	if (ndev == wl->p2p_net) {
wl_cfg80211.c:5303:		/* Suspend P2P discovery search-listen to prevent it from changing the
wl_cfg80211.c:5308:			return -EFAULT;
wl_cfg80211.c:5342:	} else if (dev == wl->p2p_net) {
wl_cfg80211.c:5364:	if ((err = wl_cfg80211_parse_set_ies(dev, &info->beacon,
wl_cfg80211.c:5409:	} else if (dev == wl->p2p_net) {
wl_cfg80211.c:5428:			err = -ENOTSUPP;
wl_cfg80211.c:5433:			err = -ENOTSUPP;
wl_cfg80211.c:5440:			err = -EINVAL;
wl_cfg80211.c:5471:	} else if (dev == wl->p2p_net) {
wl_cfg80211.c:5494:			err = -EINVAL;
wl_cfg80211.c:5517:		info->interval, info->dtim_period, info->head_len, info->tail_len));
wl_cfg80211.c:5521:	} else if (dev == wl->p2p_net) {
wl_cfg80211.c:5536:	if ((ssid_ie = bcm_parse_tlvs((u8 *)&info->head[ie_offset],
wl_cfg80211.c:5537:		info->head_len - ie_offset,
wl_cfg80211.c:5541:			memset(&wl->hostapd_ssid.SSID[0], 0x00, 32);
wl_cfg80211.c:5542:			memcpy(&wl->hostapd_ssid.SSID[0], ssid_ie->data, ssid_ie->len);
wl_cfg80211.c:5543:			wl->hostapd_ssid.SSID_len = ssid_ie->len;
wl_cfg80211.c:5546:			memset(&wl->p2p->ssid.SSID[0], 0x00, 32);
wl_cfg80211.c:5547:			memcpy(wl->p2p->ssid.SSID, ssid_ie->data, ssid_ie->len);
wl_cfg80211.c:5548:			wl->p2p->ssid.SSID_len = ssid_ie->len;
wl_cfg80211.c:5552:	if (wl_cfg80211_parse_ies((u8 *)info->tail,
wl_cfg80211.c:5553:		info->tail_len, &ies) < 0) {
wl_cfg80211.c:5555:		err = -EINVAL;
wl_cfg80211.c:5560:		VNDR_IE_BEACON_FLAG, (u8 *)info->tail,
wl_cfg80211.c:5561:		info->tail_len) < 0) {
wl_cfg80211.c:5575:	if (info->interval) {
wl_cfg80211.c:5577:			&info->interval, sizeof(s32), true)) < 0) {
wl_cfg80211.c:5582:	if (info->dtim_period) {
wl_cfg80211.c:5584:			&info->dtim_period, sizeof(s32), true)) < 0) {
wl_cfg80211.c:5599:			err = -EINVAL;
wl_cfg80211.c:5645:		request->n_match_sets, request->n_ssids));
wl_cfg80211.c:5647:		request->n_ssids, pno_time, pno_repeat, pno_freq_expo_max));
wl_cfg80211.c:5650:	if (!request || !request->n_ssids || !request->n_match_sets) {
wl_cfg80211.c:5651:		WL_ERR(("Invalid sched scan req!! n_ssids:%d \n", request->n_ssids));
wl_cfg80211.c:5652:		return -EINVAL;
wl_cfg80211.c:5657:	if (request->n_match_sets > 0) {
wl_cfg80211.c:5658:		for (i = 0; i < request->n_match_sets; i++) {
wl_cfg80211.c:5659:			ssid = &request->match_sets[i].ssid;
wl_cfg80211.c:5660:			memcpy(ssids_local[i].SSID, ssid->ssid, ssid->ssid_len);
wl_cfg80211.c:5661:			ssids_local[i].SSID_len = ssid->ssid_len;
wl_cfg80211.c:5662:			WL_PNO((">>> PNO filter set for ssid (%s) \n", ssid->ssid));
wl_cfg80211.c:5667:	if (request->n_ssids > 0) {
wl_cfg80211.c:5668:		for (i = 0; i < request->n_ssids; i++) {
wl_cfg80211.c:5670:			WL_PNO((">>> Active scan req for ssid (%s) \n", request->ssids[i].ssid));
wl_cfg80211.c:5679:		if ((ret = dhd_dev_pno_set(dev, ssids_local, request->n_match_sets,
wl_cfg80211.c:5682:			return -EINVAL;
wl_cfg80211.c:5688:			return -EINVAL;
wl_cfg80211.c:5690:		wl->sched_scan_req = request;
wl_cfg80211.c:5692:		return -EINVAL;
wl_cfg80211.c:5711:	if (wl->scan_request && wl->sched_scan_running) {
wl_cfg80211.c:5716:	 wl->sched_scan_req = NULL;
wl_cfg80211.c:5717:	 wl->sched_scan_running = FALSE;
wl_cfg80211.c:5801:		return -EINVAL;
wl_cfg80211.c:5805:		request->alpha2[0], request->alpha2[1], request->initiator));
wl_cfg80211.c:5808:	if (request->initiator != NL80211_REGDOM_SET_BY_USER) {
wl_cfg80211.c:5810:			request->initiator));
wl_cfg80211.c:5811:		return -ENOTSUPP;
wl_cfg80211.c:5814:	if (request->alpha2[0] == '0' && request->alpha2[1] == '0') {
wl_cfg80211.c:5820:		memcpy(cspec.country_abbrev, request->alpha2, 2);
wl_cfg80211.c:5822:		cspec.rev = -1; /* Unspecified */
wl_cfg80211.c:5826:		sizeof(cspec), wl->ioctl_buf, WLC_IOCTL_SMLEN, NULL)) < 0) {
wl_cfg80211.c:5846:	wdev->wiphy =
wl_cfg80211.c:5848:	if (unlikely(!wdev->wiphy)) {
wl_cfg80211.c:5850:		err = -ENOMEM;
wl_cfg80211.c:5853:	set_wiphy_dev(wdev->wiphy, sdiofunc_dev);
wl_cfg80211.c:5854:	wdev->wiphy->max_scan_ie_len = WL_SCAN_IE_LEN_MAX;
wl_cfg80211.c:5856:	wdev->wiphy->max_scan_ssids = WL_SCAN_PARAMS_SSID_MAX;
wl_cfg80211.c:5857:	wdev->wiphy->max_num_pmkids = WL_NUM_PMKIDS_MAX;
wl_cfg80211.c:5859:	wdev->wiphy->max_sched_scan_ssids = MAX_PFN_LIST_COUNT;
wl_cfg80211.c:5860:	wdev->wiphy->max_match_sets = MAX_PFN_LIST_COUNT;
wl_cfg80211.c:5861:	wdev->wiphy->max_sched_scan_ie_len = WL_SCAN_IE_LEN_MAX;
wl_cfg80211.c:5862:	wdev->wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
wl_cfg80211.c:5864:	wdev->wiphy->interface_modes =
wl_cfg80211.c:5871:	wdev->wiphy->bands[IEEE80211_BAND_2GHZ] = &__wl_band_2ghz;
wl_cfg80211.c:5873:	wdev->wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
wl_cfg80211.c:5874:	wdev->wiphy->cipher_suites = __wl_cipher_suites;
wl_cfg80211.c:5875:	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(__wl_cipher_suites);
wl_cfg80211.c:5876:	wdev->wiphy->max_remain_on_channel_duration = 5000;
wl_cfg80211.c:5877:	wdev->wiphy->mgmt_stypes = wl_cfg80211_default_mgmt_stypes;
wl_cfg80211.c:5879:	wdev->wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
wl_cfg80211.c:5881:	wdev->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
wl_cfg80211.c:5883:	wdev->wiphy->flags |= WIPHY_FLAG_NETNS_OK |
wl_cfg80211.c:5899:	/* wdev->wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; */
wl_cfg80211.c:5902:	wdev->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |
wl_cfg80211.c:5910:	wdev->wiphy->flags |= WIPHY_FLAG_HAVE_AP_SME;
wl_cfg80211.c:5913:	wdev->wiphy->reg_notifier = wl_cfg80211_reg_notifier;
wl_cfg80211.c:5916:	wdev->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
wl_cfg80211.c:5917:	wiphy_apply_custom_regulatory(wdev->wiphy, &brcm_regdom);
wl_cfg80211.c:5919:	err = wiphy_register(wdev->wiphy);
wl_cfg80211.c:5922:		wiphy_free(wdev->wiphy);
wl_cfg80211.c:5929:	struct wireless_dev *wdev = wl->wdev;
wl_cfg80211.c:5935:	wiphy = wdev->wiphy;
wl_cfg80211.c:5936:	wiphy_unregister(wdev->wiphy);
wl_cfg80211.c:5937:	wdev->wiphy->dev.parent = NULL;
wl_cfg80211.c:5966:	bss_list = wl->bss_list;
wl_cfg80211.c:5984:		wl_update_rssi_cache(&g_rssi_cache_ctrl, &node->results);
wl_cfg80211.c:5985:		node = node->next;
wl_cfg80211.c:5996:	WL_SCAN(("scanned AP count (%d)\n", bss_list->count));
wl_cfg80211.c:6001:		bi = node->results.bss_info;
wl_cfg80211.c:6005:		node = node->next;
wl_cfg80211.c:6037:	if (unlikely(dtoh32(bi->length) > WL_BSS_INFO_MAX)) {
wl_cfg80211.c:6043:		- sizeof(u8) + WL_BSS_INFO_MAX, aflags);
wl_cfg80211.c:6046:		return -ENOMEM;
wl_cfg80211.c:6048:	mgmt = (struct ieee80211_mgmt *)notif_bss_info->frame_buf;
wl_cfg80211.c:6049:	notif_bss_info->channel =
wl_cfg80211.c:6050:		bi->ctl_ch ? bi->ctl_ch : CHSPEC_CHANNEL(wl_chspec_driver_to_host(bi->chanspec));
wl_cfg80211.c:6052:	if (notif_bss_info->channel <= CH_MAX_2G_CHANNEL)
wl_cfg80211.c:6053:		band = wiphy->bands[IEEE80211_BAND_2GHZ];
wl_cfg80211.c:6055:		band = wiphy->bands[IEEE80211_BAND_5GHZ];
wl_cfg80211.c:6059:		return -EINVAL;
wl_cfg80211.c:6061:	notif_bss_info->rssi = dtoh16(bi->RSSI);
wl_cfg80211.c:6063:	notif_bss_info->rssi = wl_get_avg_rssi(&g_rssi_cache_ctrl, &bi->BSSID);
wl_cfg80211.c:6066:	notif_bss_info->rssi = wl_update_rssi_offset(notif_bss_info->rssi);
wl_cfg80211.c:6068:	memcpy(mgmt->bssid, &bi->BSSID, ETHER_ADDR_LEN);
wl_cfg80211.c:6069:	mgmt_type = wl->active_scan ?
wl_cfg80211.c:6071:	if (!memcmp(bi->SSID, sr->ssid.SSID, bi->SSID_len)) {
wl_cfg80211.c:6072:	    mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | mgmt_type);
wl_cfg80211.c:6074:	beacon_proberesp = wl->active_scan ?
wl_cfg80211.c:6075:		(struct beacon_proberesp *)&mgmt->u.probe_resp :
wl_cfg80211.c:6076:		(struct beacon_proberesp *)&mgmt->u.beacon;
wl_cfg80211.c:6077:	beacon_proberesp->timestamp = 0;
wl_cfg80211.c:6078:	beacon_proberesp->beacon_int = cpu_to_le16(bi->beacon_period);
wl_cfg80211.c:6079:	beacon_proberesp->capab_info = cpu_to_le16(bi->capability);
wl_cfg80211.c:6082:	ie_offset = ((u8 *) bi) + bi->ie_offset;
wl_cfg80211.c:6090:			bi->flags & WL_BSS_FLAGS_FROM_BEACON));
wl_cfg80211.c:6095:			*(ie_new_offset+1) = bi->SSID_len;
wl_cfg80211.c:6096:			memcpy(ie_new_offset+2, bi->SSID, bi->SSID_len);
wl_cfg80211.c:6097:			ie_new_length = bi->ie_length - *(ie_offset+1) + bi->SSID_len;
wl_cfg80211.c:6100:			memcpy(ie_new_offset+2 + bi->SSID_len,
wl_cfg80211.c:6102:				bi->ie_length - 2 - *(ie_offset+1));
wl_cfg80211.c:6106:			wl_mrg_ie(wl, ((u8 *) bi) + bi->ie_offset, bi->ie_length);
wl_cfg80211.c:6109:		wl_mrg_ie(wl, ((u8 *) bi) + bi->ie_offset, bi->ie_length);
wl_cfg80211.c:6112:	wl_cp_ie(wl, beacon_proberesp->variable, WL_BSS_INFO_MAX -
wl_cfg80211.c:6114:	notif_bss_info->frame_len = offsetof(struct ieee80211_mgmt,
wl_cfg80211.c:6117:	freq = ieee80211_channel_to_frequency(notif_bss_info->channel);
wl_cfg80211.c:6118:	(void)band->band;
wl_cfg80211.c:6120:	freq = ieee80211_channel_to_frequency(notif_bss_info->channel, band->band);
wl_cfg80211.c:6125:		return -EINVAL;
wl_cfg80211.c:6131:		return -EINVAL;
wl_cfg80211.c:6134:		"frame_len %d, SSID \"%s\"\n", &bi->BSSID, notif_bss_info->channel,
wl_cfg80211.c:6135:		notif_bss_info->rssi, mgmt->u.beacon.capab_info, mgmt_type,
wl_cfg80211.c:6136:		notif_bss_info->frame_len, bi->SSID));
wl_cfg80211.c:6138:	signal = notif_bss_info->rssi * 100;
wl_cfg80211.c:6139:	if (!mgmt->u.probe_resp.timestamp) {
wl_cfg80211.c:6143:		mgmt->u.probe_resp.timestamp = ((u64)ts.tv_sec*1000000)
wl_cfg80211.c:6148:		mgmt->u.probe_resp.timestamp = ((u64)tv.tv_sec*1000000)
wl_cfg80211.c:6154:		le16_to_cpu(notif_bss_info->frame_len), signal, aflags);
wl_cfg80211.c:6158:		return -EINVAL;
wl_cfg80211.c:6168:	u32 event = ntoh32(e->event_type);
wl_cfg80211.c:6169:	u32 status =  ntoh32(e->status);
wl_cfg80211.c:6170:	u16 flags = ntoh16(e->flags);
wl_cfg80211.c:6189:	u32 event = ntoh32(e->event_type);
wl_cfg80211.c:6190:	u16 flags = ntoh16(e->flags);
wl_cfg80211.c:6214:	u32 event = ntoh32(e->event_type);
wl_cfg80211.c:6215:	u32 status = ntoh32(e->status);
wl_cfg80211.c:6235:	u32 event = ntoh32(e->event_type);
wl_cfg80211.c:6236:	u32 reason = ntoh32(e->reason);
wl_cfg80211.c:6237:	u32 len = ntoh32(e->datalen);
wl_cfg80211.c:6242:	u8 bsscfgidx = e->bsscfgidx;
wl_cfg80211.c:6257:	WL_DBG(("event %d status %d reason %d\n", event, ntoh32(e->status), reason));
wl_cfg80211.c:6263:		complete(&wl->iface_disable);
wl_cfg80211.c:6291:		NULL, 0, wl->ioctl_buf, WLC_IOCTL_SMLEN, bsscfgidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:6292:	memcpy(da.octet, wl->ioctl_buf, ETHER_ADDR_LEN);
wl_cfg80211.c:6321:		band = wiphy->bands[IEEE80211_BAND_2GHZ];
wl_cfg80211.c:6323:		band = wiphy->bands[IEEE80211_BAND_5GHZ];
wl_cfg80211.c:6328:		return -EINVAL;
wl_cfg80211.c:6332:	(void)band->band;
wl_cfg80211.c:6334:	freq = ieee80211_channel_to_frequency(channel, band->band);
wl_cfg80211.c:6337:	err = wl_frame_get_mgmt(fc, &da, &e->addr, &bssid,
wl_cfg80211.c:6376:			return -EINVAL;
wl_cfg80211.c:6380:		cfg80211_new_sta(ndev, e->addr.octet, &sinfo, GFP_ATOMIC);
wl_cfg80211.c:6382:		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
wl_cfg80211.c:6384:		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
wl_cfg80211.c:6394:	u32 reason = ntoh32(e->reason);
wl_cfg80211.c:6395:	u32 event = ntoh32(e->event_type);
wl_cfg80211.c:6402:				sec->auth_assoc_res_status = reason;
wl_cfg80211.c:6417:	u32 event = ntoh32(e->event_type);
wl_cfg80211.c:6423:			ntoh32(e->event_type), ntoh32(e->status), ndev));
wl_cfg80211.c:6433:				cfg80211_ibss_joined(ndev, (s8 *)&e->addr,
wl_cfg80211.c:6439:						MAC2STRDBG((u8*)(&e->addr)));
wl_cfg80211.c:6443:					 wl_read_prof(wl, ndev, WL_PROF_SSID))->SSID));
wl_cfg80211.c:6447:			wl_update_prof(wl, ndev, NULL, (void *)&e->addr, WL_PROF_BSSID);
wl_cfg80211.c:6450:			if (wl->scan_request) {
wl_cfg80211.c:6451:				if (wl->escan_on) {
wl_cfg80211.c:6454:					del_timer_sync(&wl->scan_timeout);
wl_cfg80211.c:6463:					reason = ntoh32(e->reason);
wl_cfg80211.c:6469:					ndev->name, event, ntoh32(e->reason),
wl_cfg80211.c:6470:					MAC2STRDBG((u8*)(&e->addr)));
wl_cfg80211.c:6471:				if (memcmp(curbssid, &e->addr, ETHER_ADDR_LEN) != 0) {
wl_cfg80211.c:6474:						MAC2STRDBG(curbssid), MAC2STRDBG((u8*)(&e->addr))));
wl_cfg80211.c:6501:					(memcmp(&e->addr, broad_bssid, ETHER_ADDR_LEN) == 0) ||
wl_cfg80211.c:6502:					(memcmp(&e->addr, connect_req_bssid, ETHER_ADDR_LEN) == 0))
wl_cfg80211.c:6511:				complete(&wl->iface_disable);
wl_cfg80211.c:6514:			printk("connect failed event=%d e->status %d e->reason %d \n",
wl_cfg80211.c:6515:				event, (int)ntoh32(e->status), (int)ntoh32(e->reason));
wl_cfg80211.c:6517:			if (wl->scan_request) {
wl_cfg80211.c:6518:				if (wl->escan_on) {
wl_cfg80211.c:6521:					del_timer_sync(&wl->scan_timeout);
wl_cfg80211.c:6540:	u32 event = be32_to_cpu(e->event_type);
wl_cfg80211.c:6541:	u32 status = be32_to_cpu(e->status);
wl_cfg80211.c:6550:		wl_update_prof(wl, ndev, NULL, (void *)&e->addr, WL_PROF_BSSID);
wl_cfg80211.c:6562:	err = wldev_iovar_getbuf(ndev, "assoc_info", NULL, 0, wl->extra_buf,
wl_cfg80211.c:6568:	memcpy(&assoc_info, wl->extra_buf, sizeof(wl_assoc_info_t));
wl_cfg80211.c:6572:	if (conn_info->req_ie_len) {
wl_cfg80211.c:6573:		conn_info->req_ie_len = 0;
wl_cfg80211.c:6574:		bzero(conn_info->req_ie, sizeof(conn_info->req_ie));
wl_cfg80211.c:6576:	if (conn_info->resp_ie_len) {
wl_cfg80211.c:6577:		conn_info->resp_ie_len = 0;
wl_cfg80211.c:6578:		bzero(conn_info->resp_ie, sizeof(conn_info->resp_ie));
wl_cfg80211.c:6581:		err = wldev_iovar_getbuf(ndev, "assoc_req_ies", NULL, 0, wl->extra_buf,
wl_cfg80211.c:6587:		conn_info->req_ie_len = assoc_info.req_len - sizeof(struct dot11_assoc_req);
wl_cfg80211.c:6589:			conn_info->req_ie_len -= ETHER_ADDR_LEN;
wl_cfg80211.c:6591:		if (conn_info->req_ie_len <= MAX_REQ_LINE)
wl_cfg80211.c:6592:			memcpy(conn_info->req_ie, wl->extra_buf, conn_info->req_ie_len);
wl_cfg80211.c:6595:				__FUNCTION__, conn_info->req_ie_len, MAX_REQ_LINE));
wl_cfg80211.c:6599:		conn_info->req_ie_len = 0;
wl_cfg80211.c:6602:		err = wldev_iovar_getbuf(ndev, "assoc_resp_ies", NULL, 0, wl->extra_buf,
wl_cfg80211.c:6608:		conn_info->resp_ie_len = assoc_info.resp_len -sizeof(struct dot11_assoc_resp);
wl_cfg80211.c:6609:		if (conn_info->resp_ie_len <= MAX_REQ_LINE)
wl_cfg80211.c:6610:			memcpy(conn_info->resp_ie, wl->extra_buf, conn_info->resp_ie_len);
wl_cfg80211.c:6613:				__FUNCTION__, conn_info->resp_ie_len, MAX_REQ_LINE));
wl_cfg80211.c:6617:		conn_info->resp_ie_len = 0;
wl_cfg80211.c:6619:	WL_DBG(("req len (%d) resp len (%d)\n", conn_info->req_ie_len,
wl_cfg80211.c:6620:		conn_info->resp_ie_len));
wl_cfg80211.c:6630:		join_params->params.chanspec_num = 1;
wl_cfg80211.c:6631:		join_params->params.chanspec_list[0] = ch;
wl_cfg80211.c:6633:		if (join_params->params.chanspec_list[0] <= CH_MAX_2G_CHANNEL)
wl_cfg80211.c:6642:			join_params->params.chanspec_num * sizeof(chanspec_t);
wl_cfg80211.c:6644:		join_params->params.chanspec_list[0]  &= WL_CHANSPEC_CHAN_MASK;
wl_cfg80211.c:6645:		join_params->params.chanspec_list[0] |= chanspec;
wl_cfg80211.c:6646:		join_params->params.chanspec_list[0] =
wl_cfg80211.c:6647:			wl_chspec_host_to_driver(join_params->params.chanspec_list[0]);
wl_cfg80211.c:6649:		join_params->params.chanspec_num =
wl_cfg80211.c:6650:			htod32(join_params->params.chanspec_num);
wl_cfg80211.c:6651:		WL_DBG(("join_params->params.chanspec_list[0]= %X, %d channels\n",
wl_cfg80211.c:6652:			join_params->params.chanspec_list[0],
wl_cfg80211.c:6653:			join_params->params.chanspec_num));
wl_cfg80211.c:6680:		ssid->SSID, ssid->SSID_len, WLAN_CAPABILITY_ESS,
wl_cfg80211.c:6683:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:6686:		*(u32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
wl_cfg80211.c:6688:			wl->extra_buf, WL_EXTRA_BUF_MAX, false);
wl_cfg80211.c:6693:		bi = (struct wl_bss_info *)(wl->extra_buf + 4);
wl_cfg80211.c:6694:		if (memcmp(bi->BSSID.octet, curbssid, ETHER_ADDR_LEN)) {
wl_cfg80211.c:6695:			err = -EIO;
wl_cfg80211.c:6699:		ie = ((u8 *)bi) + bi->ie_offset;
wl_cfg80211.c:6700:		ie_len = bi->ie_length;
wl_cfg80211.c:6702:		if (ssidie && ssidie[1] == bi->SSID_len && !ssidie[2] && bi->SSID[0])
wl_cfg80211.c:6703:			memcpy(ssidie + 2, bi->SSID, bi->SSID_len);
wl_cfg80211.c:6709:		ie = ((u8 *)bi) + bi->ie_offset;
wl_cfg80211.c:6710:		ie_len = bi->ie_length;
wl_cfg80211.c:6711:		beacon_interval = cpu_to_le16(bi->beacon_period);
wl_cfg80211.c:6713:		WL_DBG(("Found the AP in the list - BSSID %pM\n", bss->bssid));
wl_cfg80211.c:6714:		ie = bss->information_elements;
wl_cfg80211.c:6715:		ie_len = bss->len_information_elements;
wl_cfg80211.c:6716:		beacon_interval = bss->beacon_interval;
wl_cfg80211.c:6722:		dtim_period = tim->data[1];
wl_cfg80211.c:6741:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:6754:	wl_update_prof(wl, ndev, NULL, (void *)(e->addr.octet), WL_PROF_BSSID);
wl_cfg80211.c:6757:	wl_update_pmklist(ndev, wl->pmk_list, err);
wl_cfg80211.c:6759:		MAC2STRDBG((u8*)(&e->addr)));
wl_cfg80211.c:6769:		conn_info->req_ie, conn_info->req_ie_len,
wl_cfg80211.c:6770:		conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
wl_cfg80211.c:6788:		return -ENODEV;
wl_cfg80211.c:6795:				ntoh32(e->event_type), ntoh32(e->status)));
wl_cfg80211.c:6806:	if (wl->scan_request) {
wl_cfg80211.c:6814:			wl_update_prof(wl, ndev, NULL, (void *)(e->addr.octet), WL_PROF_BSSID);
wl_cfg80211.c:6817:			wl_update_pmklist(ndev, wl->pmk_list, err);
wl_cfg80211.c:6822:			conn_info->req_ie,
wl_cfg80211.c:6823:			conn_info->req_ie_len,
wl_cfg80211.c:6824:			conn_info->resp_ie,
wl_cfg80211.c:6825:			conn_info->resp_ie_len,
wl_cfg80211.c:6827:			(sec->auth_assoc_res_status) ?
wl_cfg80211.c:6828:			sec->auth_assoc_res_status :
wl_cfg80211.c:6832:			WL_INFO(("Report connect result - connection succeeded\n"));
wl_cfg80211.c:6834:			WL_ERR(("Report connect result - connection failed\n"));
wl_cfg80211.c:6843:	u16 flags = ntoh16(e->flags);
wl_cfg80211.c:6846:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:6852:	cfg80211_michael_mic_failure(ndev, (u8 *)&e->addr, key_type, -1,
wl_cfg80211.c:6854:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:6867:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:6870:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:6896:	if (wl->iscan_on && wl->iscan_kickstart)
wl_cfg80211.c:6899:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:6913:	wl->bss_list = wl->scan_results;
wl_cfg80211.c:6914:	bss_list = wl->bss_list;
wl_cfg80211.c:6916:	bss_list->buflen = htod32(len);
wl_cfg80211.c:6918:	if (unlikely(err) && unlikely(!wl->scan_suppressed)) {
wl_cfg80211.c:6919:		WL_ERR(("%s Scan_results error (%d)\n", ndev->name, err));
wl_cfg80211.c:6920:		err = -EINVAL;
wl_cfg80211.c:6923:	bss_list->buflen = dtoh32(bss_list->buflen);
wl_cfg80211.c:6924:	bss_list->version = dtoh32(bss_list->version);
wl_cfg80211.c:6925:	bss_list->count = dtoh32(bss_list->count);
wl_cfg80211.c:6930:	del_timer_sync(&wl->scan_timeout);
wl_cfg80211.c:6931:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:6932:	if (wl->scan_request) {
wl_cfg80211.c:6933:		cfg80211_scan_done(wl->scan_request, false);
wl_cfg80211.c:6934:		wl->scan_request = NULL;
wl_cfg80211.c:6936:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:6938:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:6968:		return -ENOMEM;
wl_cfg80211.c:6971:	hdr->fc = htol16(fc);
wl_cfg80211.c:6972:	hdr->durid = 0;
wl_cfg80211.c:6973:	hdr->seq = 0;
wl_cfg80211.c:6974:	offset = (u8*)(hdr + 1) + (totlen - DOT11_MGMT_HDR_LEN - prebody_len);
wl_cfg80211.c:6975:	bcopy((const char*)da, (u8*)&hdr->da, ETHER_ADDR_LEN);
wl_cfg80211.c:6976:	bcopy((const char*)sa, (u8*)&hdr->sa, ETHER_ADDR_LEN);
wl_cfg80211.c:6977:	bcopy((const char*)bssid, (u8*)&hdr->bssid, ETHER_ADDR_LEN);
wl_cfg80211.c:6995:		if (wl->af_sent_channel)
wl_cfg80211.c:6998:				(ndev == wl->p2p_net) ? wl_to_prmry_ndev(wl) : ndev, true, true);
wl_cfg80211.c:7005:			(ndev == wl->p2p_net) ? wl_to_prmry_ndev(wl) : ndev, true, true);
wl_cfg80211.c:7027:	u32 event = ntoh32(e->event_type);
wl_cfg80211.c:7029:	u8 bsscfgidx = e->bsscfgidx;
wl_cfg80211.c:7030:	u32 mgmt_frame_len = ntoh32(e->datalen) - sizeof(wl_event_rx_frame_data_t);
wl_cfg80211.c:7031:	u16 channel = ((ntoh16(rxframe->channel) & WL_CHANSPEC_CHAN_MASK));
wl_cfg80211.c:7035:	if (wl->p2p_net == ndev) {
wl_cfg80211.c:7042:		band = wiphy->bands[IEEE80211_BAND_2GHZ];
wl_cfg80211.c:7044:		band = wiphy->bands[IEEE80211_BAND_5GHZ];
wl_cfg80211.c:7047:		return -EINVAL;
wl_cfg80211.c:7051:	(void)band->band;
wl_cfg80211.c:7053:	freq = ieee80211_channel_to_frequency(channel, band->band);
wl_cfg80211.c:7057:			NULL, 0, wl->ioctl_buf, WLC_IOCTL_SMLEN, bsscfgidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:7062:		memcpy(da.octet, wl->ioctl_buf, ETHER_ADDR_LEN);
wl_cfg80211.c:7063:		err = wl_frame_get_mgmt(FC_ACTION, &da, &e->addr, &bssid,
wl_cfg80211.c:7073:			mgmt_frame_len - DOT11_MGMT_HDR_LEN)) {
wl_cfg80211.c:7077:			mgmt_frame_len - DOT11_MGMT_HDR_LEN)) {
wl_cfg80211.c:7082:			mgmt_frame_len - DOT11_MGMT_HDR_LEN)) {
wl_cfg80211.c:7086:				if (wl->next_af_subtype == sd_act_frm->action) {
wl_cfg80211.c:7088:						sd_act_frm->action));
wl_cfg80211.c:7090:						(ndev == wl->p2p_net) ?
wl_cfg80211.c:7103:			if (wl->p2p_net == ndev)
wl_cfg80211.c:7110:				if (wl->next_af_subtype == act_frm->subtype) {
wl_cfg80211.c:7112:						act_frm->subtype));
wl_cfg80211.c:7114:						(ndev == wl->p2p_net) ?
wl_cfg80211.c:7124:			mgmt_frame_len - DOT11_MGMT_HDR_LEN);
wl_cfg80211.c:7128:		if (act_frm && ((act_frm->subtype == P2P_PAF_GON_CONF) ||
wl_cfg80211.c:7129:			(act_frm->subtype == P2P_PAF_PROVDIS_RSP))) {
wl_cfg80211.c:7132:		if (act_frm && (act_frm->subtype == P2P_PAF_GON_CONF)) {
wl_cfg80211.c:7150:			 * GO-NEG Phase
wl_cfg80211.c:7152:			if (wl->p2p &&
wl_cfg80211.c:7155:					"being in GO-Neg state\n"));
wl_cfg80211.c:7167:	WL_DBG(("%s: mgmt_frame_len (%d) , e->datalen (%d), channel (%d), freq (%d)\n", __func__,
wl_cfg80211.c:7168:		mgmt_frame_len, ntoh32(e->datalen), channel, freq));
wl_cfg80211.c:7196:	if (e->event_type == WLC_E_PFN_NET_LOST) {
wl_cfg80211.c:7200:	WL_PNO((">>> PFN NET FOUND event. count:%d \n", pfn_result->count));
wl_cfg80211.c:7201:	if (pfn_result->count > 0) {
wl_cfg80211.c:7209:				- sizeof(wl_pfn_net_info_t));
wl_cfg80211.c:7215:			err = -ENOMEM;
wl_cfg80211.c:7219:		for (i = 0; i < pfn_result->count; i++) {
wl_cfg80211.c:7223:				err = -EINVAL;
wl_cfg80211.c:7227:				netinfo->pfnsubnet.SSID, netinfo->pfnsubnet.channel));
wl_cfg80211.c:7234:			memcpy(ssid[i].ssid, netinfo->pfnsubnet.SSID,
wl_cfg80211.c:7235:				netinfo->pfnsubnet.SSID_len);
wl_cfg80211.c:7236:			ssid[i].ssid_len = netinfo->pfnsubnet.SSID_len;
wl_cfg80211.c:7239:			channel_req = netinfo->pfnsubnet.channel;
wl_cfg80211.c:7254:			/* Abort any on-going scan */
wl_cfg80211.c:7279:		wl->sched_scan_running = TRUE;
wl_cfg80211.c:7294:	conf->frag_threshold = (u32)-1;
wl_cfg80211.c:7295:	conf->rts_threshold = (u32)-1;
wl_cfg80211.c:7296:	conf->retry_short = (u32)-1;
wl_cfg80211.c:7297:	conf->retry_long = (u32)-1;
wl_cfg80211.c:7298:	conf->tx_power = -1;
wl_cfg80211.c:7306:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:7308:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:7313:	memset(wl->evt_handler, 0, sizeof(wl->evt_handler));
wl_cfg80211.c:7315:	wl->evt_handler[WLC_E_SCAN_COMPLETE] = wl_notify_scan_status;
wl_cfg80211.c:7316:	wl->evt_handler[WLC_E_AUTH] = wl_notify_connect_status;
wl_cfg80211.c:7317:	wl->evt_handler[WLC_E_ASSOC] = wl_notify_connect_status;
wl_cfg80211.c:7318:	wl->evt_handler[WLC_E_LINK] = wl_notify_connect_status;
wl_cfg80211.c:7319:	wl->evt_handler[WLC_E_DEAUTH_IND] = wl_notify_connect_status;
wl_cfg80211.c:7320:	wl->evt_handler[WLC_E_DEAUTH] = wl_notify_connect_status;
wl_cfg80211.c:7321:	wl->evt_handler[WLC_E_DISASSOC_IND] = wl_notify_connect_status;
wl_cfg80211.c:7322:	wl->evt_handler[WLC_E_ASSOC_IND] = wl_notify_connect_status;
wl_cfg80211.c:7323:	wl->evt_handler[WLC_E_REASSOC_IND] = wl_notify_connect_status;
wl_cfg80211.c:7324:	wl->evt_handler[WLC_E_ROAM] = wl_notify_roaming_status;
wl_cfg80211.c:7325:	wl->evt_handler[WLC_E_MIC_ERROR] = wl_notify_mic_status;
wl_cfg80211.c:7326:	wl->evt_handler[WLC_E_SET_SSID] = wl_notify_connect_status;
wl_cfg80211.c:7327:	wl->evt_handler[WLC_E_ACTION_FRAME_RX] = wl_notify_rx_mgmt_frame;
wl_cfg80211.c:7328:	wl->evt_handler[WLC_E_PROBREQ_MSG] = wl_notify_rx_mgmt_frame;
wl_cfg80211.c:7329:	wl->evt_handler[WLC_E_P2P_PROBREQ_MSG] = wl_notify_rx_mgmt_frame;
wl_cfg80211.c:7330:	wl->evt_handler[WLC_E_P2P_DISC_LISTEN_COMPLETE] = wl_cfgp2p_listen_complete;
wl_cfg80211.c:7331:	wl->evt_handler[WLC_E_ACTION_FRAME_COMPLETE] = wl_cfgp2p_action_tx_complete;
wl_cfg80211.c:7332:	wl->evt_handler[WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE] = wl_cfgp2p_action_tx_complete;
wl_cfg80211.c:7334:	wl->evt_handler[WLC_E_PFN_NET_FOUND] = wl_notify_pfn_status;
wl_cfg80211.c:7341:	wl->scan_results = (void *)kzalloc(WL_SCAN_BUF_MAX, GFP_KERNEL);
wl_cfg80211.c:7342:	if (unlikely(!wl->scan_results)) {
wl_cfg80211.c:7346:	wl->conf = (void *)kzalloc(sizeof(*wl->conf), GFP_KERNEL);
wl_cfg80211.c:7347:	if (unlikely(!wl->conf)) {
wl_cfg80211.c:7351:	wl->scan_req_int =
wl_cfg80211.c:7352:	    (void *)kzalloc(sizeof(*wl->scan_req_int), GFP_KERNEL);
wl_cfg80211.c:7353:	if (unlikely(!wl->scan_req_int)) {
wl_cfg80211.c:7357:	wl->ioctl_buf = (void *)kzalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
wl_cfg80211.c:7358:	if (unlikely(!wl->ioctl_buf)) {
wl_cfg80211.c:7362:	wl->escan_ioctl_buf = (void *)kzalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
wl_cfg80211.c:7363:	if (unlikely(!wl->escan_ioctl_buf)) {
wl_cfg80211.c:7367:	wl->extra_buf = (void *)kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);
wl_cfg80211.c:7368:	if (unlikely(!wl->extra_buf)) {
wl_cfg80211.c:7372:	wl->iscan = (void *)kzalloc(sizeof(*wl->iscan), GFP_KERNEL);
wl_cfg80211.c:7373:	if (unlikely(!wl->iscan)) {
wl_cfg80211.c:7377:	wl->pmk_list = (void *)kzalloc(sizeof(*wl->pmk_list), GFP_KERNEL);
wl_cfg80211.c:7378:	if (unlikely(!wl->pmk_list)) {
wl_cfg80211.c:7382:	wl->sta_info = (void *)kzalloc(sizeof(*wl->sta_info), GFP_KERNEL);
wl_cfg80211.c:7383:	if (unlikely(!wl->sta_info)) {
wl_cfg80211.c:7389:	wl->conn_info = (void *)kzalloc(sizeof(*wl->conn_info), GFP_KERNEL);
wl_cfg80211.c:7390:	if (unlikely(!wl->conn_info)) {
wl_cfg80211.c:7391:		WL_ERR(("wl->conn_info  alloc failed\n"));
wl_cfg80211.c:7394:	wl->ie = (void *)kzalloc(sizeof(*wl->ie), GFP_KERNEL);
wl_cfg80211.c:7395:	if (unlikely(!wl->ie)) {
wl_cfg80211.c:7396:		WL_ERR(("wl->ie  alloc failed\n"));
wl_cfg80211.c:7399:	wl->escan_info.escan_buf = dhd_os_prealloc(NULL, DHD_PREALLOC_WIPHY_ESCAN0, 0);
wl_cfg80211.c:7400:	bzero(wl->escan_info.escan_buf, ESCAN_BUF_SIZE);
wl_cfg80211.c:7402:	wl->afx_hdl = (void *)kzalloc(sizeof(*wl->afx_hdl), GFP_KERNEL);
wl_cfg80211.c:7403:	if (unlikely(!wl->afx_hdl)) {
wl_cfg80211.c:7407:		init_completion(&wl->act_frm_scan);
wl_cfg80211.c:7408:		init_completion(&wl->wait_next_af);
wl_cfg80211.c:7410:		INIT_WORK(&wl->afx_hdl->work, wl_cfg80211_afx_handler);
wl_cfg80211.c:7417:	return -ENOMEM;
wl_cfg80211.c:7422:	kfree(wl->scan_results);
wl_cfg80211.c:7423:	wl->scan_results = NULL;
wl_cfg80211.c:7424:	kfree(wl->conf);
wl_cfg80211.c:7425:	wl->conf = NULL;
wl_cfg80211.c:7426:	kfree(wl->scan_req_int);
wl_cfg80211.c:7427:	wl->scan_req_int = NULL;
wl_cfg80211.c:7428:	kfree(wl->ioctl_buf);
wl_cfg80211.c:7429:	wl->ioctl_buf = NULL;
wl_cfg80211.c:7430:	kfree(wl->escan_ioctl_buf);
wl_cfg80211.c:7431:	wl->escan_ioctl_buf = NULL;
wl_cfg80211.c:7432:	kfree(wl->extra_buf);
wl_cfg80211.c:7433:	wl->extra_buf = NULL;
wl_cfg80211.c:7434:	kfree(wl->iscan);
wl_cfg80211.c:7435:	wl->iscan = NULL;
wl_cfg80211.c:7436:	kfree(wl->pmk_list);
wl_cfg80211.c:7437:	wl->pmk_list = NULL;
wl_cfg80211.c:7438:	kfree(wl->sta_info);
wl_cfg80211.c:7439:	wl->sta_info = NULL;
wl_cfg80211.c:7441:	kfree(wl->conn_info);
wl_cfg80211.c:7442:	wl->conn_info = NULL;
wl_cfg80211.c:7443:	kfree(wl->ie);
wl_cfg80211.c:7444:	wl->ie = NULL;
wl_cfg80211.c:7445:	wl->escan_info.escan_buf = NULL;
wl_cfg80211.c:7447:	if (wl->afx_hdl) {
wl_cfg80211.c:7448:		cancel_work_sync(&wl->afx_hdl->work);
wl_cfg80211.c:7449:		kfree(wl->afx_hdl);
wl_cfg80211.c:7450:		wl->afx_hdl = NULL;
wl_cfg80211.c:7453:	if (wl->ap_info) {
wl_cfg80211.c:7454:		kfree(wl->ap_info->wpa_ie);
wl_cfg80211.c:7455:		kfree(wl->ap_info->rsn_ie);
wl_cfg80211.c:7456:		kfree(wl->ap_info->wps_ie);
wl_cfg80211.c:7457:		kfree(wl->ap_info);
wl_cfg80211.c:7458:		wl->ap_info = NULL;
wl_cfg80211.c:7468:	wl->event_tsk.thr_pid = -1;
wl_cfg80211.c:7471:	PROC_START2(wl_event_handler, wl, &wl->event_tsk, 0, "wl_event_handler");
wl_cfg80211.c:7473:	PROC_START(wl_event_handler, wl, &wl->event_tsk, 0);
wl_cfg80211.c:7475:	if (wl->event_tsk.thr_pid < 0)
wl_cfg80211.c:7476:		ret = -ENOMEM;
wl_cfg80211.c:7482:	if (wl->event_tsk.thr_pid >= 0)
wl_cfg80211.c:7483:		PROC_STOP(&wl->event_tsk);
wl_cfg80211.c:7490:	if (wl->iscan_on && iscan->tsk) {
wl_cfg80211.c:7491:		iscan->state = WL_ISCAN_STATE_IDLE;
wl_cfg80211.c:7493:		send_sig(SIGTERM, iscan->tsk, 1);
wl_cfg80211.c:7495:		kthread_stop(iscan->tsk);
wl_cfg80211.c:7496:		iscan->tsk = NULL;
wl_cfg80211.c:7512:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:7514:	if (likely(wl->scan_request)) {
wl_cfg80211.c:7515:		cfg80211_scan_done(wl->scan_request, aborted);
wl_cfg80211.c:7516:		wl->scan_request = NULL;
wl_cfg80211.c:7518:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:7519:	wl->iscan_kickstart = false;
wl_cfg80211.c:7524:	if (likely(iscan->state != WL_ISCAN_STATE_IDLE)) {
wl_cfg80211.c:7526:		up(&iscan->sync);
wl_cfg80211.c:7530:	return -EIO;
wl_cfg80211.c:7543:	memset(iscan->scan_buf, 0, WL_ISCAN_BUF_MAX);
wl_cfg80211.c:7544:	list_buf = (struct wl_iscan_results *)iscan->scan_buf;
wl_cfg80211.c:7545:	results = &list_buf->results;
wl_cfg80211.c:7546:	results->buflen = WL_ISCAN_RESULTS_FIXED_SIZE;
wl_cfg80211.c:7547:	results->version = 0;
wl_cfg80211.c:7548:	results->count = 0;
wl_cfg80211.c:7552:	err = wldev_iovar_getbuf(iscan->dev, "iscanresults", &list,
wl_cfg80211.c:7553:		WL_ISCAN_RESULTS_FIXED_SIZE, iscan->scan_buf,
wl_cfg80211.c:7559:	results->buflen = dtoh32(results->buflen);
wl_cfg80211.c:7560:	results->version = dtoh32(results->version);
wl_cfg80211.c:7561:	results->count = dtoh32(results->count);
wl_cfg80211.c:7562:	WL_DBG(("results->count = %d\n", results->count));
wl_cfg80211.c:7563:	WL_DBG(("results->buflen = %d\n", results->buflen));
wl_cfg80211.c:7564:	*status = dtoh32(list_buf->status);
wl_cfg80211.c:7572:	struct wl_iscan_ctrl *iscan = wl->iscan;
wl_cfg80211.c:7575:	iscan->state = WL_ISCAN_STATE_IDLE;
wl_cfg80211.c:7576:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:7579:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:7586:	struct wl_iscan_ctrl *iscan = wl->iscan;
wl_cfg80211.c:7590:	mod_timer(&iscan->timer, jiffies + msecs_to_jiffies(iscan->timer_ms));
wl_cfg80211.c:7591:	iscan->timer_on = 1;
wl_cfg80211.c:7598:	struct wl_iscan_ctrl *iscan = wl->iscan;
wl_cfg80211.c:7601:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:7604:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:7606:	mod_timer(&iscan->timer, jiffies + msecs_to_jiffies(iscan->timer_ms));
wl_cfg80211.c:7607:	iscan->timer_on = 1;
wl_cfg80211.c:7614:	struct wl_iscan_ctrl *iscan = wl->iscan;
wl_cfg80211.c:7617:	iscan->state = WL_ISCAN_STATE_IDLE;
wl_cfg80211.c:7618:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:7620:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:7634:	while (likely(!down_interruptible(&iscan->sync))) {
wl_cfg80211.c:7637:		if (iscan->timer_on) {
wl_cfg80211.c:7638:			del_timer_sync(&iscan->timer);
wl_cfg80211.c:7639:			iscan->timer_on = 0;
wl_cfg80211.c:7641:		mutex_lock(&wl->usr_sync);
wl_cfg80211.c:7642:		err = wl_get_iscan_results(iscan, &status, &wl->bss_list);
wl_cfg80211.c:7647:		mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:7648:		iscan->iscan_handler[status] (wl);
wl_cfg80211.c:7650:	if (iscan->timer_on) {
wl_cfg80211.c:7651:		del_timer_sync(&iscan->timer);
wl_cfg80211.c:7652:		iscan->timer_on = 0;
wl_cfg80211.c:7663:	if (wl->scan_request) {
wl_cfg80211.c:7665:		if (wl->escan_on)
wl_cfg80211.c:7666:			wl_notify_escan_complete(wl, wl->escan_info.ndev, true, true);
wl_cfg80211.c:7676:		iscan->timer_on = 0;
wl_cfg80211.c:7687:	if (wl->iscan_on && !iscan->tsk) {
wl_cfg80211.c:7688:		iscan->state = WL_ISCAN_STATE_IDLE;
wl_cfg80211.c:7689:		sema_init(&iscan->sync, 0);
wl_cfg80211.c:7690:		iscan->tsk = kthread_run(wl_iscan_thread, iscan, "wl_iscan");
wl_cfg80211.c:7691:		if (IS_ERR(iscan->tsk)) {
wl_cfg80211.c:7693:			iscan->tsk = NULL;
wl_cfg80211.c:7694:			return -ENOMEM;
wl_cfg80211.c:7703:	memset(iscan->iscan_handler, 0, sizeof(iscan->iscan_handler));
wl_cfg80211.c:7704:	iscan->iscan_handler[WL_SCAN_RESULTS_SUCCESS] = wl_iscan_done;
wl_cfg80211.c:7705:	iscan->iscan_handler[WL_SCAN_RESULTS_PARTIAL] = wl_iscan_inprogress;
wl_cfg80211.c:7706:	iscan->iscan_handler[WL_SCAN_RESULTS_PENDING] = wl_iscan_pending;
wl_cfg80211.c:7707:	iscan->iscan_handler[WL_SCAN_RESULTS_ABORTED] = wl_iscan_aborted;
wl_cfg80211.c:7708:	iscan->iscan_handler[WL_SCAN_RESULTS_NO_MEM] = wl_iscan_aborted;
wl_cfg80211.c:7717:	struct wireless_dev *wdev = dev->ieee80211_ptr;
wl_cfg80211.c:7726:			while (work_pending(&wdev->cleanup_work) && refcnt < 100) {
wl_cfg80211.c:7738:			/* after calling list_del_rcu(&wdev->list) */
wl_cfg80211.c:7749:				if (wl->escan_on) {
wl_cfg80211.c:7773:	if (wl->escan_info.ndev != ndev)
wl_cfg80211.c:7775:		WL_ERR(("ndev is different %p %p\n", wl->escan_info.ndev, ndev));
wl_cfg80211.c:7779:	if (wl->scan_request) {
wl_cfg80211.c:7780:		if (wl->scan_request->dev == wl->p2p_net)
wl_cfg80211.c:7783:			dev = wl->scan_request->dev;
wl_cfg80211.c:7786:		WL_DBG(("wl->scan_request is NULL may be internal scan."
wl_cfg80211.c:7788:				ndev, wl_to_prmry_ndev(wl), wl->p2p_net));
wl_cfg80211.c:7793:		params = wl_cfg80211_scan_alloc_params(-1, 0, &params_size);
wl_cfg80211.c:7796:			err = -ENOMEM;
wl_cfg80211.c:7805:	if (timer_pending(&wl->scan_timeout))
wl_cfg80211.c:7806:		del_timer_sync(&wl->scan_timeout);
wl_cfg80211.c:7808:	if (likely(wl->scan_request)) {
wl_cfg80211.c:7809:		wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
wl_cfg80211.c:7813:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:7815:	if (wl->sched_scan_req && !wl->scan_request) {
wl_cfg80211.c:7818:			cfg80211_sched_scan_stopped(wl->sched_scan_req->wiphy);
wl_cfg80211.c:7820:			cfg80211_sched_scan_results(wl->sched_scan_req->wiphy);
wl_cfg80211.c:7821:		wl->sched_scan_running = FALSE;
wl_cfg80211.c:7822:		wl->sched_scan_req = NULL;
wl_cfg80211.c:7825:	if (likely(wl->scan_request)) {
wl_cfg80211.c:7826:		cfg80211_scan_done(wl->scan_request, aborted);
wl_cfg80211.c:7827:		wl->scan_request = NULL;
wl_cfg80211.c:7832:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:7844:	s32 status = ntoh32(e->status);
wl_cfg80211.c:7855:		ntoh32(e->event_type), ntoh32(e->status)));
wl_cfg80211.c:7857:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:7861:			ndev = wl->afx_hdl->dev;
wl_cfg80211.c:7863:			ndev = wl->escan_info.ndev;
wl_cfg80211.c:7866:	if (!ndev || !wl->escan_on ||
wl_cfg80211.c:7868:		!wl->sched_scan_running)) {
wl_cfg80211.c:7869:		WL_ERR(("escan is not ready ndev %p wl->escan_on %d drv_status 0x%x\n",
wl_cfg80211.c:7870:			ndev, wl->escan_on, wl_get_drv_status(wl, SCANNING, ndev)));
wl_cfg80211.c:7880:		if (dtoh16(escan_result->bss_count) != 1) {
wl_cfg80211.c:7881:			WL_ERR(("Invalid bss_count %d: ignoring\n", escan_result->bss_count));
wl_cfg80211.c:7884:		bi = escan_result->bss_info;
wl_cfg80211.c:7889:		bi_length = dtoh32(bi->length);
wl_cfg80211.c:7890:		if (bi_length != (dtoh32(escan_result->buflen) - WL_ESCAN_RESULTS_FIXED_SIZE)) {
wl_cfg80211.c:7895:		if (!(wl_to_wiphy(wl)->interface_modes & BIT(NL80211_IFTYPE_ADHOC))) {
wl_cfg80211.c:7896:			if (dtoh16(bi->capability) & DOT11_CAP_IBSS) {
wl_cfg80211.c:7905:				wl->afx_hdl->tx_dst_addr.octet, ETHER_ADDR_LEN)) {
wl_cfg80211.c:7907:					wl_chspec_driver_to_host(bi->chanspec));
wl_cfg80211.c:7909:					MAC2STRDBG(wl->afx_hdl->tx_dst_addr.octet), channel));
wl_cfg80211.c:7911:				wl->afx_hdl->peer_chan = channel;
wl_cfg80211.c:7912:				complete(&wl->act_frm_scan);
wl_cfg80211.c:7918:			list = (wl_scan_results_t *)wl->escan_info.escan_buf;
wl_cfg80211.c:7920:			if (wl->p2p_net && wl->scan_request &&
wl_cfg80211.c:7921:				wl->scan_request->dev == wl->p2p_net)
wl_cfg80211.c:7931:				if (bi->flags & WL_BSS_FLAGS_FROM_BEACON)
wl_cfg80211.c:7933:				if ((p2p_ie = wl_cfgp2p_find_p2pie(((u8 *) bi) + bi->ie_offset,
wl_cfg80211.c:7934:					bi->ie_length)) == NULL) {
wl_cfg80211.c:7940:				channel = CHSPEC_CHANNEL(wl_chspec_driver_to_host(bi->chanspec));
wl_cfg80211.c:7945:				if ((wl->curr_band == WLC_BAND_5G) &&
wl_cfg80211.c:7954:			for (i = 0; i < list->count; i++) {
wl_cfg80211.c:7955:				bss = bss ? (wl_bss_info_t *)((uintptr)bss + dtoh32(bss->length))
wl_cfg80211.c:7956:					: list->bss_info;
wl_cfg80211.c:7958:				if (!bcmp(&bi->BSSID, &bss->BSSID, ETHER_ADDR_LEN) &&
wl_cfg80211.c:7959:					(CHSPEC_BAND(wl_chspec_driver_to_host(bi->chanspec))
wl_cfg80211.c:7960:					== CHSPEC_BAND(wl_chspec_driver_to_host(bss->chanspec))) &&
wl_cfg80211.c:7961:					bi->SSID_len == bss->SSID_len &&
wl_cfg80211.c:7962:					!bcmp(bi->SSID, bss->SSID, bi->SSID_len)) {
wl_cfg80211.c:7967:					if (!(bss->flags & WL_BSS_FLAGS_FROM_BEACON) &&
wl_cfg80211.c:7968:						(bi->flags & WL_BSS_FLAGS_FROM_BEACON))
wl_cfg80211.c:7973:						bss->SSID, MAC2STRDBG(bi->BSSID.octet), i,
wl_cfg80211.c:7974:						bss->RSSI, bss->flags, bi->RSSI, bi->flags));
wl_cfg80211.c:7976:					if ((bss->flags & WL_BSS_FLAGS_RSSI_ONCHANNEL) ==
wl_cfg80211.c:7977:						(bi->flags & WL_BSS_FLAGS_RSSI_ONCHANNEL)) {
wl_cfg80211.c:7979:						* both on-channel or both off-channel
wl_cfg80211.c:7983:						bss->SSID, MAC2STRDBG(bi->BSSID.octet),
wl_cfg80211.c:7984:						bss->RSSI, bi->RSSI));
wl_cfg80211.c:7985:						bi->RSSI = MAX(bss->RSSI, bi->RSSI);
wl_cfg80211.c:7986:					} else if ((bss->flags & WL_BSS_FLAGS_RSSI_ONCHANNEL) &&
wl_cfg80211.c:7987:						(bi->flags & WL_BSS_FLAGS_RSSI_ONCHANNEL) == 0) {
wl_cfg80211.c:7988:						/* preserve the on-channel rssi measurement
wl_cfg80211.c:7993:						bss->SSID, MAC2STRDBG(bi->BSSID.octet),
wl_cfg80211.c:7994:						bss->RSSI, bi->RSSI));
wl_cfg80211.c:7995:						bi->RSSI = bss->RSSI;
wl_cfg80211.c:7996:						bi->flags |= WL_BSS_FLAGS_RSSI_ONCHANNEL;
wl_cfg80211.c:7998:					if (dtoh32(bss->length) != bi_length) {
wl_cfg80211.c:7999:						u32 prev_len = dtoh32(bss->length);
wl_cfg80211.c:8002:							" is occured(bcast:%d->probresp%d)\n",
wl_cfg80211.c:8003:							bss->ie_length, bi->ie_length));
wl_cfg80211.c:8004:						WL_DBG(("%s("MACDBG"), replacement!(%d -> %d)\n",
wl_cfg80211.c:8005:						bss->SSID, MAC2STRDBG(bi->BSSID.octet),
wl_cfg80211.c:8008:						if (list->buflen - prev_len + bi_length
wl_cfg80211.c:8013:							bss->RSSI = bi->RSSI;
wl_cfg80211.c:8014:							bss->flags |= (bi->flags
wl_cfg80211.c:8019:						if (i < list->count - 1) {
wl_cfg80211.c:8023:								list->buflen - cur_len - prev_len);
wl_cfg80211.c:8025:						list->buflen -= prev_len;
wl_cfg80211.c:8026:						list->buflen += bi_length;
wl_cfg80211.c:8028:					list->version = dtoh32(bi->version);
wl_cfg80211.c:8032:				cur_len += dtoh32(bss->length);
wl_cfg80211.c:8034:			if (bi_length > ESCAN_BUF_SIZE - list->buflen) {
wl_cfg80211.c:8038:			if (strlen(bi->SSID) == 0) { // terence: fix for hidden SSID
wl_cfg80211.c:8039:				WL_SCAN(("Skip hidden SSID %pM\n", &bi->BSSID));
wl_cfg80211.c:8042:			memcpy(&(wl->escan_info.escan_buf[list->buflen]), bi, bi_length);
wl_cfg80211.c:8043:			list->version = dtoh32(bi->version);
wl_cfg80211.c:8044:			list->buflen += bi_length;
wl_cfg80211.c:8045:			list->count++;
wl_cfg80211.c:8050:		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
wl_cfg80211.c:8054:			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
wl_cfg80211.c:8055:			if (wl->afx_hdl->peer_chan == WL_INVALID)
wl_cfg80211.c:8056:				complete(&wl->act_frm_scan);
wl_cfg80211.c:8057:		} else if ((likely(wl->scan_request)) || (wl->sched_scan_running)) {
wl_cfg80211.c:8059:			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
wl_cfg80211.c:8065:		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
wl_cfg80211.c:8068:			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
wl_cfg80211.c:8070:			if (wl->afx_hdl->peer_chan == WL_INVALID)
wl_cfg80211.c:8071:				complete(&wl->act_frm_scan);
wl_cfg80211.c:8072:		} else if ((likely(wl->scan_request)) || (wl->sched_scan_running)) {
wl_cfg80211.c:8074:			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
wl_cfg80211.c:8082:		WL_ERR(("WLC_E_STATUS_NEWSCAN : scan_request[%p]\n", wl->scan_request));
wl_cfg80211.c:8083:		WL_ERR(("sync_id[%d], bss_count[%d]\n", escan_result->sync_id,
wl_cfg80211.c:8084:			escan_result->bss_count));
wl_cfg80211.c:8087:		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
wl_cfg80211.c:8091:			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
wl_cfg80211.c:8092:			if (wl->afx_hdl->peer_chan == WL_INVALID)
wl_cfg80211.c:8093:				complete(&wl->act_frm_scan);
wl_cfg80211.c:8094:		} else if ((likely(wl->scan_request)) || (wl->sched_scan_running)) {
wl_cfg80211.c:8095:			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
wl_cfg80211.c:8101:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:8110:	if (!wl->roamoff_on_concurrent)
wl_cfg80211.c:8115:			if ((err = wldev_iovar_getint(iter->ndev, "roam_off",
wl_cfg80211.c:8116:				(s32 *)&iter->roam_off)) != BCME_OK) {
wl_cfg80211.c:8118:					iter->ndev->name, err));
wl_cfg80211.c:8121:			if ((err = wldev_iovar_setint(iter->ndev, "roam_off", 1)) != BCME_OK) {
wl_cfg80211.c:8123:					iter->ndev->name, err));
wl_cfg80211.c:8129:			if (iter->roam_off != WL_INVALID) {
wl_cfg80211.c:8130:				if ((err = wldev_iovar_setint(iter->ndev, "roam_off",
wl_cfg80211.c:8131:					iter->roam_off)) == BCME_OK)
wl_cfg80211.c:8132:					iter->roam_off = WL_INVALID;
wl_cfg80211.c:8135:						iter->ndev->name, err));
wl_cfg80211.c:8150:	wl->vsdb_mode = false;
wl_cfg80211.c:8158:		if (wl_get_drv_status(wl, CONNECTED, iter->ndev)) {
wl_cfg80211.c:8159:			if (wldev_iovar_getint(iter->ndev, "chanspec",
wl_cfg80211.c:8166:						chan -= CH_10MHZ_APART;
wl_cfg80211.c:8168:				wl_update_prof(wl, iter->ndev, NULL,
wl_cfg80211.c:8174:				wl->vsdb_mode = true;
wl_cfg80211.c:8187:	WL_DBG(("Enter state %d set %d _net_info->pm_restore %d iface %s\n",
wl_cfg80211.c:8188:		state, set, _net_info->pm_restore, _net_info->ndev->name));
wl_cfg80211.c:8196:		if (wl_get_mode_by_netdev(wl, _net_info->ndev) == WL_MODE_AP) {
wl_cfg80211.c:8198:			WL_DBG(("%s:AP power save %s\n", _net_info->ndev->name,
wl_cfg80211.c:8200:			if ((err = wldev_ioctl(_net_info->ndev, WLC_SET_PM,
wl_cfg80211.c:8202:				if (err == -ENODEV)
wl_cfg80211.c:8204:						_net_info->ndev->name));
wl_cfg80211.c:8206:					WL_ERR(("%s:error (%d)\n", _net_info->ndev->name, err));
wl_cfg80211.c:8215:			if ((!wl->vsdb_mode) && (iter->ndev != _net_info->ndev)) {
wl_cfg80211.c:8222:			iter->pm_restore = true;
wl_cfg80211.c:8223:			err = wldev_ioctl(iter->ndev, WLC_GET_PM, &iter->pm,
wl_cfg80211.c:8224:				sizeof(iter->pm), false);
wl_cfg80211.c:8225:			WL_DBG(("%s:power save %s\n", iter->ndev->name,
wl_cfg80211.c:8226:				iter->pm ? "enabled" : "disabled"));
wl_cfg80211.c:8227:			if ((err = wldev_ioctl(iter->ndev, WLC_SET_PM, &pm,
wl_cfg80211.c:8229:				if (err == -ENODEV)
wl_cfg80211.c:8230:					WL_DBG(("%s:netdev not ready\n", iter->ndev->name));
wl_cfg80211.c:8232:					WL_ERR(("%s:error (%d)\n", iter->ndev->name, err));
wl_cfg80211.c:8233:				iter->ndev->ieee80211_ptr->ps = pm ? true: false;
wl_cfg80211.c:8240:		wl_update_prof(wl, _net_info->ndev, NULL, &chan, WL_PROF_CHAN);
wl_cfg80211.c:8243:			if (iter->pm_restore) {
wl_cfg80211.c:8245:					iter->ndev->name, (iter->pm ? "enabled" : "disabled")));
wl_cfg80211.c:8246:				err = wldev_ioctl(iter->ndev,
wl_cfg80211.c:8247:					WLC_SET_PM, &iter->pm, sizeof(iter->pm), true);
wl_cfg80211.c:8249:					if (err == -ENODEV)
wl_cfg80211.c:8250:						WL_DBG(("%s:netdev not ready\n", iter->ndev->name));
wl_cfg80211.c:8252:						WL_ERR(("%s:error(%d)\n", iter->ndev->name, err));
wl_cfg80211.c:8255:				iter->pm_restore = 0;
wl_cfg80211.c:8268:	if (wl->iscan_on) {
wl_cfg80211.c:8269:		iscan->dev = wl_to_prmry_ndev(wl);
wl_cfg80211.c:8270:		iscan->state = WL_ISCAN_STATE_IDLE;
wl_cfg80211.c:8272:		iscan->timer_ms = WL_ISCAN_TIMER_INTERVAL_MS;
wl_cfg80211.c:8273:		init_timer(&iscan->timer);
wl_cfg80211.c:8274:		iscan->timer.data = (unsigned long) iscan;
wl_cfg80211.c:8275:		iscan->timer.function = wl_iscan_timer;
wl_cfg80211.c:8276:		sema_init(&iscan->sync, 0);
wl_cfg80211.c:8277:		iscan->tsk = kthread_run(wl_iscan_thread, iscan, "wl_iscan");
wl_cfg80211.c:8278:		if (IS_ERR(iscan->tsk)) {
wl_cfg80211.c:8280:			iscan->tsk = NULL;
wl_cfg80211.c:8281:			return -ENOMEM;
wl_cfg80211.c:8283:		iscan->data = wl;
wl_cfg80211.c:8284:	} else if (wl->escan_on) {
wl_cfg80211.c:8285:		wl->evt_handler[WLC_E_ESCAN_RESULT] = wl_escan_handler;
wl_cfg80211.c:8286:		wl->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
wl_cfg80211.c:8289:	init_timer(&wl->scan_timeout);
wl_cfg80211.c:8290:	wl->scan_timeout.data = (unsigned long) wl;
wl_cfg80211.c:8291:	wl->scan_timeout.function = wl_scan_timeout;
wl_cfg80211.c:8302:	wl->scan_request = NULL;
wl_cfg80211.c:8303:	wl->pwr_save = !!(wiphy->flags & WIPHY_FLAG_PS_ON_BY_DEFAULT);
wl_cfg80211.c:8304:	wl->iscan_on = false;
wl_cfg80211.c:8305:	wl->escan_on = true;
wl_cfg80211.c:8306:	wl->roam_on = false;
wl_cfg80211.c:8307:	wl->iscan_kickstart = false;
wl_cfg80211.c:8308:	wl->active_scan = true;
wl_cfg80211.c:8309:	wl->rf_blocked = false;
wl_cfg80211.c:8310:	wl->vsdb_mode = false;
wl_cfg80211.c:8311:	wl->wlfc_on = false;
wl_cfg80211.c:8312:	wl->roamoff_on_concurrent = true;
wl_cfg80211.c:8314:	set_bit(WL_STATUS_CONNECTED, &wl->interrested_state);
wl_cfg80211.c:8315:	spin_lock_init(&wl->cfgdrv_lock);
wl_cfg80211.c:8316:	mutex_init(&wl->ioctl_buf_sync);
wl_cfg80211.c:8317:	init_waitqueue_head(&wl->netif_change_event);
wl_cfg80211.c:8318:	init_completion(&wl->send_af_done);
wl_cfg80211.c:8319:	init_completion(&wl->iface_disable);
wl_cfg80211.c:8325:		return -ENOMEM;
wl_cfg80211.c:8327:	mutex_init(&wl->usr_sync);
wl_cfg80211.c:8328:	mutex_init(&wl->event_sync);
wl_cfg80211.c:8332:	wl_init_conf(wl->conf);
wl_cfg80211.c:8346:	del_timer_sync(&wl->scan_timeout);
wl_cfg80211.c:8361:		return -ENODEV;
wl_cfg80211.c:8370:	struct wireless_dev *wdev = wl->p2p_wdev;
wl_cfg80211.c:8375:		return -EINVAL;
wl_cfg80211.c:8380:	wl->p2p_wdev = NULL;
wl_cfg80211.c:8381:	wl->p2p_net = NULL;
wl_cfg80211.c:8396:		return -ENODEV;
wl_cfg80211.c:8401:		return -EINVAL;
wl_cfg80211.c:8404:			if (wl->wdev &&
wl_cfg80211.c:8407:				wl->wdev->wiphy->interface_modes |=
wl_cfg80211.c:8415:				if (wl->p2p_net) {
wl_cfg80211.c:8417:					memcpy(wl->p2p_net->dev_addr, ndev->dev_addr, ETH_ALEN);
wl_cfg80211.c:8418:					wl->p2p_net->dev_addr[0] |= 0x02;
wl_cfg80211.c:8420:						wl->p2p_net->name,
wl_cfg80211.c:8421:						MAC2STRDBG(wl->p2p_net->dev_addr)));
wl_cfg80211.c:8425:					return -ENODEV;
wl_cfg80211.c:8429:				wl->p2p_supported = true;
wl_cfg80211.c:8447:		return -ENODEV;
wl_cfg80211.c:8455:		return -ENOMEM;
wl_cfg80211.c:8460:		return -ENOMEM;
wl_cfg80211.c:8462:	wdev->iftype = wl_mode_to_nl80211_iftype(WL_MODE_BSS);
wl_cfg80211.c:8463:	wl = (struct wl_priv *)wiphy_priv(wdev->wiphy);
wl_cfg80211.c:8464:	wl->wdev = wdev;
wl_cfg80211.c:8465:	wl->pub = data;
wl_cfg80211.c:8466:	INIT_LIST_HEAD(&wl->net_list);
wl_cfg80211.c:8467:	ndev->ieee80211_ptr = wdev;
wl_cfg80211.c:8468:	SET_NETDEV_DEV(ndev, wiphy_dev(wdev->wiphy));
wl_cfg80211.c:8469:	wdev->netdev = ndev;
wl_cfg80211.c:8470:	wl->state_notifier = wl_notifier_change_state;
wl_cfg80211.c:8530:	if (wl->p2p_supported) {
wl_cfg80211.c:8531:		if (timer_pending(&wl->p2p->listen_timer))
wl_cfg80211.c:8532:			del_timer_sync(&wl->p2p->listen_timer);
wl_cfg80211.c:8556:	if (wl->event_tsk.thr_pid >= 0) {
wl_cfg80211.c:8557:		DHD_OS_WAKE_LOCK(wl->pub);
wl_cfg80211.c:8558:		up(&wl->event_tsk.sema);
wl_cfg80211.c:8564:	switch (e->etype) {
wl_cfg80211.c:8575:		if (e->emsg.ifidx != 0) {
wl_cfg80211.c:8577:			e->emsg.ifidx));
wl_cfg80211.c:8586:				" Sent it to p2p0 \n", e->emsg.ifidx));
wl_cfg80211.c:8592:		WL_TRACE(("NON-P2P Event %d on ifidx (ifidx:%d) \n",
wl_cfg80211.c:8593:			e->etype, e->emsg.ifidx));
wl_cfg80211.c:8605:	wl = (struct wl_priv *)tsk->parent;
wl_cfg80211.c:8608:	complete(&tsk->completed);
wl_cfg80211.c:8613:	while (down_interruptible (&tsk->sema) == 0) {
wl_cfg80211.c:8615:		if (tsk->terminated)
wl_cfg80211.c:8618:			WL_DBG(("event type (%d), if idx: %d\n", e->etype, e->emsg.ifidx));
wl_cfg80211.c:8623:			if ((wl_is_p2p_event(e) == TRUE) && (wl->p2p_net)) {
wl_cfg80211.c:8624:				netdev = wl->p2p_net;
wl_cfg80211.c:8626:				netdev = dhd_idx2net((struct dhd_pub *)(wl->pub), e->emsg.ifidx);
wl_cfg80211.c:8630:			if (e->etype < WLC_E_LAST && wl->evt_handler[e->etype]) {
wl_cfg80211.c:8631:				wl->evt_handler[e->etype] (wl, netdev, &e->emsg, e->edata);
wl_cfg80211.c:8633:				WL_DBG(("Unknown Event (%d): ignoring\n", e->etype));
wl_cfg80211.c:8637:		DHD_OS_WAKE_UNLOCK(wl->pub);
wl_cfg80211.c:8640:	complete_and_exit(&tsk->completed, 0);
wl_cfg80211.c:8647:	u32 event_type = ntoh32(e->event_type);
wl_cfg80211.c:8651:	s8 *estr = (event_type <= sizeof(wl_dbg_estr) / WL_DBG_ESTR_MAX - 1) ?
wl_cfg80211.c:8670:	INIT_LIST_HEAD(&wl->eq_list);
wl_cfg80211.c:8679:	while (!list_empty(&wl->eq_list)) {
wl_cfg80211.c:8680:		e = list_first_entry(&wl->eq_list, struct wl_event_q, eq_list);
wl_cfg80211.c:8681:		list_del(&e->eq_list);
wl_cfg80211.c:8697:	if (likely(!list_empty(&wl->eq_list))) {
wl_cfg80211.c:8698:		e = list_first_entry(&wl->eq_list, struct wl_event_q, eq_list);
wl_cfg80211.c:8699:		list_del(&e->eq_list);
wl_cfg80211.c:8723:		data_len = ntoh32(msg->datalen);
wl_cfg80211.c:8729:		return -ENOMEM;
wl_cfg80211.c:8731:	e->etype = event;
wl_cfg80211.c:8732:	memcpy(&e->emsg, msg, sizeof(wl_event_msg_t));
wl_cfg80211.c:8734:		memcpy(e->edata, data, data_len);
wl_cfg80211.c:8736:	list_add_tail(&e->eq_list, &wl->eq_list);
wl_cfg80211.c:8757:		err = -EINVAL;
wl_cfg80211.c:8773:		err = -EINVAL;
wl_cfg80211.c:8794:	if (ev->num < MAX_EVENT_BUF_NUM) {
wl_cfg80211.c:8795:		ev->event[ev->num].type = event;
wl_cfg80211.c:8796:		ev->event[ev->num].set = set;
wl_cfg80211.c:8797:		ev->num++;
wl_cfg80211.c:8814:	if (!ev || (!ev->num))
wl_cfg80211.c:8815:		return -EINVAL;
wl_cfg80211.c:8817:	mutex_lock(&wl->event_sync);
wl_cfg80211.c:8830:	for (i = 0; i < ev->num; i++) {
wl_cfg80211.c:8831:		if (ev->event[i].set)
wl_cfg80211.c:8832:			setbit(eventmask, ev->event[i].type);
wl_cfg80211.c:8834:			clrbit(eventmask, ev->event[i].type);
wl_cfg80211.c:8846:	mutex_unlock(&wl->event_sync);
wl_cfg80211.c:8858:		return -ENODEV;
wl_cfg80211.c:8860:	mutex_lock(&wl->event_sync);
wl_cfg80211.c:8885:	mutex_unlock(&wl->event_sync);
wl_cfg80211.c:8907:		return -ENOMEM;
wl_cfg80211.c:8910:	list->count = htod32(WL_NUMCHANSPECS);
wl_cfg80211.c:8914:		0, pbuf, LOCAL_BUF_LEN, 0, &wl->ioctl_buf_sync);
wl_cfg80211.c:8924:	for (i = 0; i < dtoh32(list->count); i++) {
wl_cfg80211.c:8928:		c = (chanspec_t)dtoh32(list->element[i]);
wl_cfg80211.c:8935:				channel -= CH_10MHZ_APART;
wl_cfg80211.c:9040:	s32 cur_band = -1;
wl_cfg80211.c:9045:		mutex_lock(&wl->usr_sync);
wl_cfg80211.c:9089:		index = -1;
wl_cfg80211.c:9095:				bands[index]->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;
wl_cfg80211.c:9102:				bands[index]->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;
wl_cfg80211.c:9106:			bands[index]->ht_cap.cap |=
wl_cfg80211.c:9108:			bands[index]->ht_cap.ht_supported = TRUE;
wl_cfg80211.c:9109:			bands[index]->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
wl_cfg80211.c:9110:			bands[index]->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;
wl_cfg80211.c:9112:			bands[index]->ht_cap.mcs.rx_mask[0] = 0xff;
wl_cfg80211.c:9117:	wiphy->bands[IEEE80211_BAND_2GHZ] = bands[IEEE80211_BAND_2GHZ];
wl_cfg80211.c:9118:	wiphy->bands[IEEE80211_BAND_5GHZ] = bands[IEEE80211_BAND_5GHZ];
wl_cfg80211.c:9125:		mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:9133:	struct wireless_dev *wdev = ndev->ieee80211_ptr;
wl_cfg80211.c:9141:	err = wl_config_ifmode(wl, ndev, wdev->iftype);
wl_cfg80211.c:9142:	if (unlikely(err && err != -EINPROGRESS)) {
wl_cfg80211.c:9150:	err = dhd_monitor_init(wl->pub);
wl_cfg80211.c:9157:		err = -1;
wl_cfg80211.c:9163:	init_timer(&wl->scan_supp_timer);
wl_cfg80211.c:9164:	wl->scan_supp_timer.data = (ulong)wl;
wl_cfg80211.c:9165:	wl->scan_supp_timer.function = wl_cfg80211_scan_supp_timerfunc;
wl_cfg80211.c:9166:	INIT_WORK(&wl->wlan_work, wl_cfg80211_work_handler);
wl_cfg80211.c:9179:	struct net_device *p2p_net = wl->p2p_net;
wl_cfg80211.c:9185:	if (wl->scan_suppressed)
wl_cfg80211.c:9187:	if (timer_pending(&wl->scan_supp_timer))
wl_cfg80211.c:9188:		del_timer_sync(&wl->scan_supp_timer);
wl_cfg80211.c:9189:	cancel_work_sync(&wl->wlan_work);
wl_cfg80211.c:9203:		wl_set_drv_status(wl, SCAN_ABORTING, iter->ndev);
wl_cfg80211.c:9206:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:9207:	if (wl->scan_request) {
wl_cfg80211.c:9208:		cfg80211_scan_done(wl->scan_request, true);
wl_cfg80211.c:9209:		wl->scan_request = NULL;
wl_cfg80211.c:9211:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:9214:		wl_clr_drv_status(wl, READY, iter->ndev);
wl_cfg80211.c:9215:		wl_clr_drv_status(wl, SCANNING, iter->ndev);
wl_cfg80211.c:9216:		wl_clr_drv_status(wl, SCAN_ABORTING, iter->ndev);
wl_cfg80211.c:9217:		wl_clr_drv_status(wl, CONNECTING, iter->ndev);
wl_cfg80211.c:9218:		wl_clr_drv_status(wl, CONNECTED, iter->ndev);
wl_cfg80211.c:9219:		wl_clr_drv_status(wl, DISCONNECTING, iter->ndev);
wl_cfg80211.c:9220:		wl_clr_drv_status(wl, AP_CREATED, iter->ndev);
wl_cfg80211.c:9221:		wl_clr_drv_status(wl, AP_CREATING, iter->ndev);
wl_cfg80211.c:9223:	wl_to_prmry_ndev(wl)->ieee80211_ptr->iftype =
wl_cfg80211.c:9230:	if (wl->p2p_supported)
wl_cfg80211.c:9262:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:9263:	dhd = (dhd_pub_t *)(wl->pub);
wl_cfg80211.c:9264:	if (!(dhd->op_mode & DHD_FLAG_HOSTAP_MODE)) {
wl_cfg80211.c:9272:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:9305:	mutex_lock(&wl->usr_sync);
wl_cfg80211.c:9314:	mutex_unlock(&wl->usr_sync);
wl_cfg80211.c:9327:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:9330:		rptr = &profile->sec;
wl_cfg80211.c:9333:		rptr = &profile->active;
wl_cfg80211.c:9336:		rptr = profile->bssid;
wl_cfg80211.c:9339:		rptr = &profile->ssid;
wl_cfg80211.c:9342:		rptr = &profile->channel;
wl_cfg80211.c:9345:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:9362:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:9366:		memset(profile->ssid.SSID, 0,
wl_cfg80211.c:9367:			sizeof(profile->ssid.SSID));
wl_cfg80211.c:9368:		memcpy(profile->ssid.SSID, ssid->SSID, ssid->SSID_len);
wl_cfg80211.c:9369:		profile->ssid.SSID_len = ssid->SSID_len;
wl_cfg80211.c:9373:			memcpy(profile->bssid, data, ETHER_ADDR_LEN);
wl_cfg80211.c:9375:			memset(profile->bssid, 0, ETHER_ADDR_LEN);
wl_cfg80211.c:9378:		memcpy(&profile->sec, data, sizeof(profile->sec));
wl_cfg80211.c:9381:		profile->active = *(bool *)data;
wl_cfg80211.c:9384:		profile->beacon_interval = *(u16 *)data;
wl_cfg80211.c:9387:		profile->dtim_period = *(u8 *)data;
wl_cfg80211.c:9390:		profile->channel = *(u32*)data;
wl_cfg80211.c:9392:		err = -EOPNOTSUPP;
wl_cfg80211.c:9395:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfg80211.c:9421:	return wl->ibss_starter;
wl_cfg80211.c:9428:	ie->offset = 0;
wl_cfg80211.c:9436:	if (unlikely(ie->offset + l + 2 > WL_TLV_INFO_MAX)) {
wl_cfg80211.c:9438:		return -ENOSPC;
wl_cfg80211.c:9440:	ie->buf[ie->offset] = t;
wl_cfg80211.c:9441:	ie->buf[ie->offset + 1] = l;
wl_cfg80211.c:9442:	memcpy(&ie->buf[ie->offset + 2], v, l);
wl_cfg80211.c:9443:	ie->offset += l + 2;
wl_cfg80211.c:9453:	if (unlikely(ie->offset + ie_size > WL_TLV_INFO_MAX)) {
wl_cfg80211.c:9455:		return -ENOSPC;
wl_cfg80211.c:9457:	memcpy(&ie->buf[ie->offset], ie_stream, ie_size);
wl_cfg80211.c:9458:	ie->offset += ie_size;
wl_cfg80211.c:9468:	if (unlikely(ie->offset > dst_size)) {
wl_cfg80211.c:9470:		return -ENOSPC;
wl_cfg80211.c:9472:	memcpy(dst, &ie->buf[0], ie->offset);
wl_cfg80211.c:9481:	return ie->offset;
wl_cfg80211.c:9486:	wl->link_up = true;
wl_cfg80211.c:9494:	wl->link_up = false;
wl_cfg80211.c:9495:	conn_info->req_ie_len = 0;
wl_cfg80211.c:9496:	conn_info->resp_ie_len = 0;
wl_cfg80211.c:9503:	spin_lock_irqsave(&wl->eq_lock, flags);
wl_cfg80211.c:9509:	spin_unlock_irqrestore(&wl->eq_lock, flags);
wl_cfg80211.c:9514:	spin_lock_init(&wl->eq_lock);
wl_cfg80211.c:9531:	if (!wl->p2p)
wl_cfg80211.c:9532:		return -1;
wl_cfg80211.c:9537:		memcpy(p2pdev_addr->octet,
wl_cfg80211.c:9538:			wl->p2p->dev_addr.octet, ETHER_ADDR_LEN);
wl_cfg80211.c:9603:	} else if (wl->p2p) {
wl_cfg80211.c:9604:		if (net == wl->p2p_net) {
wl_cfg80211.c:9607:		if (!wl->p2p->on) {
wl_cfg80211.c:9609:			wl_cfgp2p_generate_bss_mac(&primary_mac, &wl->p2p->dev_addr,
wl_cfg80211.c:9610:				&wl->p2p->int_addr);
wl_cfg80211.c:9663:		return -EINVAL;
wl_cfg80211.c:9665:	wl->rf_blocked = blocked;
wl_cfg80211.c:9676:		return -EINVAL;
wl_cfg80211.c:9678:		wl->rfkill = rfkill_alloc("brcmfmac-wifi",
wl_cfg80211.c:9682:		if (!wl->rfkill) {
wl_cfg80211.c:9683:			err = -ENOMEM;
wl_cfg80211.c:9687:		err = rfkill_register(wl->rfkill);
wl_cfg80211.c:9690:			rfkill_destroy(wl->rfkill);
wl_cfg80211.c:9692:		if (!wl->rfkill) {
wl_cfg80211.c:9693:			err = -ENOMEM;
wl_cfg80211.c:9697:		rfkill_unregister(wl->rfkill);
wl_cfg80211.c:9698:		rfkill_destroy(wl->rfkill);
wl_cfg80211.c:9723:		0, wl->ioctl_buf, WLC_IOCTL_SMLEN, 0, &wl->ioctl_buf_sync);
wl_cfg80211.c:9724:	memcpy(mac->octet, wl->ioctl_buf, ETHER_ADDR_LEN);
wl_cfg80211.c:9731:	if (!wl || !wl->wdev)
wl_cfg80211.c:9732:		return -EINVAL;
wl_cfg80211.c:9734:	if (dhd_do_driver_init(wl->wdev->netdev) < 0)
wl_cfg80211.c:9735:		return -1;
wl_cfg80211.c:9791:		return -1;
wl_cfg80211.c:9797:	buf_len = sizeof(ie_setbuf_t) + data_len - 1;
wl_cfg80211.c:9802:		return -ENOMEM;
wl_cfg80211.c:9805:	if (wl->iw_ie_len == data_len && !memcmp(wl->iw_ie, data, data_len)) {
wl_cfg80211.c:9810:	strncpy(ie_setbuf->cmd, "add", VNDR_IE_CMD_LEN - 1);
wl_cfg80211.c:9811:	ie_setbuf->cmd[VNDR_IE_CMD_LEN - 1] = '\0';
wl_cfg80211.c:9815:	memcpy((void *)&ie_setbuf->ie_buffer.iecount, &iecount, sizeof(int));
wl_cfg80211.c:9816:	memcpy((void *)&ie_setbuf->ie_buffer.ie_list[0].pktflag, &pktflag, sizeof(uint32));
wl_cfg80211.c:9819:	ie_setbuf->ie_buffer.ie_list[0].ie_data.id = ie_id;
wl_cfg80211.c:9822:	if (wl->iw_ie_len != 0) {
wl_cfg80211.c:9825:		ie_setbuf->ie_buffer.ie_list[0].ie_data.len = 0;
wl_cfg80211.c:9828:			wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:9834:	ie_setbuf->ie_buffer.ie_list[0].ie_data.len = data_len;
wl_cfg80211.c:9835:	memcpy((uchar *)&ie_setbuf->ie_buffer.ie_list[0].ie_data.data[0], data, data_len);
wl_cfg80211.c:9838:		wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
wl_cfg80211.c:9841:		memcpy(wl->iw_ie, data, data_len);
wl_cfg80211.c:9842:		wl->iw_ie_len = data_len;
wl_cfg80211.c:9843:		wl->wl11u = TRUE;
wl_cfg80211.c:9863:		return -EINVAL;
wl_cfg80211.c:9873:	wl->curr_band = band;
wl_cfg80211.c:9885:	schedule_work(&wl->wlan_work);
wl_cfg80211.c:9899:	if (wl->scan_suppressed) {
wl_cfg80211.c:9912:		return -EINVAL;
wl_cfg80211.c:9914:	if (suppress == wl->scan_suppressed) {
wl_cfg80211.c:9919:	if (timer_pending(&wl->scan_supp_timer))
wl_cfg80211.c:9920:		del_timer_sync(&wl->scan_supp_timer);
wl_cfg80211.c:9927:		wl->scan_suppressed = suppress;
wl_cfg80211.c:9931:	if (wl->scan_suppressed) {
wl_cfg80211.c:9934:			mod_timer(&wl->scan_supp_timer,
wl_cfg80211.c:9938:			mod_timer(&wl->scan_supp_timer,
wl_cfg80211.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
wl_cfg80211.h:24: * $Id: wl_cfg80211.h 374275 2012-12-12 11:44:18Z $
wl_cfg80211.h:65:#define CFG80211_ERROR_TEXT		"CFG80211-ERROR) "
wl_cfg80211.h:91:			printk(KERN_INFO "CFG80211-INFO) %s : ", __func__);	\
wl_cfg80211.h:101:		printk(KERN_INFO "CFG80211-SCAN) %s :", __func__);	\
wl_cfg80211.h:111:		printk(KERN_INFO "CFG80211-TRACE) %s :", __func__);	\
wl_cfg80211.h:123:		printk(KERN_DEBUG "CFG80211-DEBUG) %s :", __func__);	\
wl_cfg80211.h:161:#define WL_INVALID 		-1
wl_cfg80211.h:211:/* wi-fi mode */
wl_cfg80211.h:392:	pmkid_t foo[MAXPMKID - 1];
wl_cfg80211.h:543:	bool roam_on;		/* on/off switch for self-roaming */
wl_cfg80211.h:594:		(struct wl_bss_info *)((uintptr) bss + dtoh32(bss->length)) : list->bss_info;
wl_cfg80211.h:602:	if (wl->iface_cnt == IFACE_MAX_CNT)
wl_cfg80211.h:603:		return -ENOMEM;
wl_cfg80211.h:606:		err = -ENOMEM;
wl_cfg80211.h:608:		_net_info->mode = mode;
wl_cfg80211.h:609:		_net_info->ndev = ndev;
wl_cfg80211.h:610:		_net_info->wdev = wdev;
wl_cfg80211.h:611:		_net_info->pm_restore = 0;
wl_cfg80211.h:612:		_net_info->pm = 0;
wl_cfg80211.h:613:		_net_info->pm_block = pm_block;
wl_cfg80211.h:614:		_net_info->roam_off = WL_INVALID;
wl_cfg80211.h:615:		wl->iface_cnt++;
wl_cfg80211.h:616:		list_add(&_net_info->list, &wl->net_list);
wl_cfg80211.h:625:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:626:		if (ndev && (_net_info->ndev == ndev)) {
wl_cfg80211.h:627:			list_del(&_net_info->list);
wl_cfg80211.h:628:			wl->iface_cnt--;
wl_cfg80211.h:629:			if (_net_info->wdev) {
wl_cfg80211.h:630:				kfree(_net_info->wdev);
wl_cfg80211.h:631:				ndev->ieee80211_ptr = NULL;
wl_cfg80211.h:643:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:644:		list_del(&_net_info->list);
wl_cfg80211.h:645:			if (_net_info->wdev)
wl_cfg80211.h:646:				kfree(_net_info->wdev);
wl_cfg80211.h:649:	wl->iface_cnt = 0;
wl_cfg80211.h:657:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:658:		if (_net_info->ndev &&
wl_cfg80211.h:659:			test_bit(status, &_net_info->sme_state))
wl_cfg80211.h:668:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:673:				clear_bit(status, &_net_info->sme_state);
wl_cfg80211.h:674:				if (wl->state_notifier &&
wl_cfg80211.h:675:					test_bit(status, &(wl->interrested_state)))
wl_cfg80211.h:676:					wl->state_notifier(wl, _net_info, status, false);
wl_cfg80211.h:692:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:693:		if (ndev && (_net_info->ndev == ndev)) {
wl_cfg80211.h:696:					set_bit(status, &_net_info->sme_state);
wl_cfg80211.h:697:					if (wl->state_notifier &&
wl_cfg80211.h:698:						test_bit(status, &(wl->interrested_state)))
wl_cfg80211.h:699:						wl->state_notifier(wl, _net_info, status, true);
wl_cfg80211.h:702:					clear_bit(status, &_net_info->sme_state);
wl_cfg80211.h:703:					if (wl->state_notifier &&
wl_cfg80211.h:704:						test_bit(status, &(wl->interrested_state)))
wl_cfg80211.h:705:						wl->state_notifier(wl, _net_info, status, false);
wl_cfg80211.h:708:					change_bit(status, &_net_info->sme_state);
wl_cfg80211.h:723:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:724:				if (ndev && (_net_info->ndev == ndev))
wl_cfg80211.h:725:					return test_bit(status, &_net_info->sme_state);
wl_cfg80211.h:735:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:736:				if (ndev && (_net_info->ndev == ndev))
wl_cfg80211.h:737:					return _net_info->mode;
wl_cfg80211.h:739:	return -1;
wl_cfg80211.h:749:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:750:				if (ndev && (_net_info->ndev == ndev))
wl_cfg80211.h:751:					_net_info->mode = mode;
wl_cfg80211.h:759:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:760:				if (ndev && (_net_info->ndev == ndev))
wl_cfg80211.h:761:					return &_net_info->profile;
wl_cfg80211.h:770:	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
wl_cfg80211.h:771:				if (ndev && (_net_info->ndev == ndev))
wl_cfg80211.h:776:#define wl_to_wiphy(w) (w->wdev->wiphy)
wl_cfg80211.h:777:#define wl_to_prmry_ndev(w) (w->wdev->netdev)
wl_cfg80211.h:778:#define ndev_to_wl(n) (wdev_to_wl(n->ieee80211_ptr))
wl_cfg80211.h:779:#define wl_to_sr(w) (w->scan_req_int)
wl_cfg80211.h:781:#define wl_to_ie(w) (w->ie)
wl_cfg80211.h:782:#define wl_to_conn(w) (w->conn_info)
wl_cfg80211.h:784:#define wl_to_ie(w) (&w->ie)
wl_cfg80211.h:785:#define wl_to_conn(w) (&w->conn_info)
wl_cfg80211.h:787:#define iscan_to_wl(i) ((struct wl_priv *)(i->data))
wl_cfg80211.h:788:#define wl_to_iscan(w) (w->iscan)
wl_cfg80211.h:789:#define wiphy_from_scan(w) (w->escan_info.wiphy)
wl_cfg80211.h:804:	for (__i = 0; __i < list->count && __i < WL_AP_MAX; __i++, bss = next_bss(list, bss))
wl_cfg80211.h:807:	list_for_each_entry_safe(iter, next, &wl->net_list, list)
wl_cfg80211.h:814:	((wl_cfgp2p_find_wpsie((u8 *)_sme->ie, _sme->ie_len) != NULL) && \
wl_cfg80211.h:815:	 (!_sme->crypto.n_ciphers_pairwise) && \
wl_cfg80211.h:816:	 (!_sme->crypto.cipher_group))
wl_cfgp2p.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
wl_cfgp2p.c:24: * $Id: wl_cfgp2p.c 372668 2012-12-04 14:07:12Z $
wl_cfgp2p.c:80:	if (frame_len < sizeof(wifi_p2p_pub_act_frame_t) -1)
wl_cfgp2p.c:83:	if (pact_frm->category == P2P_PUB_AF_CATEGORY &&
wl_cfgp2p.c:84:		pact_frm->action == P2P_PUB_AF_ACTION &&
wl_cfgp2p.c:85:		pact_frm->oui_type == P2P_VER &&
wl_cfgp2p.c:86:		memcmp(pact_frm->oui, P2P_OUI, sizeof(pact_frm->oui)) == 0) {
wl_cfgp2p.c:100:	if (frame_len < sizeof(wifi_p2p_action_frame_t) -1)
wl_cfgp2p.c:103:	if (act_frm->category == P2P_AF_CATEGORY &&
wl_cfgp2p.c:104:		act_frm->type  == P2P_VER &&
wl_cfgp2p.c:105:		memcmp(act_frm->OUI, P2P_OUI, DOT11_OUI_LEN) == 0) {
wl_cfgp2p.c:135:	frame = (uint8 *)ie + ie->len + TLV_HDR_LEN + GAS_RESP_LEN;
wl_cfgp2p.c:160:	if (frame_len < sizeof(wifi_p2psd_gas_pub_act_frame_t) - 1)
wl_cfgp2p.c:162:	if (sd_act_frm->category != P2PSD_ACTION_CATEGORY)
wl_cfgp2p.c:166:	if (sd_act_frm->action == P2PSD_ACTION_ID_GAS_IRESP)
wl_cfgp2p.c:168:			(u8 *)sd_act_frm->query_data + GAS_RESP_OFFSET,
wl_cfgp2p.c:171:	else if (sd_act_frm->action == P2PSD_ACTION_ID_GAS_CRESP)
wl_cfgp2p.c:173:			(u8 *)sd_act_frm->query_data + GAS_CRESP_OFFSET,
wl_cfgp2p.c:175:	else if (sd_act_frm->action == P2PSD_ACTION_ID_GAS_IREQ ||
wl_cfgp2p.c:176:		sd_act_frm->action == P2PSD_ACTION_ID_GAS_CREQ)
wl_cfgp2p.c:181:	if (sd_act_frm->action == P2PSD_ACTION_ID_GAS_IREQ ||
wl_cfgp2p.c:182:		sd_act_frm->action == P2PSD_ACTION_ID_GAS_IRESP ||
wl_cfgp2p.c:183:		sd_act_frm->action == P2PSD_ACTION_ID_GAS_CREQ ||
wl_cfgp2p.c:184:		sd_act_frm->action == P2PSD_ACTION_ID_GAS_CRESP)
wl_cfgp2p.c:200:		switch (pact_frm->subtype) {
wl_cfgp2p.c:245:		switch (act_frm->subtype) {
wl_cfgp2p.c:269:		switch (sd_act_frm->action) {
wl_cfgp2p.c:302:	if (!(wl->p2p = kzalloc(sizeof(struct p2p_info), GFP_KERNEL))) {
wl_cfgp2p.c:304:		return -ENOMEM;
wl_cfgp2p.c:346:	if (wl->p2p) {
wl_cfgp2p.c:347:		kfree(wl->p2p);
wl_cfgp2p.c:348:		wl->p2p = NULL;
wl_cfgp2p.c:350:	wl->p2p_supported = 0;
wl_cfgp2p.c:384:		sizeof(null_eth_addr), wl->ioctl_buf, WLC_IOCTL_MAXLEN, 0, &wl->ioctl_buf_sync);
wl_cfgp2p.c:409:	memcpy(ifreq.addr.octet, mac->octet, sizeof(ifreq.addr.octet));
wl_cfgp2p.c:411:	CFGP2P_DBG(("---wl p2p_ifadd "MACDBG" %s %u\n",
wl_cfgp2p.c:417:		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
wl_cfgp2p.c:440:	CFGP2P_INFO(("------primary idx %d : wl p2p_ifdis "MACDBG"\n",
wl_cfgp2p.c:441:		netdev->ifindex, MAC2STRDBG(mac->octet)));
wl_cfgp2p.c:443:		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
wl_cfgp2p.c:461:	CFGP2P_INFO(("------primary idx %d : wl p2p_ifdel "MACDBG"\n",
wl_cfgp2p.c:462:	    netdev->ifindex, MAC2STRDBG(mac->octet)));
wl_cfgp2p.c:464:		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
wl_cfgp2p.c:488:	memcpy(ifreq.addr.octet, mac->octet, sizeof(ifreq.addr.octet));
wl_cfgp2p.c:490:	CFGP2P_INFO(("---wl p2p_ifchange "MACDBG" %s %u"
wl_cfgp2p.c:497:		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
wl_cfgp2p.c:523:	CFGP2P_INFO(("---wl p2p_if "MACDBG"\n", MAC2STRDBG(mac->octet)));
wl_cfgp2p.c:530:		CFGP2P_INFO(("---wl p2p_if   ==> %d\n", *index));
wl_cfgp2p.c:571:		return -1;
wl_cfgp2p.c:585:		sizeof(discovery_mode), wl->ioctl_buf, WLC_IOCTL_MAXLEN,
wl_cfgp2p.c:586:		bssidx, &wl->ioctl_buf_sync);
wl_cfgp2p.c:664:		return -1;
wl_cfgp2p.c:714:	/* Set wsec to any non-zero value in the discovery bsscfg to ensure our
wl_cfgp2p.c:797:		num_chans * sizeof(eparams->params.channel_list[0]);
wl_cfgp2p.c:804:		return -1;
wl_cfgp2p.c:807:	memset(wl->ioctl_buf, 0, WLC_IOCTL_MAXLEN);
wl_cfgp2p.c:823:		strncpy(ssid.SSID, WL_P2P_WILDCARD_SSID, sizeof(ssid.SSID) - 1);
wl_cfgp2p.c:824:		ssid.SSID[sizeof(ssid.SSID) - 1] = 0;
wl_cfgp2p.c:830:		return -1;
wl_cfgp2p.c:836:	p2p_params->type = 'E';
wl_cfgp2p.c:839:	eparams->params.bss_type = DOT11_BSSTYPE_ANY;
wl_cfgp2p.c:841:		eparams->params.scan_type = DOT11_SCANTYPE_ACTIVE;
wl_cfgp2p.c:843:		eparams->params.scan_type = DOT11_SCANTYPE_PASSIVE;
wl_cfgp2p.c:845:	memcpy(&eparams->params.bssid, &ether_bcast, ETHER_ADDR_LEN);
wl_cfgp2p.c:847:		memcpy(&eparams->params.ssid, &ssid, sizeof(wlc_ssid_t));
wl_cfgp2p.c:849:	eparams->params.home_time = htod32(P2PAPI_SCAN_HOME_TIME_MS);
wl_cfgp2p.c:855:		eparams->params.active_time = htod32(P2PAPI_SCAN_SOCIAL_DWELL_TIME_MS);
wl_cfgp2p.c:857:		eparams->params.active_time = htod32(P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS);
wl_cfgp2p.c:859:		eparams->params.active_time = -1;
wl_cfgp2p.c:861:		eparams->params.active_time = htod32(P2PAPI_SCAN_DWELL_TIME_MS);
wl_cfgp2p.c:862:	eparams->params.nprobes = htod32((eparams->params.active_time /
wl_cfgp2p.c:867:		eparams->params.active_time = htod32(WL_SCAN_CONNECT_DWELL_TIME_MS);
wl_cfgp2p.c:868:		eparams->params.nprobes = htod32(eparams->params.active_time /
wl_cfgp2p.c:872:	if (eparams->params.nprobes <= 0)
wl_cfgp2p.c:873:		eparams->params.nprobes = 1;
wl_cfgp2p.c:875:		eparams->params.nprobes, eparams->params.active_time));
wl_cfgp2p.c:876:	eparams->params.passive_time = htod32(-1);
wl_cfgp2p.c:877:	eparams->params.channel_num = htod32((0 << WL_SCAN_PARAMS_NSSID_SHIFT) |
wl_cfgp2p.c:881:		eparams->params.channel_list[i] = wl_ch_host_to_driver(channels[i]);
wl_cfgp2p.c:883:	eparams->version = htod32(ESCAN_REQ_VERSION);
wl_cfgp2p.c:884:	eparams->action =  htod16(action);
wl_cfgp2p.c:885:	eparams->sync_id = htod16(0x1234);
wl_cfgp2p.c:896:		memblk, memsize, wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
wl_cfgp2p.c:917:		return -BCME_ERROR;
wl_cfgp2p.c:928:		ret = -ENOMEM;
wl_cfgp2p.c:950:/* Check whether pointed-to IE looks like WPA. */
wl_cfgp2p.c:953:/* Check whether pointed-to IE looks like WPS. */
wl_cfgp2p.c:978:	WL_INFO(("---> len %d\n", len));
wl_cfgp2p.c:985:		if (ie->id == DOT11_MNG_VS_ID) {
wl_cfgp2p.c:988:			if (vndrie->len < (VNDR_IE_MIN_LEN + 1)) {
wl_cfgp2p.c:990:					__FUNCTION__, vndrie->len));
wl_cfgp2p.c:994:			if (!bcmp(vndrie->oui, (u8*)WPA_OUI, WPA_OUI_LEN) &&
wl_cfgp2p.c:995:				((vndrie->data[0] == WPA_OUI_TYPE) ||
wl_cfgp2p.c:996:				(vndrie->data[0] == WME_OUI_TYPE))) {
wl_cfgp2p.c:1001:			parsed_info = &vndr_ies->ie_info[count++];
wl_cfgp2p.c:1004:			parsed_info->ie_ptr = (char *)vndrie;
wl_cfgp2p.c:1005:			parsed_info->ie_len = (vndrie->len + TLV_HDR_LEN);
wl_cfgp2p.c:1006:			memcpy(&parsed_info->vndrie, vndrie, sizeof(vndr_ie_t));
wl_cfgp2p.c:1008:			vndr_ies->count = count;
wl_cfgp2p.c:1011:				parsed_info->vndrie.oui[0], parsed_info->vndrie.oui[1],
wl_cfgp2p.c:1012:				parsed_info->vndrie.oui[2], parsed_info->vndrie.data[0]));
wl_cfgp2p.c:1056:	if (wl->p2p != NULL) {
wl_cfgp2p.c:1087:				return -1;
wl_cfgp2p.c:1092:				mgmt_ie_buf = wl->ap_info->probe_res_ie;
wl_cfgp2p.c:1093:				mgmt_ie_len = &wl->ap_info->probe_res_ie_len;
wl_cfgp2p.c:1094:				mgmt_ie_buf_len = sizeof(wl->ap_info->probe_res_ie);
wl_cfgp2p.c:1097:				mgmt_ie_buf = wl->ap_info->beacon_ie;
wl_cfgp2p.c:1098:				mgmt_ie_len = &wl->ap_info->beacon_ie_len;
wl_cfgp2p.c:1099:				mgmt_ie_buf_len = sizeof(wl->ap_info->beacon_ie);
wl_cfgp2p.c:1105:				return -1;
wl_cfgp2p.c:1111:				mgmt_ie_buf = wl->sta_info->probe_req_ie;
wl_cfgp2p.c:1112:				mgmt_ie_len = &wl->sta_info->probe_req_ie_len;
wl_cfgp2p.c:1113:				mgmt_ie_buf_len = sizeof(wl->sta_info->probe_req_ie);
wl_cfgp2p.c:1116:				mgmt_ie_buf = wl->sta_info->assoc_req_ie;
wl_cfgp2p.c:1117:				mgmt_ie_len = &wl->sta_info->assoc_req_ie_len;
wl_cfgp2p.c:1118:				mgmt_ie_buf_len = sizeof(wl->sta_info->assoc_req_ie);
wl_cfgp2p.c:1124:				return -1;
wl_cfgp2p.c:1129:		return -1;
wl_cfgp2p.c:1134:		ret = -ENOMEM;
wl_cfgp2p.c:1147:				memcpy(ptr + parsed_ie_buf_len, vndrie_info->ie_ptr,
wl_cfgp2p.c:1148:					vndrie_info->ie_len);
wl_cfgp2p.c:1149:				parsed_ie_buf_len += vndrie_info->ie_len;
wl_cfgp2p.c:1170:					vndrie_info->vndrie.id, vndrie_info->vndrie.len,
wl_cfgp2p.c:1171:					vndrie_info->vndrie.oui[0], vndrie_info->vndrie.oui[1],
wl_cfgp2p.c:1172:					vndrie_info->vndrie.oui[2]));
wl_cfgp2p.c:1175:					bssidx, pktflag, vndrie_info->vndrie.oui,
wl_cfgp2p.c:1176:					vndrie_info->vndrie.id,
wl_cfgp2p.c:1177:					vndrie_info->ie_ptr + VNDR_IE_FIXED_LEN,
wl_cfgp2p.c:1178:					vndrie_info->ie_len - VNDR_IE_FIXED_LEN,
wl_cfgp2p.c:1199:					vndrie_info->vndrie.id, vndrie_info->vndrie.len,
wl_cfgp2p.c:1200:					vndrie_info->ie_len - 2,
wl_cfgp2p.c:1201:					vndrie_info->vndrie.oui[0], vndrie_info->vndrie.oui[1],
wl_cfgp2p.c:1202:					vndrie_info->vndrie.oui[2]));
wl_cfgp2p.c:1205:					bssidx, pktflag, vndrie_info->vndrie.oui,
wl_cfgp2p.c:1206:					vndrie_info->vndrie.id,
wl_cfgp2p.c:1207:					vndrie_info->ie_ptr + VNDR_IE_FIXED_LEN,
wl_cfgp2p.c:1208:					vndrie_info->ie_len - VNDR_IE_FIXED_LEN,
wl_cfgp2p.c:1212:				if (remained_buf_len >= vndrie_info->ie_len) {
wl_cfgp2p.c:1213:					remained_buf_len -= vndrie_info->ie_len;
wl_cfgp2p.c:1219:						*mgmt_ie_len, vndrie_info->ie_len));
wl_cfgp2p.c:1224:				memcpy(ptr + (*mgmt_ie_len), vndrie_info->ie_ptr,
wl_cfgp2p.c:1225:					vndrie_info->ie_len);
wl_cfgp2p.c:1226:				*mgmt_ie_len += vndrie_info->ie_len;
wl_cfgp2p.c:1234:				total_ie_buf_len, wl->ioctl_buf, WLC_IOCTL_MAXLEN,
wl_cfgp2p.c:1235:				bssidx, &wl->ioctl_buf_sync);
wl_cfgp2p.c:1258:	s32 index = -1;
wl_cfgp2p.c:1302:	*tlvs_len -= (int)(ie - *tlvs);
wl_cfgp2p.c:1373:		return -1;
wl_cfgp2p.c:1377:	strncpy(hdr.cmd, add_del_cmd, VNDR_IE_CMD_LEN - 1);
wl_cfgp2p.c:1378:	hdr.cmd[VNDR_IE_CMD_LEN - 1] = '\0';
wl_cfgp2p.c:1380:	/* Set the IE count - the buffer contains only 1 IE */
wl_cfgp2p.c:1402:	memcpy(iebuf, &hdr, sizeof(hdr) - 1);
wl_cfgp2p.c:1406:		(u8*)&hdr.vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.data[0] -
wl_cfgp2p.c:1424:	s32 index = -1;
wl_cfgp2p.c:1430:	if (!wl->p2p_supported) {
wl_cfgp2p.c:1439:	if (index == -1)
wl_cfgp2p.c:1475:	if (!wl || !wl->p2p)
wl_cfgp2p.c:1477:	if (wl->p2p_net == ndev) {
wl_cfgp2p.c:1485:		if (timer_pending(&wl->p2p->listen_timer)) {
wl_cfgp2p.c:1486:			del_timer_sync(&wl->p2p->listen_timer);
wl_cfgp2p.c:1489:		if (wl->afx_hdl->is_listen == TRUE &&
wl_cfgp2p.c:1492:			complete(&wl->act_frm_scan);
wl_cfgp2p.c:1498:				jiffies_to_msecs(jiffies - wl->af_tx_sent_jiffies)));
wl_cfgp2p.c:1503:			complete(&wl->wait_next_af);
wl_cfgp2p.c:1518:			if (ndev && (ndev->ieee80211_ptr != NULL)) {
wl_cfgp2p.c:1519:				cfg80211_remain_on_channel_expired(ndev, wl->last_roc_id,
wl_cfgp2p.c:1520:					&wl->remain_on_chan, wl->remain_on_chan_type, GFP_KERNEL);
wl_cfgp2p.c:1547:	wl_cfg80211_event(wl->p2p_net ? wl->p2p_net :
wl_cfgp2p.c:1561:	if (timer_pending(&wl->p2p->listen_timer)) {
wl_cfgp2p.c:1562:		del_timer_sync(&wl->p2p->listen_timer);
wl_cfgp2p.c:1564:			if (ndev && ndev->ieee80211_ptr) {
wl_cfgp2p.c:1565:				cfg80211_remain_on_channel_expired(ndev, wl->last_roc_id,
wl_cfgp2p.c:1566:				 &wl->remain_on_chan, wl->remain_on_chan_type,
wl_cfgp2p.c:1600:	if (timer_pending(&wl->p2p->listen_timer)) {
wl_cfgp2p.c:1615:	_timer = &wl->p2p->listen_timer;
wl_cfgp2p.c:1675:	u32 event_type = ntoh32(e->event_type);
wl_cfgp2p.c:1676:	u32 status = ntoh32(e->status);
wl_cfgp2p.c:1695:			complete(&wl->send_af_done);
wl_cfgp2p.c:1718:	    af_params->channel, af_params->dwell_time));
wl_cfgp2p.c:1733:	wl->af_sent_channel  = af_params->channel;
wl_cfgp2p.c:1735:	wl->af_tx_sent_jiffies = jiffies;
wl_cfgp2p.c:1739:		wl->ioctl_buf, WLC_IOCTL_MAXLEN, bssidx, &wl->ioctl_buf_sync);
wl_cfgp2p.c:1746:	timeout = wait_for_completion_timeout(&wl->send_af_done, msecs_to_jiffies(MAX_WAIT_TIME));
wl_cfgp2p.c:1786:	out_dev_addr->octet[0] |= 0x02;
wl_cfgp2p.c:1789:	 * BSSCFGs need to simultaneously co-exist, then this address must be
wl_cfgp2p.c:1793:	out_int_addr->octet[4] ^= 0x80;
wl_cfgp2p.c:1802:	u16 len = ie->len;
wl_cfgp2p.c:1811:	subel = ie->subelts;
wl_cfgp2p.c:1812:	len -= 4;	/* exclude OUI + OUI_TYPE */
wl_cfgp2p.c:1818:		len -= 1;
wl_cfgp2p.c:1820:		/* 2-byte little endian */
wl_cfgp2p.c:1824:		len -= 2;
wl_cfgp2p.c:1825:		len -= subelt_len;	/* for the remaining subelt fields */
wl_cfgp2p.c:1829:				memcpy(subel, p2p_int_addr->octet, ETHER_ADDR_LEN);
wl_cfgp2p.c:1832:				memcpy(subel, p2p_int_addr->octet, ETHER_ADDR_LEN);
wl_cfgp2p.c:1835:				memcpy(subel, p2p_int_addr->octet, ETHER_ADDR_LEN);
wl_cfgp2p.c:1838:				memcpy(subel, p2p_int_addr->octet, ETHER_ADDR_LEN);
wl_cfgp2p.c:1851: * common code -- call p2posl_bss_isup() instead to allow the OSL to
wl_cfgp2p.c:1862:	*(int*)getbuf = -1;
wl_cfgp2p.c:1866:		CFGP2P_ERR(("'wl bss -C %d' failed: %d\n", bsscfg_idx, result));
wl_cfgp2p.c:1872:		CFGP2P_INFO(("---wl bss -C %d   ==> %d\n", bsscfg_idx, val));
wl_cfgp2p.c:1893:	CFGP2P_INFO(("---wl bss -C %d %s\n", bsscfg_idx, up ? "up" : "down"));
wl_cfgp2p.c:1895:		wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
wl_cfgp2p.c:1929:	s32 i = 0, index = -1;
wl_cfgp2p.c:1931:		wl->p2p_net ? wl->p2p_net : wl_to_prmry_ndev(wl), TRUE);
wl_cfgp2p.c:1944:	s32 ret = -1;
wl_cfgp2p.c:1952:	if (wl->p2p && wl->p2p->vif_created) {
wl_cfgp2p.c:1954:		wl->p2p->noa.desc[0].start = 0;
wl_cfgp2p.c:1959:		if (count != -1)
wl_cfgp2p.c:1960:			wl->p2p->noa.desc[0].count = count;
wl_cfgp2p.c:1963:		if (start != -1)
wl_cfgp2p.c:1964:			wl->p2p->noa.desc[0].interval = start;
wl_cfgp2p.c:1966:		if (duration != -1)
wl_cfgp2p.c:1967:			wl->p2p->noa.desc[0].duration = duration;
wl_cfgp2p.c:1969:		if (wl->p2p->noa.desc[0].count != 255) {
wl_cfgp2p.c:1970:			wl->p2p->noa.desc[0].start = 200;
wl_cfgp2p.c:1979:			if ((wl->p2p->noa.desc[0].interval == 102) ||
wl_cfgp2p.c:1980:				(wl->p2p->noa.desc[0].interval == 100)) {
wl_cfgp2p.c:1981:				wl->p2p->noa.desc[0].start = 100 -
wl_cfgp2p.c:1982:					wl->p2p->noa.desc[0].duration;
wl_cfgp2p.c:1990:		dongle_noa.desc[0].count = htod32(wl->p2p->noa.desc[0].count);
wl_cfgp2p.c:1992:			dongle_noa.desc[0].start = htod32(wl->p2p->noa.desc[0].start);
wl_cfgp2p.c:1993:			dongle_noa.desc[0].duration = htod32(wl->p2p->noa.desc[0].duration);
wl_cfgp2p.c:1996:			dongle_noa.desc[0].start = htod32(wl->p2p->noa.desc[0].start*1000);
wl_cfgp2p.c:1997:			dongle_noa.desc[0].duration = htod32(wl->p2p->noa.desc[0].duration*1000);
wl_cfgp2p.c:1999:		dongle_noa.desc[0].interval = htod32(wl->p2p->noa.desc[0].interval*1000);
wl_cfgp2p.c:2002:			"p2p_noa", &dongle_noa, sizeof(dongle_noa), wl->ioctl_buf, WLC_IOCTL_MAXLEN,
wl_cfgp2p.c:2003:			&wl->ioctl_buf_sync);
wl_cfgp2p.c:2010:		CFGP2P_ERR(("ERROR: set_noa in non-p2p mode\n"));
wl_cfgp2p.c:2024:	if (wl->p2p && wl->p2p->vif_created) {
wl_cfgp2p.c:2025:		if (wl->p2p->noa.desc[0].count || wl->p2p->ops.ops) {
wl_cfgp2p.c:2027:			_buf[1] = (wl->p2p->ops.ops ? 0x80: 0) |
wl_cfgp2p.c:2028:				(wl->p2p->ops.ctw & 0x7f); /* ops + ctw */
wl_cfgp2p.c:2030:			if (wl->p2p->noa.desc[0].count) {
wl_cfgp2p.c:2032:				noa_desc->cnt_type = wl->p2p->noa.desc[0].count;
wl_cfgp2p.c:2033:				noa_desc->duration = wl->p2p->noa.desc[0].duration;
wl_cfgp2p.c:2034:				noa_desc->interval = wl->p2p->noa.desc[0].interval;
wl_cfgp2p.c:2035:				noa_desc->start = wl->p2p->noa.desc[0].start;
wl_cfgp2p.c:2041:				return -1;
wl_cfgp2p.c:2052:		CFGP2P_ERR(("ERROR: get_noa in non-p2p mode\n"));
wl_cfgp2p.c:2053:		return -1;
wl_cfgp2p.c:2061:	int ret = -1;
wl_cfgp2p.c:2065:	if (wl->p2p && wl->p2p->vif_created) {
wl_cfgp2p.c:2068:		if (ctw != -1) {
wl_cfgp2p.c:2069:			wl->p2p->ops.ctw = ctw;
wl_cfgp2p.c:2072:		if (ps != -1) {
wl_cfgp2p.c:2073:			wl->p2p->ops.ops = ps;
wl_cfgp2p.c:2075:				"p2p_ops", &wl->p2p->ops, sizeof(wl->p2p->ops),
wl_cfgp2p.c:2076:				wl->ioctl_buf, WLC_IOCTL_MAXLEN, &wl->ioctl_buf_sync);
wl_cfgp2p.c:2082:		if ((legacy_ps != -1) && ((legacy_ps == PM_MAX) || (legacy_ps == PM_OFF))) {
wl_cfgp2p.c:2100:		CFGP2P_ERR(("ERROR: set_p2p_ps in non-p2p mode\n"));
wl_cfgp2p.c:2101:		ret = -1;
wl_cfgp2p.c:2121:	len = ie->len;
wl_cfgp2p.c:2126:	subel = ie->subelts;
wl_cfgp2p.c:2127:	len -= 4;	/* exclude OUI + OUI_TYPE */
wl_cfgp2p.c:2133:		len -= 1;
wl_cfgp2p.c:2135:		/* 2-byte little endian */
wl_cfgp2p.c:2139:		len -= 2;
wl_cfgp2p.c:2140:		len -= subelt_len;	/* for the remaining subelt fields */
wl_cfgp2p.c:2166:	if (!(p2p_ie = wl_cfgp2p_find_p2pie(((u8 *) bi) + bi->ie_offset, bi->ie_length))) {
wl_cfgp2p.c:2179:		return bi->BSSID.octet;
wl_cfgp2p.c:2200:	snprintf(info->driver, sizeof(info->driver), "p2p");
wl_cfgp2p.c:2201:	snprintf(info->version, sizeof(info->version), "%lu", (unsigned long)(0));
wl_cfgp2p.c:2217:	if (wl->p2p_net) {
wl_cfgp2p.c:2219:		return -EINVAL;
wl_cfgp2p.c:2224:		CFGP2P_ERR(("%s: OOM - alloc_etherdev\n", __FUNCTION__));
wl_cfgp2p.c:2225:		return -ENODEV;
wl_cfgp2p.c:2232:		return -ENOMEM;
wl_cfgp2p.c:2235:	strncpy(net->name, "p2p%d", sizeof(net->name) - 1);
wl_cfgp2p.c:2236:	net->name[IFNAMSIZ - 1] = '\0';
wl_cfgp2p.c:2242:	ASSERT(!net->open);
wl_cfgp2p.c:2243:	net->do_ioctl = wl_cfgp2p_do_ioctl;
wl_cfgp2p.c:2244:	net->hard_start_xmit = wl_cfgp2p_start_xmit;
wl_cfgp2p.c:2245:	net->open = wl_cfgp2p_if_open;
wl_cfgp2p.c:2246:	net->stop = wl_cfgp2p_if_stop;
wl_cfgp2p.c:2248:	ASSERT(!net->netdev_ops);
wl_cfgp2p.c:2249:	net->netdev_ops = &wl_cfgp2p_if_ops;
wl_cfgp2p.c:2253:	memcpy(net->dev_addr, temp_addr, ETHER_ADDR_LEN);
wl_cfgp2p.c:2255:	wdev->wiphy = wl->wdev->wiphy;
wl_cfgp2p.c:2257:	wdev->iftype = wl_mode_to_nl80211_iftype(WL_MODE_BSS);
wl_cfgp2p.c:2259:	net->ieee80211_ptr = wdev;
wl_cfgp2p.c:2262:	net->ethtool_ops = &cfgp2p_ethtool_ops;
wl_cfgp2p.c:2265:	SET_NETDEV_DEV(net, wiphy_dev(wdev->wiphy));
wl_cfgp2p.c:2268:	wdev->netdev = net;
wl_cfgp2p.c:2275:		return -ENODEV;
wl_cfgp2p.c:2281:	wl->p2p_wdev = wdev;
wl_cfgp2p.c:2282:	wl->p2p_net = net;
wl_cfgp2p.c:2284:	printk("%s: P2P Interface Registered\n", net->name);
wl_cfgp2p.c:2293:	if (!wl || !wl->p2p_net) {
wl_cfgp2p.c:2295:		return -EINVAL;
wl_cfgp2p.c:2298:	unregister_netdev(wl->p2p_net);
wl_cfgp2p.c:2299:	free_netdev(wl->p2p_net);
wl_cfgp2p.c:2308:			ndev->name));
wl_cfgp2p.c:2331:		return -1;
wl_cfgp2p.c:2340:	struct wireless_dev *wdev = net->ieee80211_ptr;
wl_cfgp2p.c:2343:	if (!wdev || !wl || !wl->p2p)
wl_cfgp2p.c:2344:		return -EINVAL;
wl_cfgp2p.c:2349:	 * i.e you may give wpa_supp -iwlan0 -N -ip2p0 or wpa_supp -ip2p0 -N
wl_cfgp2p.c:2350:	 * -iwlan0.
wl_cfgp2p.c:2352:	wdev->wiphy->interface_modes |= (BIT(NL80211_IFTYPE_P2P_CLIENT)
wl_cfgp2p.c:2364:	struct wireless_dev *wdev = net->ieee80211_ptr;
wl_cfgp2p.c:2367:		return -EINVAL;
wl_cfgp2p.c:2372:		return -EINVAL;
wl_cfgp2p.c:2373:	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
wl_cfgp2p.c:2374:	if (wl->scan_request && wl->scan_request->dev == net) {
wl_cfgp2p.c:2375:		cfg80211_scan_done(wl->scan_request, true);
wl_cfgp2p.c:2376:		wl->scan_request = NULL;
wl_cfgp2p.c:2379:	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
wl_cfgp2p.c:2382:	wdev->wiphy->interface_modes = (wdev->wiphy->interface_modes)
wl_cfgp2p.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
wl_cfgp2p.h:24: * $Id: wl_cfgp2p.h 368091 2012-11-12 04:28:31Z $
wl_cfgp2p.h:118:#define wl_to_p2p_bss_ndev(wl, type)		((wl)->p2p->bss_idx[type].dev)
wl_cfgp2p.h:119:#define wl_to_p2p_bss_bssidx(wl, type)		((wl)->p2p->bss_idx[type].bssidx)
wl_cfgp2p.h:120:#define wl_to_p2p_bss_saved_ie(wl, type)	((wl)->p2p->bss_idx[type].saved_ie)
wl_cfgp2p.h:121:#define wl_to_p2p_bss_private(wl, type)		((wl)->p2p->bss_idx[type].private_data)
wl_cfgp2p.h:122:#define wl_to_p2p_bss(wl, type)			((wl)->p2p->bss_idx[type])
wl_cfgp2p.h:123:#define wl_get_p2p_status(wl, stat) ((!(wl)->p2p_supported) ? 0 : test_bit(WLP2P_STATUS_ ## stat, \
wl_cfgp2p.h:124:									&(wl)->p2p->status))
wl_cfgp2p.h:125:#define wl_set_p2p_status(wl, stat) ((!(wl)->p2p_supported) ? 0 : set_bit(WLP2P_STATUS_ ## stat, \
wl_cfgp2p.h:126:									&(wl)->p2p->status))
wl_cfgp2p.h:127:#define wl_clr_p2p_status(wl, stat) ((!(wl)->p2p_supported) ? 0 : clear_bit(WLP2P_STATUS_ ## stat, \
wl_cfgp2p.h:128:									&(wl)->p2p->status))
wl_cfgp2p.h:129:#define wl_chg_p2p_status(wl, stat) ((!(wl)->p2p_supported) ? 0:change_bit(WLP2P_STATUS_ ## stat, \
wl_cfgp2p.h:130:									&(wl)->p2p->status))
wl_cfgp2p.h:131:#define p2p_on(wl) ((wl)->p2p->on)
wl_cfgp2p.h:132:#define p2p_scan(wl) ((wl)->p2p->scan)
wl_cfgp2p.h:133:#define p2p_is_on(wl) ((wl)->p2p && (wl)->p2p->on)
wl_cfgp2p.h:138:#define CFGP2P_ERROR_TEXT		"CFGP2P-ERROR) "
wl_cfgp2p.h:150:			printk(KERN_INFO "CFGP2P-INFO) %s : ", __func__);	\
wl_cfgp2p.h:157:			printk(KERN_DEBUG "CFGP2P-DEBUG) %s :", __func__);	\
wl_cfgp2p.h:165:			printk(KERN_DEBUG "CFGP2P-ACTION) %s :", __func__);	\
wl_cfgp2p.h:172:		timer->function = func; \
wl_cfgp2p.h:173:		timer->expires = jiffies + msecs_to_jiffies(duration + extra_delay); \
wl_cfgp2p.h:174:		timer->data = (unsigned long) wl; \
wl_cfgp2p.h:315:#define WL_P2P_WILDCARD_SSID "DIRECT-"
wl_cfgp2p.h:327:					((frame->action == P2PSD_ACTION_ID_GAS_IREQ) || \
wl_cfgp2p.h:328:					(frame->action == P2PSD_ACTION_ID_GAS_CREQ)))
wl_cfgp2p.h:331:					((frame->subtype == P2P_PAF_GON_REQ) || \
wl_cfgp2p.h:332:					(frame->subtype == P2P_PAF_INVITE_REQ) || \
wl_cfgp2p.h:333:					((frame->subtype == P2P_PAF_PROVDIS_REQ) && \
wl_dbg.h:5: * Copyright (C) 1999-2012, Broadcom Corporation
wl_dbg.h:25: * $Id: wl_dbg.h 326635 2012-04-10 03:15:29Z $
wldev_common.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
wldev_common.c:24: * $Id: wldev_common.c,v 1.1.4.1.2.14 2011-02-09 01:40:07 $
wldev_common.c:44:		printk(KERN_ERR "WLDEV-ERROR) %s : ", __func__);	\
wldev_common.c:273:		return -ENOMEM;
wldev_common.c:290:		return -ENOMEM;
wldev_common.c:307:		return -ENOMEM;
wldev_common.c:311:	pssid->SSID_len = dtoh32(pssid->SSID_len);
wldev_common.c:327:	int error = -1;
wldev_common.c:340:	int error = -1;
wldev_common.c:362:		cspec.rev = -1;
wldev_common.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
wldev_common.h:24: * $Id: wldev_common.h,v 1.1.4.1.2.14 2011-02-09 01:40:07 $
wldev_common.h:31:/* wl_dev_ioctl - get/set IOCTLs, will call net_device's do_ioctl (or
wldev_common.h:32: *  netdev_ops->ndo_do_ioctl in new kernels)
wl_iw.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
wl_iw.c:24: * $Id: wl_iw.c 352251 2012-08-22 06:08:38Z $
wl_iw.c:77:#define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)
wl_iw.c:78:#define IW_EVENT_IDX(cmd)	((cmd) - IWEVFIRST)
wl_iw.c:91:		strncpy(current->comm, a, MIN(sizeof(current->comm), (strlen(a) + 1))); \
wl_iw.c:127:/* priv_link becomes netdev->priv and is the link between netdev and wlif struct */
wl_iw.c:134:#define WL_DEV_LINK(dev)       (priv_link_t*)(dev->priv)
wl_iw.c:140:#define IW_DEV_IF(dev)          ((wl_iw_t*)(WL_DEV_LINK(dev))->wliw)
wl_iw.c:146:	key->index = htod32(key->index);
wl_iw.c:147:	key->len = htod32(key->len);
wl_iw.c:148:	key->algo = htod32(key->algo);
wl_iw.c:149:	key->flags = htod32(key->flags);
wl_iw.c:150:	key->rxiv.hi = htod32(key->rxiv.hi);
wl_iw.c:151:	key->rxiv.lo = htod16(key->rxiv.lo);
wl_iw.c:152:	key->iv_initialized = htod32(key->iv_initialized);
wl_iw.c:159:	key->index = dtoh32(key->index);
wl_iw.c:160:	key->len = dtoh32(key->len);
wl_iw.c:161:	key->algo = dtoh32(key->algo);
wl_iw.c:162:	key->flags = dtoh32(key->flags);
wl_iw.c:163:	key->rxiv.hi = dtoh32(key->rxiv.hi);
wl_iw.c:164:	key->rxiv.lo = dtoh16(key->rxiv.lo);
wl_iw.c:165:	key->iv_initialized = dtoh32(key->iv_initialized);
wl_iw.c:186:	strcpy(ifr.ifr_name, dev->name);
wl_iw.c:199:	ret = dev->netdev_ops->ndo_do_ioctl(dev, &ifr, SIOCDEVPRIVATE);
wl_iw.c:201:	ret = dev->do_ioctl(dev, &ifr, SIOCDEVPRIVATE);
wl_iw.c:278:		return -ENOMEM;
wl_iw.c:307:		return -ENOMEM;
wl_iw.c:353:	__u16		flags;		/* More to come ;-) */
wl_iw.c:422:		return -1;
wl_iw.c:444:	WL_TRACE(("%s: SIOCSIWCOMMIT\n", dev->name));
wl_iw.c:475:	WL_TRACE(("%s: SIOCGIWNAME\n", dev->name));
wl_iw.c:506:	snprintf(cwrq->name, IFNAMSIZ, "IEEE 802.11%s", cap);
wl_iw.c:521:	WL_TRACE(("%s: SIOCSIWFREQ\n", dev->name));
wl_iw.c:524:	if (fwrq->e == 0 && fwrq->m < MAXCHANNEL) {
wl_iw.c:525:		chan = fwrq->m;
wl_iw.c:531:		if (fwrq->e >= 6) {
wl_iw.c:532:			fwrq->e -= 6;
wl_iw.c:533:			while (fwrq->e--)
wl_iw.c:534:				fwrq->m *= 10;
wl_iw.c:535:		} else if (fwrq->e < 6) {
wl_iw.c:536:			while (fwrq->e++ < 6)
wl_iw.c:537:				fwrq->m /= 10;
wl_iw.c:540:	if (fwrq->m > 4000 && fwrq->m < 5000)
wl_iw.c:543:		chan = wf_mhz2channel(fwrq->m, sf);
wl_iw.c:549:	/* -EINPROGRESS: Call commit handler */
wl_iw.c:550:	return -EINPROGRESS;
wl_iw.c:564:	WL_TRACE(("%s: SIOCGIWFREQ\n", dev->name));
wl_iw.c:570:	fwrq->m = dtoh32(ci.hw_channel);
wl_iw.c:571:	fwrq->e = dtoh32(0);
wl_iw.c:585:	WL_TRACE(("%s: SIOCSIWMODE\n", dev->name));
wl_iw.c:598:		return -EINVAL;
wl_iw.c:607:	/* -EINPROGRESS: Call commit handler */
wl_iw.c:608:	return -EINPROGRESS;
wl_iw.c:621:	WL_TRACE(("%s: SIOCGIWMODE\n", dev->name));
wl_iw.c:658:	WL_TRACE(("%s: SIOCGIWRANGE\n", dev->name));
wl_iw.c:661:		return -EINVAL;
wl_iw.c:663:	dwrq->length = sizeof(struct iw_range);
wl_iw.c:667:	range->min_nwid = range->max_nwid = 0;
wl_iw.c:670:	list->count = htod32(MAXCHANNEL);
wl_iw.c:673:	for (i = 0; i < dtoh32(list->count) && i < IW_MAX_FREQUENCIES; i++) {
wl_iw.c:674:		range->freq[i].i = dtoh32(list->element[i]);
wl_iw.c:676:		ch = dtoh32(list->element[i]);
wl_iw.c:682:		range->freq[i].m = wf_channel2mhz(ch, sf);
wl_iw.c:683:		range->freq[i].e = 6;
wl_iw.c:685:	range->num_frequency = range->num_channels = i;
wl_iw.c:688:	range->max_qual.qual = 5;
wl_iw.c:690:	range->max_qual.level = 0x100 - 200;	/* -200 dBm */
wl_iw.c:692:	range->max_qual.noise = 0x100 - 200;	/* -200 dBm */
wl_iw.c:694:	range->sensitivity = 65535;
wl_iw.c:698:	range->avg_qual.qual = 3;
wl_iw.c:700:	range->avg_qual.level = 0x100 + WL_IW_RSSI_GOOD;
wl_iw.c:702:	range->avg_qual.noise = 0x100 - 75;	/* -75 dBm */
wl_iw.c:709:	range->num_bitrates = rateset.count;
wl_iw.c:711:		range->bitrate[i] = (rateset.rates[i] & 0x7f) * 500000; /* convert to bps */
wl_iw.c:737:		range->num_bitrates += 8;
wl_iw.c:738:		for (k = 0; i < range->num_bitrates; k++, i++) {
wl_iw.c:740:			range->bitrate[i] = (nrate_list[nrate_list2copy][k]) * 500000;
wl_iw.c:752:		range->throughput = 24000000;	/* 24 Mbits/s */
wl_iw.c:754:		range->throughput = 1500000;	/* 1.5 Mbits/s */
wl_iw.c:757:	range->min_rts = 0;
wl_iw.c:758:	range->max_rts = 2347;
wl_iw.c:759:	range->min_frag = 256;
wl_iw.c:760:	range->max_frag = 2346;
wl_iw.c:762:	range->max_encoding_tokens = DOT11_MAX_DEFAULT_KEYS;
wl_iw.c:763:	range->num_encoding_sizes = 4;
wl_iw.c:764:	range->encoding_size[0] = WEP1_KEY_SIZE;
wl_iw.c:765:	range->encoding_size[1] = WEP128_KEY_SIZE;
wl_iw.c:767:	range->encoding_size[2] = TKIP_KEY_SIZE;
wl_iw.c:769:	range->encoding_size[2] = 0;
wl_iw.c:771:	range->encoding_size[3] = AES_KEY_SIZE;
wl_iw.c:773:	/* Do not support power micro-management */
wl_iw.c:774:	range->min_pmp = 0;
wl_iw.c:775:	range->max_pmp = 0;
wl_iw.c:776:	range->min_pmt = 0;
wl_iw.c:777:	range->max_pmt = 0;
wl_iw.c:778:	range->pmp_flags = 0;
wl_iw.c:779:	range->pm_capa = 0;
wl_iw.c:781:	/* Transmit Power - values are in mW */
wl_iw.c:782:	range->num_txpower = 2;
wl_iw.c:783:	range->txpower[0] = 1;
wl_iw.c:784:	range->txpower[1] = 255;
wl_iw.c:785:	range->txpower_capa = IW_TXPOW_MWATT;
wl_iw.c:788:	range->we_version_compiled = WIRELESS_EXT;
wl_iw.c:789:	range->we_version_source = 19;
wl_iw.c:792:	range->retry_capa = IW_RETRY_LIMIT;
wl_iw.c:793:	range->retry_flags = IW_RETRY_LIMIT;
wl_iw.c:794:	range->r_time_flags = 0;
wl_iw.c:796:	range->min_retry = 1;
wl_iw.c:797:	range->max_retry = 255;
wl_iw.c:799:	range->min_r_time = 0;
wl_iw.c:800:	range->max_r_time = 0;
wl_iw.c:804:	range->enc_capa = IW_ENC_CAPA_WPA;
wl_iw.c:805:	range->enc_capa |= IW_ENC_CAPA_CIPHER_TKIP;
wl_iw.c:806:	range->enc_capa |= IW_ENC_CAPA_CIPHER_CCMP;
wl_iw.c:807:	range->enc_capa |= IW_ENC_CAPA_WPA2;
wl_iw.c:810:	range->enc_capa |= IW_ENC_CAPA_4WAY_HANDSHAKE;
wl_iw.c:814:	IW_EVENT_CAPA_SET_KERNEL(range->event_capa);
wl_iw.c:816:	IW_EVENT_CAPA_SET(range->event_capa, SIOCGIWAP);
wl_iw.c:817:	IW_EVENT_CAPA_SET(range->event_capa, SIOCGIWSCAN);
wl_iw.c:818:	IW_EVENT_CAPA_SET(range->event_capa, IWEVTXDROP);
wl_iw.c:819:	IW_EVENT_CAPA_SET(range->event_capa, IWEVMICHAELMICFAILURE);
wl_iw.c:820:	IW_EVENT_CAPA_SET(range->event_capa, IWEVASSOCREQIE);
wl_iw.c:821:	IW_EVENT_CAPA_SET(range->event_capa, IWEVASSOCRESPIE);
wl_iw.c:822:	IW_EVENT_CAPA_SET(range->event_capa, IWEVPMKIDCAND);
wl_iw.c:826:	range->scan_capa = IW_SCAN_CAPA_ESSID;
wl_iw.c:862:	WL_TRACE(("%s: SIOCSIWSPY\n", dev->name));
wl_iw.c:865:		return -EINVAL;
wl_iw.c:867:	iw->spy_num = MIN(ARRAYSIZE(iw->spy_addr), dwrq->length);
wl_iw.c:868:	for (i = 0; i < iw->spy_num; i++)
wl_iw.c:869:		memcpy(&iw->spy_addr[i], addr[i].sa_data, ETHER_ADDR_LEN);
wl_iw.c:870:	memset(iw->spy_qual, 0, sizeof(iw->spy_qual));
wl_iw.c:885:	struct iw_quality *qual = (struct iw_quality *) &addr[iw->spy_num];
wl_iw.c:888:	WL_TRACE(("%s: SIOCGIWSPY\n", dev->name));
wl_iw.c:891:		return -EINVAL;
wl_iw.c:893:	dwrq->length = iw->spy_num;
wl_iw.c:894:	for (i = 0; i < iw->spy_num; i++) {
wl_iw.c:895:		memcpy(addr[i].sa_data, &iw->spy_addr[i], ETHER_ADDR_LEN);
wl_iw.c:897:		memcpy(&qual[i], &iw->spy_qual[i], sizeof(struct iw_quality));
wl_iw.c:898:		iw->spy_qual[i].updated = 0;
wl_iw.c:912:	int error = -EINVAL;
wl_iw.c:914:	WL_TRACE(("%s: SIOCSIWAP\n", dev->name));
wl_iw.c:916:	if (awrq->sa_family != ARPHRD_ETHER) {
wl_iw.c:918:		return -EINVAL;
wl_iw.c:922:	if (ETHER_ISBCAST(awrq->sa_data) || ETHER_ISNULLADDR(awrq->sa_data)) {
wl_iw.c:930:	/* WL_ASSOC(("Assoc to %s\n", bcm_ether_ntoa((struct ether_addr *)&(awrq->sa_data),
wl_iw.c:934:	if ((error = dev_wlc_ioctl(dev, WLC_REASSOC, awrq->sa_data, ETHER_ADDR_LEN))) {
wl_iw.c:950:	WL_TRACE(("%s: SIOCGIWAP\n", dev->name));
wl_iw.c:952:	awrq->sa_family = ARPHRD_ETHER;
wl_iw.c:953:	memset(awrq->sa_data, 0, ETHER_ADDR_LEN);
wl_iw.c:956:	(void) dev_wlc_ioctl(dev, WLC_GET_BSSID, awrq->sa_data, ETHER_ADDR_LEN);
wl_iw.c:972:	int error  = -EINVAL;
wl_iw.c:974:	WL_TRACE(("%s: SIOCSIWMLME\n", dev->name));
wl_iw.c:982:	scbval.val = mlme->reason_code;
wl_iw.c:983:	bcopy(&mlme->addr.sa_data, &scbval.ea, ETHER_ADDR_LEN);
wl_iw.c:985:	if (mlme->cmd == IW_MLME_DISASSOC) {
wl_iw.c:989:	else if (mlme->cmd == IW_MLME_DEAUTH) {
wl_iw.c:1016:	uint buflen = dwrq->length;
wl_iw.c:1018:	WL_TRACE(("%s: SIOCGIWAPLIST\n", dev->name));
wl_iw.c:1021:		return -EINVAL;
wl_iw.c:1026:		return -ENOMEM;
wl_iw.c:1028:	list->buflen = htod32(buflen);
wl_iw.c:1034:	list->buflen = dtoh32(list->buflen);
wl_iw.c:1035:	list->version = dtoh32(list->version);
wl_iw.c:1036:	list->count = dtoh32(list->count);
wl_iw.c:1037:	ASSERT(list->version == WL_BSS_INFO_VERSION);
wl_iw.c:1039:	for (i = 0, dwrq->length = 0; i < list->count && dwrq->length < IW_MAX_AP; i++) {
wl_iw.c:1040:		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : list->bss_info;
wl_iw.c:1041:		ASSERT(((uintptr)bi + dtoh32(bi->length)) <= ((uintptr)list +
wl_iw.c:1045:		if (!(dtoh16(bi->capability) & DOT11_CAP_ESS))
wl_iw.c:1049:		memcpy(addr[dwrq->length].sa_data, &bi->BSSID, ETHER_ADDR_LEN);
wl_iw.c:1050:		addr[dwrq->length].sa_family = ARPHRD_ETHER;
wl_iw.c:1051:		qual[dwrq->length].qual = rssi_to_qual(dtoh16(bi->RSSI));
wl_iw.c:1052:		qual[dwrq->length].level = 0x100 + dtoh16(bi->RSSI);
wl_iw.c:1053:		qual[dwrq->length].noise = 0x100 + bi->phy_noise;
wl_iw.c:1057:		qual[dwrq->length].updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
wl_iw.c:1059:		qual[dwrq->length].updated = 7;
wl_iw.c:1062:		dwrq->length++;
wl_iw.c:1067:	if (dwrq->length) {
wl_iw.c:1068:		memcpy(&addr[dwrq->length], qual, sizeof(struct iw_quality) * dwrq->length);
wl_iw.c:1070:		dwrq->flags = 1;
wl_iw.c:1093:	WL_TRACE(("%s: SIOCGIWAPLIST\n", dev->name));
wl_iw.c:1096:		return -EINVAL;
wl_iw.c:1098:	if ((!iscan) || (iscan->sysioc_pid < 0)) {
wl_iw.c:1102:	buf = iscan->list_hdr;
wl_iw.c:1105:	    list = &((wl_iscan_results_t*)buf->iscan_buf)->results;
wl_iw.c:1106:	    ASSERT(list->version == WL_BSS_INFO_VERSION);
wl_iw.c:1109:	for (i = 0, dwrq->length = 0; i < list->count && dwrq->length < IW_MAX_AP; i++) {
wl_iw.c:1110:		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : list->bss_info;
wl_iw.c:1111:		ASSERT(((uintptr)bi + dtoh32(bi->length)) <= ((uintptr)list +
wl_iw.c:1115:		if (!(dtoh16(bi->capability) & DOT11_CAP_ESS))
wl_iw.c:1119:		memcpy(addr[dwrq->length].sa_data, &bi->BSSID, ETHER_ADDR_LEN);
wl_iw.c:1120:		addr[dwrq->length].sa_family = ARPHRD_ETHER;
wl_iw.c:1121:		qual[dwrq->length].qual = rssi_to_qual(dtoh16(bi->RSSI));
wl_iw.c:1122:		qual[dwrq->length].level = 0x100 + dtoh16(bi->RSSI);
wl_iw.c:1123:		qual[dwrq->length].noise = 0x100 + bi->phy_noise;
wl_iw.c:1127:		qual[dwrq->length].updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
wl_iw.c:1129:		qual[dwrq->length].updated = 7;
wl_iw.c:1132:		dwrq->length++;
wl_iw.c:1134:	    buf = buf->next;
wl_iw.c:1136:	if (dwrq->length) {
wl_iw.c:1137:		memcpy(&addr[dwrq->length], qual, sizeof(struct iw_quality) * dwrq->length);
wl_iw.c:1139:		dwrq->flags = 1;
wl_iw.c:1156:	WL_TRACE(("%s: SIOCSIWSCAN\n", dev->name));
wl_iw.c:1163:	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
wl_iw.c:1164:		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
wl_iw.c:1166:			ssid.SSID_len = MIN(sizeof(ssid.SSID), req->essid_len);
wl_iw.c:1167:			memcpy(ssid.SSID, req->essid, ssid.SSID_len);
wl_iw.c:1189:	WL_TRACE(("%s: SIOCSIWSCAN\n", dev->name));
wl_iw.c:1192:	if ((!iscan) || (iscan->sysioc_pid < 0)) {
wl_iw.c:1195:	if (iscan->iscan_state == ISCAN_STATE_SCANING) {
wl_iw.c:1204:	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
wl_iw.c:1205:		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
wl_iw.c:1207:			ssid.SSID_len = MIN(sizeof(ssid.SSID), req->essid_len);
wl_iw.c:1208:			memcpy(ssid.SSID, req->essid, ssid.SSID_len);
wl_iw.c:1214:	iscan->list_cur = iscan->list_hdr;
wl_iw.c:1215:	iscan->iscan_state = ISCAN_STATE_SCANING;
wl_iw.c:1221:	iscan->timer.expires = jiffies + msecs_to_jiffies(iscan->timer_ms);
wl_iw.c:1222:	add_timer(&iscan->timer);
wl_iw.c:1223:	iscan->timer_on = 1;
wl_iw.c:1245:	*tlvs_len -= (int)(ie - *tlvs);
wl_iw.c:1267:	*tlvs_len -= (int)(ie - *tlvs);
wl_iw.c:1284:	if (bi->ie_length) {
wl_iw.c:1288:		int ptr_len = bi->ie_length;
wl_iw.c:1292:			iwe.u.data.length = ie->len + 2;
wl_iw.c:1300:			iwe.u.data.length = ie->len + 2;
wl_iw.c:1310:				iwe.u.data.length = ie->len + 2;
wl_iw.c:1317:		ptr_len = bi->ie_length;
wl_iw.c:1321:				iwe.u.data.length = ie->len + 2;
wl_iw.c:1346:	char *event = extra, *end = extra + dwrq->length, *value;
wl_iw.c:1347:	uint buflen = dwrq->length;
wl_iw.c:1349:	WL_TRACE(("%s: SIOCGIWSCAN\n", dev->name));
wl_iw.c:1352:		return -EINVAL;
wl_iw.c:1359:		return -EAGAIN;
wl_iw.c:1364:		return -ENOMEM;
wl_iw.c:1366:	list->buflen = htod32(buflen);
wl_iw.c:1371:	list->buflen = dtoh32(list->buflen);
wl_iw.c:1372:	list->version = dtoh32(list->version);
wl_iw.c:1373:	list->count = dtoh32(list->count);
wl_iw.c:1375:	ASSERT(list->version == WL_BSS_INFO_VERSION);
wl_iw.c:1377:	for (i = 0; i < list->count && i < IW_MAX_AP; i++) {
wl_iw.c:1378:		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : list->bss_info;
wl_iw.c:1379:		ASSERT(((uintptr)bi + dtoh32(bi->length)) <= ((uintptr)list +
wl_iw.c:1385:		memcpy(iwe.u.ap_addr.sa_data, &bi->BSSID, ETHER_ADDR_LEN);
wl_iw.c:1389:		iwe.u.data.length = dtoh32(bi->SSID_len);
wl_iw.c:1392:		event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, bi->SSID);
wl_iw.c:1395:		if (dtoh16(bi->capability) & (DOT11_CAP_ESS | DOT11_CAP_IBSS)) {
wl_iw.c:1397:			if (dtoh16(bi->capability) & DOT11_CAP_ESS)
wl_iw.c:1406:		iwe.u.freq.m = wf_channel2mhz(CHSPEC_CHANNEL(bi->chanspec),
wl_iw.c:1407:			CHSPEC_CHANNEL(bi->chanspec) <= CH_MAX_2G_CHANNEL ?
wl_iw.c:1414:		iwe.u.qual.qual = rssi_to_qual(dtoh16(bi->RSSI));
wl_iw.c:1415:		iwe.u.qual.level = 0x100 + dtoh16(bi->RSSI);
wl_iw.c:1416:		iwe.u.qual.noise = 0x100 + bi->phy_noise;
wl_iw.c:1424:		if (dtoh16(bi->capability) & DOT11_CAP_PRIVACY)
wl_iw.c:1432:		if (bi->rateset.count) {
wl_iw.c:1437:			for (j = 0; j < bi->rateset.count && j < IW_MAX_BITRATES; j++) {
wl_iw.c:1438:				iwe.u.bitrate.value = (bi->rateset.rates[j] & 0x7f) * 500000;
wl_iw.c:1448:	dwrq->length = event - extra;
wl_iw.c:1449:	dwrq->flags = 0;	/* todo */
wl_iw.c:1467:	char *event = extra, *end = extra + dwrq->length, *value;
wl_iw.c:1471:	WL_TRACE(("%s: SIOCGIWSCAN\n", dev->name));
wl_iw.c:1474:		return -EINVAL;
wl_iw.c:1477:	if ((!iscan) || (iscan->sysioc_pid < 0)) {
wl_iw.c:1482:	if (iscan->iscan_state == ISCAN_STATE_SCANING)
wl_iw.c:1483:		return -EAGAIN;
wl_iw.c:1486:	p_buf = iscan->list_hdr;
wl_iw.c:1488:	while (p_buf != iscan->list_cur) {
wl_iw.c:1489:	    list = &((wl_iscan_results_t*)p_buf->iscan_buf)->results;
wl_iw.c:1491:	    if (list->version != WL_BSS_INFO_VERSION) {
wl_iw.c:1492:		WL_ERROR(("list->version %d != WL_BSS_INFO_VERSION\n", list->version));
wl_iw.c:1496:	    for (ii = 0; ii < list->count && apcnt < IW_MAX_AP; apcnt++, ii++) {
wl_iw.c:1497:		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : list->bss_info;
wl_iw.c:1498:		ASSERT(((uintptr)bi + dtoh32(bi->length)) <= ((uintptr)list +
wl_iw.c:1502:		if (event + ETHER_ADDR_LEN + bi->SSID_len + IW_EV_UINT_LEN + IW_EV_FREQ_LEN +
wl_iw.c:1504:			return -E2BIG;
wl_iw.c:1508:		memcpy(iwe.u.ap_addr.sa_data, &bi->BSSID, ETHER_ADDR_LEN);
wl_iw.c:1512:		iwe.u.data.length = dtoh32(bi->SSID_len);
wl_iw.c:1515:		event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, bi->SSID);
wl_iw.c:1518:		if (dtoh16(bi->capability) & (DOT11_CAP_ESS | DOT11_CAP_IBSS)) {
wl_iw.c:1520:			if (dtoh16(bi->capability) & DOT11_CAP_ESS)
wl_iw.c:1529:		iwe.u.freq.m = wf_channel2mhz(CHSPEC_CHANNEL(bi->chanspec),
wl_iw.c:1530:			CHSPEC_CHANNEL(bi->chanspec) <= CH_MAX_2G_CHANNEL ?
wl_iw.c:1537:		iwe.u.qual.qual = rssi_to_qual(dtoh16(bi->RSSI));
wl_iw.c:1538:		iwe.u.qual.level = 0x100 + dtoh16(bi->RSSI);
wl_iw.c:1539:		iwe.u.qual.noise = 0x100 + bi->phy_noise;
wl_iw.c:1547:		if (dtoh16(bi->capability) & DOT11_CAP_PRIVACY)
wl_iw.c:1555:		if (bi->rateset.count <= sizeof(bi->rateset.rates)) {
wl_iw.c:1557:				return -E2BIG;
wl_iw.c:1563:			for (j = 0; j < bi->rateset.count && j < IW_MAX_BITRATES; j++) {
wl_iw.c:1564:				iwe.u.bitrate.value = (bi->rateset.rates[j] & 0x7f) * 500000;
wl_iw.c:1571:	    p_buf = p_buf->next;
wl_iw.c:1574:	dwrq->length = event - extra;
wl_iw.c:1575:	dwrq->flags = 0;	/* todo */
wl_iw.c:1594:	WL_TRACE(("%s: SIOCSIWESSID\n", dev->name));
wl_iw.c:1598:	if (dwrq->length && extra) {
wl_iw.c:1600:		ssid.SSID_len = MIN(sizeof(ssid.SSID), dwrq->length);
wl_iw.c:1602:		ssid.SSID_len = MIN(sizeof(ssid.SSID), dwrq->length-1);
wl_iw.c:1631:	WL_TRACE(("%s: SIOCGIWESSID\n", dev->name));
wl_iw.c:1634:		return -EINVAL;
wl_iw.c:1646:	dwrq->length = ssid.SSID_len;
wl_iw.c:1648:	dwrq->flags = 1; /* active */
wl_iw.c:1662:	WL_TRACE(("%s: SIOCSIWNICKN\n", dev->name));
wl_iw.c:1665:		return -EINVAL;
wl_iw.c:1668:	if (dwrq->length > sizeof(iw->nickname))
wl_iw.c:1669:		return -E2BIG;
wl_iw.c:1671:	memcpy(iw->nickname, extra, dwrq->length);
wl_iw.c:1672:	iw->nickname[dwrq->length - 1] = '\0';
wl_iw.c:1686:	WL_TRACE(("%s: SIOCGIWNICKN\n", dev->name));
wl_iw.c:1689:		return -EINVAL;
wl_iw.c:1691:	strcpy(extra, iw->nickname);
wl_iw.c:1692:	dwrq->length = strlen(extra) + 1;
wl_iw.c:1707:	WL_TRACE(("%s: SIOCSIWRATE\n", dev->name));
wl_iw.c:1715:	if (vwrq->value < 0) {
wl_iw.c:1717:		rate = rateset.rates[rateset.count - 1] & 0x7f;
wl_iw.c:1718:	} else if (vwrq->value < rateset.count) {
wl_iw.c:1720:		rate = rateset.rates[vwrq->value] & 0x7f;
wl_iw.c:1723:		rate = vwrq->value / 500000;
wl_iw.c:1726:	if (vwrq->fixed) {
wl_iw.c:1729:			Since the is a/b/g-blind, both a/bg_rate are enforced.
wl_iw.c:1739:			Since the is a/b/g-blind, both a/bg_rate are enforced.
wl_iw.c:1772:	WL_TRACE(("%s: SIOCGIWRATE\n", dev->name));
wl_iw.c:1778:	vwrq->value = rate * 500000;
wl_iw.c:1793:	WL_TRACE(("%s: SIOCSIWRTS\n", dev->name));
wl_iw.c:1795:	if (vwrq->disabled)
wl_iw.c:1797:	else if (vwrq->value < 0 || vwrq->value > DOT11_DEFAULT_RTS_LEN)
wl_iw.c:1798:		return -EINVAL;
wl_iw.c:1800:		rts = vwrq->value;
wl_iw.c:1818:	WL_TRACE(("%s: SIOCGIWRTS\n", dev->name));
wl_iw.c:1823:	vwrq->value = rts;
wl_iw.c:1824:	vwrq->disabled = (rts >= DOT11_DEFAULT_RTS_LEN);
wl_iw.c:1825:	vwrq->fixed = 1;
wl_iw.c:1840:	WL_TRACE(("%s: SIOCSIWFRAG\n", dev->name));
wl_iw.c:1842:	if (vwrq->disabled)
wl_iw.c:1844:	else if (vwrq->value < 0 || vwrq->value > DOT11_DEFAULT_FRAG_LEN)
wl_iw.c:1845:		return -EINVAL;
wl_iw.c:1847:		frag = vwrq->value;
wl_iw.c:1865:	WL_TRACE(("%s: SIOCGIWFRAG\n", dev->name));
wl_iw.c:1870:	vwrq->value = fragthreshold;
wl_iw.c:1871:	vwrq->disabled = (fragthreshold >= DOT11_DEFAULT_FRAG_LEN);
wl_iw.c:1872:	vwrq->fixed = 1;
wl_iw.c:1887:	WL_TRACE(("%s: SIOCSIWTXPOW\n", dev->name));
wl_iw.c:1890:	disable = vwrq->disabled ? WL_RADIO_SW_DISABLE : 0;
wl_iw.c:1902:	if (!(vwrq->flags & IW_TXPOW_MWATT))
wl_iw.c:1903:		return -EINVAL;
wl_iw.c:1906:	if (vwrq->value < 0)
wl_iw.c:1909:	if (vwrq->value > 0xffff) txpwrmw = 0xffff;
wl_iw.c:1910:	else txpwrmw = (uint16)vwrq->value;
wl_iw.c:1928:	WL_TRACE(("%s: SIOCGIWTXPOW\n", dev->name));
wl_iw.c:1936:	vwrq->value = (int32)bcm_qdbm_to_mw(result);
wl_iw.c:1937:	vwrq->fixed = 0;
wl_iw.c:1938:	vwrq->disabled = (disable & (WL_RADIO_SW_DISABLE | WL_RADIO_HW_DISABLE)) ? 1 : 0;
wl_iw.c:1939:	vwrq->flags = IW_TXPOW_MWATT;
wl_iw.c:1955:	WL_TRACE(("%s: SIOCSIWRETRY\n", dev->name));
wl_iw.c:1958:	if (vwrq->disabled || (vwrq->flags & IW_RETRY_LIFETIME))
wl_iw.c:1959:		return -EINVAL;
wl_iw.c:1962:	if (vwrq->flags & IW_RETRY_LIMIT) {
wl_iw.c:1965:		if ((vwrq->flags & IW_RETRY_LONG) ||(vwrq->flags & IW_RETRY_MAX) ||
wl_iw.c:1966:			!((vwrq->flags & IW_RETRY_SHORT) || (vwrq->flags & IW_RETRY_MIN))) {
wl_iw.c:1968:		if ((vwrq->flags & IW_RETRY_MAX) || !(vwrq->flags & IW_RETRY_MIN)) {
wl_iw.c:1971:			lrl = htod32(vwrq->value);
wl_iw.c:1977:		if ((vwrq->flags & IW_RETRY_SHORT) ||(vwrq->flags & IW_RETRY_MIN) ||
wl_iw.c:1978:			!((vwrq->flags & IW_RETRY_LONG) || (vwrq->flags & IW_RETRY_MAX))) {
wl_iw.c:1980:		if ((vwrq->flags & IW_RETRY_MIN) || !(vwrq->flags & IW_RETRY_MAX)) {
wl_iw.c:1983:			srl = htod32(vwrq->value);
wl_iw.c:2002:	WL_TRACE(("%s: SIOCGIWRETRY\n", dev->name));
wl_iw.c:2004:	vwrq->disabled = 0;      /* Can't be disabled */
wl_iw.c:2007:	if ((vwrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME)
wl_iw.c:2008:		return -EINVAL;
wl_iw.c:2019:	if (vwrq->flags & IW_RETRY_MAX) {
wl_iw.c:2020:		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_MAX;
wl_iw.c:2021:		vwrq->value = lrl;
wl_iw.c:2023:		vwrq->flags = IW_RETRY_LIMIT;
wl_iw.c:2024:		vwrq->value = srl;
wl_iw.c:2026:			vwrq->flags |= IW_RETRY_MIN;
wl_iw.c:2044:	WL_TRACE(("%s: SIOCSIWENCODE\n", dev->name));
wl_iw.c:2048:	if ((dwrq->flags & IW_ENCODE_INDEX) == 0) {
wl_iw.c:2062:		key.index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
wl_iw.c:2064:			return -EINVAL;
wl_iw.c:2068:	wsec = (dwrq->flags & IW_ENCODE_DISABLED) ? 0 : WEP_ENABLED;
wl_iw.c:2074:	if (!extra || !dwrq->length || (dwrq->flags & IW_ENCODE_NOKEY)) {
wl_iw.c:2080:		key.len = dwrq->length;
wl_iw.c:2082:		if (dwrq->length > sizeof(key.data))
wl_iw.c:2083:			return -EINVAL;
wl_iw.c:2085:		memcpy(key.data, extra, dwrq->length);
wl_iw.c:2104:			return -EINVAL;
wl_iw.c:2114:	val = (dwrq->flags & IW_ENCODE_RESTRICTED) ? 1 : 0;
wl_iw.c:2133:	WL_TRACE(("%s: SIOCGIWENCODE\n", dev->name));
wl_iw.c:2138:	if ((dwrq->flags & IW_ENCODE_INDEX) == 0) {
wl_iw.c:2149:		key.index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
wl_iw.c:2165:	dwrq->length = MIN(IW_ENCODING_TOKEN_MAX, key.len);
wl_iw.c:2168:	dwrq->flags = key.index + 1;
wl_iw.c:2171:		dwrq->flags |= IW_ENCODE_DISABLED;
wl_iw.c:2175:		dwrq->flags |= IW_ENCODE_RESTRICTED;
wl_iw.c:2179:	if (dwrq->length && extra)
wl_iw.c:2180:		memcpy(extra, key.data, dwrq->length);
wl_iw.c:2195:	WL_TRACE(("%s: SIOCSIWPOWER\n", dev->name));
wl_iw.c:2197:	pm = vwrq->disabled ? PM_OFF : PM_MAX;
wl_iw.c:2216:	WL_TRACE(("%s: SIOCGIWPOWER\n", dev->name));
wl_iw.c:2222:	vwrq->disabled = pm ? 0 : 1;
wl_iw.c:2223:	vwrq->flags = IW_POWER_ALL_R;
wl_iw.c:2237:		dev_wlc_bufvar_set(dev, "wpaie", extra, iwp->length);
wl_iw.c:2250:	WL_TRACE(("%s: SIOCGIWGENIE\n", dev->name));
wl_iw.c:2251:	iwp->length = 64;
wl_iw.c:2252:	dev_wlc_bufvar_get(dev, "wpaie", extra, iwp->length);
wl_iw.c:2268:	WL_TRACE(("%s: SIOCSIWENCODEEXT\n", dev->name));
wl_iw.c:2274:	if (dwrq->flags & IW_ENCODE_DISABLED) {
wl_iw.c:2280:	if (dwrq->flags & IW_ENCODE_INDEX)
wl_iw.c:2281:		key.index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
wl_iw.c:2283:	key.len = iwe->key_len;
wl_iw.c:2286:	if (!ETHER_ISMULTI(iwe->addr.sa_data))
wl_iw.c:2287:		bcopy((void *)&iwe->addr.sa_data, (char *)&key.ea, ETHER_ADDR_LEN);
wl_iw.c:2291:		if (iwe->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
wl_iw.c:2310:	 * to pass the PMK to the in-driver supplicant for use in
wl_iw.c:2311:	 * the 4-way handshake.
wl_iw.c:2313:	else if (iwe->alg == IW_ENCODE_ALG_PMK) {
wl_iw.c:2322:			sprintf(charptr, "%02x", iwe->key[j]);
wl_iw.c:2337:		if (iwe->key_len > sizeof(key.data))
wl_iw.c:2338:			return -EINVAL;
wl_iw.c:2341:		if (iwe->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
wl_iw.c:2346:		bcopy((void *)iwe->key, key.data, iwe->key_len);
wl_iw.c:2348:		if (iwe->alg == IW_ENCODE_ALG_TKIP) {
wl_iw.c:2356:		if (iwe->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
wl_iw.c:2358:			ivptr = (uchar *)iwe->rx_seq;
wl_iw.c:2365:		switch (iwe->alg) {
wl_iw.c:2370:				if (iwe->key_len == WEP1_KEY_SIZE)
wl_iw.c:2399:	pmkid_t foo[MAXPMKID-1];
wl_iw.c:2414:	WL_TRACE(("%s: SIOCSIWPMKSA\n", dev->name));
wl_iw.c:2417:	if (iwpmksa->cmd == IW_PMKSA_FLUSH) {
wl_iw.c:2418:		WL_TRACE(("wl_iw_set_pmksa - IW_PMKSA_FLUSH\n"));
wl_iw.c:2421:	if (iwpmksa->cmd == IW_PMKSA_REMOVE) {
wl_iw.c:2424:		bcopy(&iwpmksa->bssid.sa_data[0], &pmkidptr->pmkid[0].BSSID, ETHER_ADDR_LEN);
wl_iw.c:2425:		bcopy(&iwpmksa->pmkid[0], &pmkidptr->pmkid[0].PMKID, WPA2_PMKID_LEN);
wl_iw.c:2428:			WL_TRACE(("wl_iw_set_pmksa,IW_PMKSA_REMOVE - PMKID: %s = ",
wl_iw.c:2429:				bcm_ether_ntoa(&pmkidptr->pmkid[0].BSSID,
wl_iw.c:2432:				WL_TRACE(("%02x ", pmkidptr->pmkid[0].PMKID[j]));
wl_iw.c:2436:			if (!bcmp(&iwpmksa->bssid.sa_data[0], &pmkid_array[i].BSSID,
wl_iw.c:2447:		pmkid_list.pmkids.npmkid--;
wl_iw.c:2449:	if (iwpmksa->cmd == IW_PMKSA_ADD) {
wl_iw.c:2450:		bcopy(&iwpmksa->bssid.sa_data[0],
wl_iw.c:2453:		bcopy(&iwpmksa->pmkid[0], &pmkid_array[pmkid_list.pmkids.npmkid].PMKID,
wl_iw.c:2460:			WL_TRACE(("wl_iw_set_pmksa,IW_PMKSA_ADD - PMKID: %s = ",
wl_iw.c:2469:	WL_TRACE(("PRINTING pmkid LIST - No of elements %d\n", pmkid_list.pmkids.npmkid));
wl_iw.c:2493:	WL_TRACE(("%s: SIOCGIWENCODEEXT\n", dev->name));
wl_iw.c:2512:	WL_TRACE(("%s: SIOCSIWAUTH\n", dev->name));
wl_iw.c:2514:	paramid = vwrq->flags & IW_AUTH_INDEX;
wl_iw.c:2515:	paramval = vwrq->value;
wl_iw.c:2518:		dev->name, paramid, paramval));
wl_iw.c:2539:			iw->pwsec = paramval;
wl_iw.c:2542:			iw->gwsec = paramval;
wl_iw.c:2548:		cipher_combined = iw->gwsec | iw->pwsec;
wl_iw.c:2557:		if (iw->privacy_invoked && !val) {
wl_iw.c:2559:			         "we're a WPS enrollee\n", dev->name, __FUNCTION__));
wl_iw.c:2654:			iw->privacy_invoked = FALSE;
wl_iw.c:2660:			iw->privacy_invoked = TRUE;
wl_iw.c:2705:	WL_TRACE(("%s: SIOCGIWAUTH\n", dev->name));
wl_iw.c:2707:	paramid = vwrq->flags & IW_AUTH_INDEX;
wl_iw.c:2723:		paramval = iw->pwsec;
wl_iw.c:2727:		paramval = iw->gwsec;
wl_iw.c:2778:		paramval = iw->privacy_invoked;
wl_iw.c:2783:	vwrq->value = paramval;
wl_iw.c:2808:	(iw_handler) NULL,			/* -- hole -- */
wl_iw.c:2809:	(iw_handler) NULL,			/* -- hole -- */
wl_iw.c:2815:	(iw_handler) NULL,			/* -- hole -- */
wl_iw.c:2829:	(iw_handler) NULL,			/* -- hole -- */
wl_iw.c:2830:	(iw_handler) NULL,			/* -- hole -- */
wl_iw.c:2848:	(iw_handler) NULL,			/* -- hole -- */
wl_iw.c:2849:	(iw_handler) NULL,			/* -- hole -- */
wl_iw.c:2925:		return -EOPNOTSUPP;
wl_iw.c:2957:		max_tokens = wrq->u.data.length;
wl_iw.c:2976:	if (max_tokens && wrq->u.data.pointer) {
wl_iw.c:2977:		if (wrq->u.data.length > max_tokens)
wl_iw.c:2978:			return -E2BIG;
wl_iw.c:2981:			return -ENOMEM;
wl_iw.c:2983:		if (copy_from_user(extra, wrq->u.data.pointer, wrq->u.data.length * token_size)) {
wl_iw.c:2985:			return -EFAULT;
wl_iw.c:2992:	ret = handler(dev, &info, &wrq->u, extra);
wl_iw.c:2995:		if (copy_to_user(wrq->u.data.pointer, extra, wrq->u.data.length * token_size)) {
wl_iw.c:2997:			return -EFAULT;
wl_iw.c:3067:		if (row->inEvent == event_type &&
wl_iw.c:3068:		    (row->inStatus == status || row->inStatus == WL_IW_DONT_CARE) &&
wl_iw.c:3069:		    (row->inReason == reason || row->inReason == WL_IW_DONT_CARE)) {
wl_iw.c:3070:			name = row->outName;
wl_iw.c:3071:			cause = row->outCause;
wl_iw.c:3096:	uint32 event = ntoh32(e->event_type);
wl_iw.c:3097:	uint32 status =  ntoh32(e->status);
wl_iw.c:3098:	uint32 reason =  ntoh32(e->reason);
wl_iw.c:3120:	uint32 event_type = ntoh32(e->event_type);
wl_iw.c:3121:	uint16 flags =  ntoh16(e->flags);
wl_iw.c:3122:	uint32 datalen = ntoh32(e->datalen);
wl_iw.c:3123:	uint32 status =  ntoh32(e->status);
wl_iw.c:3128:	memcpy(wrqu.addr.sa_data, &e->addr, ETHER_ADDR_LEN);
wl_iw.c:3184:			micerrevt->flags |= IW_MICFAILURE_GROUP;
wl_iw.c:3186:			micerrevt->flags |= IW_MICFAILURE_PAIRWISE;
wl_iw.c:3187:		memcpy(micerrevt->src_addr.sa_data, &e->addr, ETHER_ADDR_LEN);
wl_iw.c:3188:		micerrevt->src_addr.sa_family = ARPHRD_ETHER;
wl_iw.c:3218:		count = ntoh32_ua((uint8 *)&pmkcandlist->npmkid_cand);
wl_iw.c:3220:		pmkidcand = pmkcandlist->pmkid_cand;
wl_iw.c:3223:			if (pmkidcand->preauth)
wl_iw.c:3224:				iwpmkidcand->flags |= IW_PMKID_CAND_PREAUTH;
wl_iw.c:3225:			bcopy(&pmkidcand->BSSID, &iwpmkidcand->bssid.sa_data,
wl_iw.c:3229:			count--;
wl_iw.c:3240:		if ((g_iscan) && (g_iscan->sysioc_pid >= 0) &&
wl_iw.c:3241:			(g_iscan->iscan_state != ISCAN_STATE_IDLE))
wl_iw.c:3242:			up(&g_iscan->sysioc_sem);
wl_iw.c:3294:		wstats->qual.qual = 0;
wl_iw.c:3296:		wstats->qual.qual = 1;
wl_iw.c:3298:		wstats->qual.qual = 2;
wl_iw.c:3300:		wstats->qual.qual = 3;
wl_iw.c:3302:		wstats->qual.qual = 4;
wl_iw.c:3304:		wstats->qual.qual = 5;
wl_iw.c:3307:	wstats->qual.level = 0x100 + rssi;
wl_iw.c:3308:	wstats->qual.noise = 0x100 + phy_noise;
wl_iw.c:3310:	wstats->qual.updated |= (IW_QUAL_ALL_UPDATED | IW_QUAL_DBM);
wl_iw.c:3312:	wstats->qual.updated |= 7;
wl_iw.c:3333:	wstats->discard.nwid = 0;
wl_iw.c:3334:	wstats->discard.code = dtoh32(cnt.rxundec);
wl_iw.c:3335:	wstats->discard.fragment = dtoh32(cnt.rxfragerr);
wl_iw.c:3336:	wstats->discard.retries = dtoh32(cnt.txfail);
wl_iw.c:3337:	wstats->discard.misc = dtoh32(cnt.rxrunt) + dtoh32(cnt.rxgiant);
wl_iw.c:3338:	wstats->miss.beacon = 0;
wl_iw.c:3360:	iscan->timer_on = 0;
wl_iw.c:3361:	if (iscan->iscan_state != ISCAN_STATE_IDLE) {
wl_iw.c:3363:		up(&iscan->sysioc_sem);
wl_iw.c:3386:	memcpy(&params->bssid, &ether_bcast, ETHER_ADDR_LEN);
wl_iw.c:3387:	params->bss_type = DOT11_BSSTYPE_ANY;
wl_iw.c:3388:	params->scan_type = 0;
wl_iw.c:3389:	params->nprobes = -1;
wl_iw.c:3390:	params->active_time = -1;
wl_iw.c:3391:	params->passive_time = -1;
wl_iw.c:3392:	params->home_time = -1;
wl_iw.c:3393:	params->channel_num = 0;
wl_iw.c:3395:	params->nprobes = htod32(params->nprobes);
wl_iw.c:3396:	params->active_time = htod32(params->active_time);
wl_iw.c:3397:	params->passive_time = htod32(params->passive_time);
wl_iw.c:3398:	params->home_time = htod32(params->home_time);
wl_iw.c:3399:	if (ssid && ssid->SSID_len)
wl_iw.c:3400:		memcpy(&params->ssid, ssid, sizeof(wlc_ssid_t));
wl_iw.c:3412:	if (ssid && ssid->SSID_len) {
wl_iw.c:3417:		return -ENOMEM;
wl_iw.c:3422:	err = wl_iw_iscan_prep(&params->params, ssid);
wl_iw.c:3425:		params->version = htod32(ISCAN_REQ_VERSION);
wl_iw.c:3426:		params->action = htod16(action);
wl_iw.c:3427:		params->scan_duration = htod16(0);
wl_iw.c:3430:		(void) dev_iw_iovar_setbuf(iscan->dev, "iscan", params, params_size,
wl_iw.c:3431:			iscan->ioctlbuf, WLC_IOCTL_SMLEN);
wl_iw.c:3449:	if (iscan->list_cur) {
wl_iw.c:3450:		buf = iscan->list_cur;
wl_iw.c:3451:		iscan->list_cur = buf->next;
wl_iw.c:3457:		buf->next = NULL;
wl_iw.c:3458:		if (!iscan->list_hdr)
wl_iw.c:3459:			iscan->list_hdr = buf;
wl_iw.c:3461:			ptr = iscan->list_hdr;
wl_iw.c:3462:			while (ptr->next) {
wl_iw.c:3463:				ptr = ptr->next;
wl_iw.c:3465:			ptr->next = buf;
wl_iw.c:3468:	memset(buf->iscan_buf, 0, WLC_IW_ISCAN_MAXLEN);
wl_iw.c:3469:	list_buf = (wl_iscan_results_t*)buf->iscan_buf;
wl_iw.c:3470:	results = &list_buf->results;
wl_iw.c:3471:	results->buflen = WL_ISCAN_RESULTS_FIXED_SIZE;
wl_iw.c:3472:	results->version = 0;
wl_iw.c:3473:	results->count = 0;
wl_iw.c:3478:		iscan->dev,
wl_iw.c:3482:		buf->iscan_buf,
wl_iw.c:3484:	results->buflen = dtoh32(results->buflen);
wl_iw.c:3485:	results->version = dtoh32(results->version);
wl_iw.c:3486:	results->count = dtoh32(results->count);
wl_iw.c:3487:	WL_TRACE(("results->count = %d\n", results->count));
wl_iw.c:3489:	WL_TRACE(("results->buflen = %d\n", results->buflen));
wl_iw.c:3490:	status = dtoh32(list_buf->status);
wl_iw.c:3501:	wireless_send_event(iscan->dev, SIOCGIWSCAN, &wrqu, NULL);
wl_iw.c:3513:	while (down_interruptible(&iscan->sysioc_sem) == 0) {
wl_iw.c:3514:		if (iscan->timer_on) {
wl_iw.c:3515:			del_timer(&iscan->timer);
wl_iw.c:3516:			iscan->timer_on = 0;
wl_iw.c:3539:				iscan->timer.expires = jiffies + msecs_to_jiffies(iscan->timer_ms);
wl_iw.c:3540:				add_timer(&iscan->timer);
wl_iw.c:3541:				iscan->timer_on = 1;
wl_iw.c:3545:				iscan->iscan_state = ISCAN_STATE_IDLE;
wl_iw.c:3551:				iscan->timer.expires = jiffies + msecs_to_jiffies(iscan->timer_ms);
wl_iw.c:3552:				add_timer(&iscan->timer);
wl_iw.c:3553:				iscan->timer_on = 1;
wl_iw.c:3557:				iscan->iscan_state = ISCAN_STATE_IDLE;
wl_iw.c:3565:	complete_and_exit(&iscan->sysioc_exited, 0);
wl_iw.c:3578:		return -ENOMEM;
wl_iw.c:3580:	iscan->sysioc_pid = -1;
wl_iw.c:3583:	iscan->dev = dev;
wl_iw.c:3584:	iscan->iscan_state = ISCAN_STATE_IDLE;
wl_iw.c:3588:	iscan->timer_ms    = 2000;
wl_iw.c:3589:	init_timer(&iscan->timer);
wl_iw.c:3590:	iscan->timer.data = (ulong)iscan;
wl_iw.c:3591:	iscan->timer.function = wl_iw_timerfunc;
wl_iw.c:3593:	sema_init(&iscan->sysioc_sem, 0);
wl_iw.c:3594:	init_completion(&iscan->sysioc_exited);
wl_iw.c:3595:	iscan->sysioc_pid = kernel_thread(_iscan_sysioc_thread, iscan, 0);
wl_iw.c:3596:	if (iscan->sysioc_pid < 0)
wl_iw.c:3597:		return -ENOMEM;
wl_iw.c:3607:	if (iscan->sysioc_pid >= 0) {
wl_iw.c:3608:		KILL_PROC(iscan->sysioc_pid, SIGTERM);
wl_iw.c:3609:		wait_for_completion(&iscan->sysioc_exited);
wl_iw.c:3612:	while (iscan->list_hdr) {
wl_iw.c:3613:		buf = iscan->list_hdr->next;
wl_iw.c:3614:		kfree(iscan->list_hdr);
wl_iw.c:3615:		iscan->list_hdr = buf;
wl_iw.h:4: * Copyright (C) 1999-2012, Broadcom Corporation
wl_iw.h:24: * $Id: wl_iw.h 291086 2011-10-21 01:17:24Z $
wl_iw.h:51:/* Lin - Is the extra space needed? */
wl_iw.h:66:	char iso_abbrev[WLC_CNTRY_BUF_SZ];	/* ISO 3166-1 country abbreviation */
wl_iw.h:68:	int32 custom_locale_rev;		/* Custom local revisin default -1 */
wl_iw.h:72:#define	WL_IW_RSSI_MINVAL		-200	/* Low value, e.g. for forcing roam */
wl_iw.h:73:#define	WL_IW_RSSI_NO_SIGNAL	-91	/* NDIS RSSI link quality cutoffs */
wl_iw.h:74:#define	WL_IW_RSSI_VERY_LOW	-80	/* Very low quality cutoffs */
wl_iw.h:75:#define	WL_IW_RSSI_LOW		-70	/* Low quality cutoffs */
wl_iw.h:76:#define	WL_IW_RSSI_GOOD		-68	/* Good quality cutoffs */
wl_iw.h:77:#define	WL_IW_RSSI_VERY_GOOD	-58	/* Very good quality cutoffs */
wl_iw.h:78:#define	WL_IW_RSSI_EXCELLENT	-57	/* Excellent quality cutoffs */
wl_linux_mon.c:4: * Copyright (C) 1999-2012, Broadcom Corporation
wl_linux_mon.c:24: * $Id: dhd_linux_mon.c 280623 2011-08-30 14:49:39Z $
wl_linux_mon.c:62:#define MON_PRINT(format, ...) printk("DHD-MON: %s " format, __func__, ##__VA_ARGS__)
wl_linux_mon.c:105: * "p2p-eth0-0" is a match for "mon.p2p-eth0-0")
wl_linux_mon.c:116:	/* We need to find interface "p2p-p2p-0" corresponding to monitor interface "mon-p2p-0",
wl_linux_mon.c:117:	 * Once mon iface name reaches IFNAMSIZ, it is reset to p2p0-0 and corresponding mon
wl_linux_mon.c:118:	 * iface would be mon-p2p0-0.
wl_linux_mon.c:123:		/* Skip "p2p" and look for "-p2p0-x" in monitor interface name. If it
wl_linux_mon.c:126:		if (ndev && strstr(ndev->name, "p2p-p2p0")) {
wl_linux_mon.c:129:		/* if p2p- is not present, then the IFNAMSIZ have reached and name
wl_linux_mon.c:130:		 * would have got reset. In this casse,look for p2p0-x in mon-p2p0-x
wl_linux_mon.c:134:		if (ndev && strstr(name, (ndev->name + len))) {
wl_linux_mon.c:135:			if (strlen(ndev->name) > last_name_len) {
wl_linux_mon.c:137:				last_name_len = strlen(ndev->name);
wl_linux_mon.c:191:	if (mon_if == NULL || mon_if->real_ndev == NULL) {
wl_linux_mon.c:196:	if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))
wl_linux_mon.c:199:	rtap_hdr = (struct ieee80211_radiotap_header *)skb->data;
wl_linux_mon.c:200:	if (unlikely(rtap_hdr->it_version))
wl_linux_mon.c:203:	rtap_len = ieee80211_get_radiotap_len(skb->data);
wl_linux_mon.c:204:	if (unlikely(skb->len < rtap_len))
wl_linux_mon.c:212:	dot11_hdr = (struct ieee80211_hdr *)skb->data;
wl_linux_mon.c:213:	frame_ctl = le16_to_cpu(dot11_hdr->frame_control);
wl_linux_mon.c:219:		if (dot11_hdr->frame_control & 0x0080)
wl_linux_mon.c:221:		if ((dot11_hdr->frame_control & 0x0300) == 0x0300)
wl_linux_mon.c:224:		memcpy(dst_mac_addr, dot11_hdr->addr1, sizeof(dst_mac_addr));
wl_linux_mon.c:225:		memcpy(src_mac_addr, dot11_hdr->addr2, sizeof(src_mac_addr));
wl_linux_mon.c:230:		skb_pull(skb, dot11_hdr_len + qos_len + snap_len - sizeof(src_mac_addr) * 2);
wl_linux_mon.c:231:		pdata = (unsigned char*)skb->data;
wl_linux_mon.c:236:		MON_PRINT("if name: %s, matched if name %s\n", ndev->name, mon_if->real_ndev->name);
wl_linux_mon.c:239:		ret = dhd_start_xmit(skb, mon_if->real_ndev);
wl_linux_mon.c:253:	if (mon_if == NULL || mon_if->real_ndev == NULL) {
wl_linux_mon.c:257:		ndev->name, mon_if->real_ndev->name);
wl_linux_mon.c:267:	if (mon_if == NULL || mon_if->real_ndev == NULL) {
wl_linux_mon.c:271:		ndev->name, mon_if->real_ndev->name);
wl_linux_mon.c:283:	int idx = -1;
wl_linux_mon.c:293:		ret = -EINVAL;
wl_linux_mon.c:305:	if (idx == -1) {
wl_linux_mon.c:307:		ret = -EFAULT;
wl_linux_mon.c:314:		ret = -ENOMEM;
wl_linux_mon.c:318:	ndev->type = ARPHRD_IEEE80211_RADIOTAP;
wl_linux_mon.c:319:	strncpy(ndev->name, name, IFNAMSIZ);
wl_linux_mon.c:320:	ndev->name[IFNAMSIZ - 1] = 0;
wl_linux_mon.c:321:	ndev->netdev_ops = &dhd_mon_if_ops;
wl_linux_mon.c:337:	MON_PRINT("found a matched net device, name %s\n", g_monitor.mon_if[idx].real_ndev->name);
wl_linux_mon.c:353:		return -EINVAL;
